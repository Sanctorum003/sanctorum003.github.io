<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE4 反射机制</title>
      <link href="/2021/09/04/CG/UE4/EngineBottom/UE4_ReflectionMechanism/"/>
      <url>/2021/09/04/CG/UE4/EngineBottom/UE4_ReflectionMechanism/</url>
      
        <content type="html"><![CDATA[<ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/60622181" target="_blank" rel="noopener">UE4反射机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/24319968" target="_blank" rel="noopener">《InsideUE4》UObject（一）开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/24445322" target="_blank" rel="noopener">《InsideUE4》UObject（二）类型系统概述</a></li><li><a href="https://www.jianshu.com/p/1f2de6ea383c" target="_blank" rel="noopener">UE4对象系统_UObject&amp;UClass</a></li><li><a href="https://zhuanlan.zhihu.com/p/400473355" target="_blank" rel="noopener">UE — UBT、UHT与反射基本理解</a></li></ul></li></ul><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><ul><li>Java反射机制：是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍可扩展。<blockquote><p>java加载类的时候是将.class加载到内存并生成相关内存映像，在内存中的.class内存映像中含有类的各种数据，之后生成对象都是用内存中相应的.class，因此通过修改该信息还能动态改变类的数据。</p></blockquote></li></ul><h2 id="U4反射"><a href="#U4反射" class="headerlink" title="U4反射"></a>U4反射</h2><ul><li>反射用于在是在程序运行时动态加载类以及获取类的信息，反射数据描述了类在运行时的内容</li><li>这些数据所存储的信息包括类的名称、类中的数据成员、每个数据成员的类型、每个成员位于对象内存映像的偏移（offset），此外，它也包含类的所有成员函数信息。</li></ul><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><ul><li>指的是程序运行空间内构建出来的类型信息树组织</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>描述运行时得到类型的功能，通过类型信息反过来创建对象，读取修改属性，调用方法的功能行为</li></ul><h1 id="反射有什么用"><a href="#反射有什么用" class="headerlink" title="反射有什么用"></a>反射有什么用</h1><ul><li>实现序列化</li><li>实现editor的details panel</li><li>垃圾回收</li><li>网络复制</li><li>蓝图/C++通信和相互调用</li></ul><h1 id="U4如何实现反射机制"><a href="#U4如何实现反射机制" class="headerlink" title="U4如何实现反射机制"></a>U4如何实现反射机制</h1><h2 id="C-RTTI"><a href="#C-RTTI" class="headerlink" title="C++ RTTI"></a>C++ RTTI</h2><p>C++中的运行时类型系统功能太弱，无法支持反射系统的功能</p><ul><li>typeid/typeinfo<blockquote><p>这个关键字的主要作用就是用于让用户知道是什么类型，并提供一些基本对比和name方法，作用也顶多只是让用户判断从属于不同的类型，所以其实说起来type_info的应用并不广泛，一般来说也只是把它当作编译器提供的一个唯一类型Id。</p></blockquote></li><li>dynamic_cast<blockquote><p>dynamic_cast内部机制其实也是利用虚函数表里的类型信息来判断一个基类指针是否指向一个派生类对象。其目的更多是用于在运行时判断对象指针是否为特定一个子类的对象。</p></blockquote></li></ul><h2 id="UE4反射"><a href="#UE4反射" class="headerlink" title="UE4反射"></a>UE4反射</h2><ul><li><p>UE4反射系统主要依靠2个工具,UHT和UBT，还需要UObject和UClass的支持.</p><blockquote><p>UObject是所有支持反射的对象的基类，有类的StaticClass()或者实例的GetClass()来获取反射信息<br>UClass（相当于是元数据）继承自UStrcut-&gt;UField，用于存储反射数据。</p></blockquote></li><li><p>UE4 中的反射大概的流程是在编译前利用 UnrealHeaderTool 对代码文件内容进行处理，生成 .generated.h/.gen.cpp 文件，在生成的代码中加入反射信息，并和自己编写的代码一起编译，在运行时动态地将这些反射信息收集起来使用。</p></li></ul><h3 id="UBT"><a href="#UBT" class="headerlink" title="UBT"></a>UBT</h3><h4 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h4><ul><li>是一个自定义工具，负责管理通过各种编译配置来编译虚幻引擎4（UE4）源代码的过程。<ul><li>该工具处理所有复杂的项目编译工作，编译UE4的逐个模块并处理依赖等<ul><li>Target.cs，Build.cs</li></ul></li></ul></li></ul><h3 id="UHT"><a href="#UHT" class="headerlink" title="UHT"></a>UHT</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>用于生成C++的反射代码<h4 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h4></li><li>UHT被编译成exe文件，通过命令行参数调用</li><li>UE4的反射系统并不是把所有的信息都纳入，而是需要程序员标记才会被反射系统纳入</li><li>UHT会扫描文件，如果其中有<code>#include &quot;file.generated.h&quot;</code>,就是告知UHT该头文件需要被纳入反射系统之中.然后UHT会根本相关的宏标记，<code>UCLASS()</code>,<code>UFUNCTION</code>，<code>GENERATED_BODY()</code>来解析头文件中的定义，，最终生成<code>#include &quot;file.generated.h&quot;</code>和<code>#include &quot;file.generated.cpp&quot;</code>两个文件，其中包含了用于实现反射的相关代码。其中主要做的工作是将C++类中的真实数据成员和UClass（用于存储反射数据的类）中的UPorperty等数据类型绑定起来。</li></ul><h3 id="UE4完整编译流程"><a href="#UE4完整编译流程" class="headerlink" title="UE4完整编译流程"></a>UE4完整编译流程</h3><blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/400473355" target="_blank" rel="noopener">UE — UBT、UHT与反射基本理解</a></p><ul><li>UBT搜集目录中的.cs文件</li><li>然后UBT调用UHT分析需要分析的.h .cpp文件（典型根据文件是否含有#include”FileName.generated.h”，是否有UCLASS()、UPROPERTY等宏）生成generated.h和gen.cpp文件</li><li>最后UBT调用MSBuild，将.h.cpp和generated.h gen.cpp结合到一起然后编译</li></ul><hr><ul><li>UBT通过扫描头文件时，记录所有包含反射类型的modules（模块），当其中有头文件改变时，就会用UHT更新反射数据。UHT解析头文件，扫描标记，生成用于支持反射的C++代码</li></ul></blockquote><h3 id="使用反射系统"><a href="#使用反射系统" class="headerlink" title="使用反射系统"></a>使用反射系统</h3><ul><li>你可以通过使用UTypeName::StaticClass()或者FTypeName::StaticStruct()来获取反射类型对应的UClass以及UScriptStruct，你也通过 一个UObject的实例通过Instance-&gt;GetClass()来获取类型（不能通过一个结构体实例的获取类型，因为结构体没有一个通用的基类或者需要的存储空间）。</li></ul><h3 id="为什么用c-代码存储反射数据"><a href="#为什么用c-代码存储反射数据" class="headerlink" title="为什么用c++代码存储反射数据"></a>为什么用c++代码存储反射数据</h3><ul><li>用生成的C++代码来存储反射数据的一个最大好处就是，它可以保证跟二进制做到同步。你永远也不会加载陈旧或者过时的反射数据，因为它是跟引擎的其它代码同时编译的.</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> EngineBottom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/2021/08/26/LeetCode/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/08/26/LeetCode/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h1><h2 id="为什么快慢指针一定会相遇"><a href="#为什么快慢指针一定会相遇" class="headerlink" title="为什么快慢指针一定会相遇"></a>为什么快慢指针一定会相遇</h2><p><img src="环形链表.png" alt></p><hr><ul><li>如图,假设非环长<code>a</code>,环长<code>b</code>,相遇时距离入环口<code>c</code>.  </li><li>假设快指针每次移动<code>2</code>个单位,慢指针每次移动<code>1</code>个单位.</li><li>当慢指针走到环的入口时,移动了<code>a</code>的单位,此时快指针移动了<code>2a</code>个单位.</li><li>此时快指针在环中的位置是(2a-a)%b = <code>a%b</code></li><li>此时快慢指针相距<code>b - a%b</code>的距离.</li><li>由于快指针每次比慢指针多移动<code>1</code>个单位,则还需<code>b-a%b</code>次移动两者相遇.</li></ul><h2 id="两者需要移动多少次才能相遇"><a href="#两者需要移动多少次才能相遇" class="headerlink" title="两者需要移动多少次才能相遇"></a>两者需要移动多少次才能相遇</h2><ul><li><code>a + b - a%b</code></li></ul><h2 id="为什么慢指针入环第一圈没走完的时候就会和快指针相遇-慢指针要走多少圈才能和快指针相遇"><a href="#为什么慢指针入环第一圈没走完的时候就会和快指针相遇-慢指针要走多少圈才能和快指针相遇" class="headerlink" title="为什么慢指针入环第一圈没走完的时候就会和快指针相遇?/慢指针要走多少圈才能和快指针相遇"></a>为什么慢指针入环第一圈没走完的时候就会和快指针相遇?/慢指针要走多少圈才能和快指针相遇</h2><ul><li>根据上述推导,在慢指针如环的时候,快指针在<code>a%b</code>处</li><li>只需再走<code>b-a%b</code>就能相遇(b-a%b &lt; b)</li></ul><h2 id="为什么快指针移动2步-移动其他步数可以吗"><a href="#为什么快指针移动2步-移动其他步数可以吗" class="headerlink" title="为什么快指针移动2步,移动其他步数可以吗."></a>为什么快指针移动2步,移动其他步数可以吗.</h2><ul><li>如果快指针每次移动<code>x</code>步，x&gt;1.</li><li>当慢指针走到环的入口时,移动了<code>a</code>的单位,此时快指针移动了<code>xa</code>个单位.</li><li>此时快指针在环中的位置是(xa-a)%b = <code>[(x-1)a]%b</code></li><li>此时快慢指针相距<code>b - [(x-1)a]%b</code>的距离.</li><li>那么最终则需要 <code>a + (b - [(x-1)a]%b)/(x-1)</code>步才能相遇,此时该值不一定是整数,所以移动其他步数不一定相遇.</li></ul><h3 id="为什么第一次不相遇，之后就不可能相遇"><a href="#为什么第一次不相遇，之后就不可能相遇" class="headerlink" title="为什么第一次不相遇，之后就不可能相遇."></a>为什么第一次不相遇，之后就不可能相遇.</h3><ul><li>假设慢指针在环入口的位置走了<code>a+nb</code>步.</li><li>则快指针<code>xa+xnb</code>步,其中<code>xnb</code>相当于绕环xn圈,相当于此时快指针一定在距离环<code>xa</code>处,重复上述的操作.</li></ul><h2 id="如何找到入环结点"><a href="#如何找到入环结点" class="headerlink" title="如何找到入环结点"></a>如何找到入环结点</h2><ul><li>根据上述推导后</li><li>当快指针和慢指针相遇的位置是: <code>a + nb + (b - a%b)</code>(nb为快指针绕环的圈数)</li><li>又因为<code>慢指针在第一圈一定能和快指针相遇</code>,所以快指针的位置还等于慢指针的2倍，即: <code>2(a+ b - a%b)</code></li><li>联立两者得: <code>a = (n-1)*b + a%b</code></li><li>我们知道快慢指针相遇时的位置是<code>b-a%b</code>,我们加上a得:<code>b - a%b + a</code> = <code>b-a%b +(n-1)*b + a%b</code> = <code>n*b</code></li><li>所以我们只要让相遇时的指针再走a个单位就能到入环结点.</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程并发</title>
      <link href="/2021/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MultiThreads/C++_MultiThreads/"/>
      <url>/2021/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/MultiThreads/C++_MultiThreads/</url>
      
        <content type="html"><![CDATA[<ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/194198073" target="_blank" rel="noopener">C++多线程并发基础入门教程</a></li></ul><h1 id="什么是C-多线程并发"><a href="#什么是C-多线程并发" class="headerlink" title="什么是C++多线程并发"></a>什么是C++多线程并发</h1><ul><li>线程</li><li>多线程并发<blockquote><p>多线程并发即多个线程同时执行,一般而言，多线程并发就是把一个任务拆分为多个子任务，然后交由不同线程处理不同子任务,使得这多个子任务同时执行</p></blockquote></li><li>C++多线程并发<blockquote><p>实现C++多线程并发程序的思路如下：将任务的不同功能交由多个函数分别实现，创建多个线程，每个线程执行一个函数，一个任务就这样同时分由不同线程执行了。</p></blockquote></li></ul><h2 id="什么时候不适用多线程并发"><a href="#什么时候不适用多线程并发" class="headerlink" title="什么时候不适用多线程并发"></a>什么时候不适用多线程并发</h2><ul><li>每创建一个线程,系统要分配给线程相应的栈空间，用于保存上下文信息.</li><li>如果线程执行过快导致上下文切换频繁，这将导致收益比不上成本</li></ul><h1 id="C-多线程并发基础知识"><a href="#C-多线程并发基础知识" class="headerlink" title="C++多线程并发基础知识"></a>C++多线程并发基础知识</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="std-ref和std-cref-std-bind"><a href="#std-ref和std-cref-std-bind" class="headerlink" title="std::ref和std::cref /std::bind"></a>std::ref和std::cref /std::bind</h3><ul><li>std::ref 用于包装按引用传递的值</li><li>std::cref 用于包装按const引用传递的值</li></ul><h3 id="为什么线程函数不能传引用"><a href="#为什么线程函数不能传引用" class="headerlink" title="为什么线程函数不能传引用"></a>为什么线程函数不能传引用</h3><ul><li><a href="https://www.zhihu.com/question/38273897" target="_blank" rel="noopener">C++传递参数给线程函数时出现问题？</a><blockquote><p>C++封装thread是通过将thread entry functor和所有的参数打包到一个数据结构里，然后通过库中的一个预先写好的OS compatible thread entry function启动线程，在这个函数中将传进去的数据结构解包再运行。</p></blockquote></li></ul><blockquote><p>这个过程需要将所有的参数copy/move一份，而众所周知引用本身是不能copy/move的，所以C++在标准库里加入了std::reference_wrapper，这个东西其实很无聊，就是把引用变成指针存起来，用的时候再转成引用，但这样就解决了引用不能copy/move的问题，因为指针是可以copy的，而std::ref/std::cref就是返回std::reference_wrapper的builder function。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code class="lang-cpp">//创建线程std::thread THREAD_NAME(FUNCTION_NAME,PARAM...);//当线程启动后，一定要在和线程相关联的std::thread对象销毁前，对线程运用join()或者detach()方法。//当使用join()函数时，主调线程阻塞，等待被调线程终止，然后主调线程回收被调线程资源，并继续运行；THREAD_NAME::join();//当使用detach()函数时，主调线程继续运行，被调线程驻留后台运行，主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。THREAD_NAME::detach();//joinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程(能被join或者detach)，因为相同的线程不能join两次，也不能join完再detach，同理也不能detach，所以joinable函数就是用来判断当前这个线程是否可以joinable的。THREAD_NAME::joinable();</code></pre><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;thread&gt;using namespace std;void proc(int &amp;a){    cout &lt;&lt; &quot;我是子线程,传入参数为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;子线程中显示子线程id为&quot; &lt;&lt; this_thread::get_id()&lt;&lt; endl;}int main(){    cout &lt;&lt; &quot;我是主线程&quot; &lt;&lt; endl;    int a = 9;    thread th2(proc,ref(a));//第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。    th2.join();//此时主线程被阻塞直至子线程执行结束。    cout &lt;&lt; &quot;主线程中显示子线程id为&quot; &lt;&lt; th2.get_id() &lt;&lt; endl;    return 0;}</code></pre><h3 id="创建线程时的传参问题分析"><a href="#创建线程时的传参问题分析" class="headerlink" title="创建线程时的传参问题分析"></a>创建线程时的传参问题分析</h3><ul><li>创建线程时需要传递函数名作为参数，提供的函数对象会复制到新的线程的内存空间中执行与调用。</li><li>在传参过程中,std::thread的构造函数会拷贝传入的参数<ul><li>当传入参数为基本数据类型(int，char,string等)时，会拷贝一份给创建的线程；</li><li>当传入参数为指针时，会浅拷贝一份给创建的线程，也就是说，只会拷贝对象的指针，不会拷贝指针指向的对象本身。</li><li>当传入的参数为引用时，实参必须用ref()函数处理后传递给形参，否则编译不通过，此时不存在“拷贝”行为<ul><li>引用只是变量的别名，在线程中传递对象的引用，那么该对象始终只有一份，只是存在多个别名罢了</li><li>对于std::ref,其底层相当于拷贝指针,但是在解释的时候，使用引用解释.</li></ul></li></ul></li></ul><h1 id="互斥量（锁）使用"><a href="#互斥量（锁）使用" class="headerlink" title="互斥量（锁）使用"></a>互斥量（锁）使用</h1><h2 id="什么是互斥量（锁）"><a href="#什么是互斥量（锁）" class="headerlink" title="什么是互斥量（锁）"></a>什么是互斥量（锁）</h2><ul><li>在访问共享数据时,代码进入临界区，对于多个线程需要互斥访问这时候需要使用互斥量(锁)<blockquote><p>互斥量是为了解决数据共享过程中可能存在的访问冲突的问题</p></blockquote></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="临界区、信号量、互斥量（锁）的区别与联系："><a href="#临界区、信号量、互斥量（锁）的区别与联系：" class="headerlink" title="临界区、信号量、互斥量（锁）的区别与联系："></a>临界区、信号量、互斥量（锁）的区别与联系：</h2><ul><li>共同点:<ul><li>三者都可以用来进行进程的同步与互斥</li></ul></li><li>不同点:<ul><li>临界区:速度最快，但只能作用于同一进程下不同线程，不能作用于不同进程；临界区可确保某一代码段同一时刻只被一个线程执行；</li><li>信号量:多个线程同一时刻访问共享资源，进行线程的计数，确保同时访问资源的线程数目不超过上限，当访问数超过上限后，不发出信号量；</li><li>互斥量:比临界区满，但支持不同进程间的同步与互斥</li></ul></li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>任务运行时，有些任务片段间存在严格的先后顺序，同步指维护任务片段的先后顺序;</li><li>互斥就是保证资源同一时刻只能被一个进程使用；互斥是为了保证数据的一致性</li></ul><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li>互斥量mutex就是互斥锁，加锁的资源支持互斥访问；<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3></li><li>shared_mutex读写锁把对共享资源的访问者划分成读者和写者，多个读线程能同时读取共享资源，但只有一个写线程能同时读取共享资源</li><li>shared_mutex通过lock_shared，unlock_shared进行读者的锁定与解锁；通过lock，unlock进行写者的锁定与解锁。</li></ul><pre><code class="lang-cpp">shared_mutex s_m;std::string book;void read(){    s_m.lock_shared();    cout &lt;&lt; book;    s_m.unlock_shared();}void write(){    s_m.lock();    book = &quot;new context&quot;;    s_m.unlock();}</code></pre><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li>如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁；</li><li>自旋锁比较适用于锁使用者保持锁时间比较短的情况。</li></ul><h2 id="C-多线程相关函数"><a href="#C-多线程相关函数" class="headerlink" title="C++多线程相关函数"></a>C++多线程相关函数</h2><ul><li>进入代码临界区的时候需要进行加锁<h3 id="加锁-lock-与unlock"><a href="#加锁-lock-与unlock" class="headerlink" title="加锁-lock()与unlock()"></a>加锁-lock()与unlock()</h3></li><li><code>mutex m</code>表示实例化mutex变量,用于加锁.<ul><li>如果该互斥量当前未上锁，则本线程将该互斥量锁住，直到调用unlock()之前，本线程一直拥有该锁</li><li>如果该互斥量当前被其他线程锁住，则本线程被阻塞,直至该互斥量被其他线程解锁，此时本线程将该互斥量锁住，直到调用unlock()之前，本线程一直拥有该锁</li></ul></li><li>缺点<ul><li>如果忘记unlock()，将导致锁无法释放<br>```cpp<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<iostream></iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<thread></thread></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<mutex></mutex></h1>using namespace std;<br>mutex m;//实例化m对象，不要理解为定义变量<br>void proc1(int a)<br>{<br>m.lock();<br>cout &lt;&lt; “proc1函数正在改写a” &lt;&lt; endl;<br>cout &lt;&lt; “原始a为” &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; “现在a为” &lt;&lt; a + 2 &lt;&lt; endl;<br>m.unlock();<br>}</li></ul></li></ul><p>void proc2(int a)<br>{<br>    m.lock();<br>    cout &lt;&lt; “proc2函数正在改写a” &lt;&lt; endl;<br>    cout &lt;&lt; “原始a为” &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; “现在a为” &lt;&lt; a + 1 &lt;&lt; endl;<br>    m.unlock();<br>}<br>int main()<br>{<br>    int a = 0;<br>    thread t1(proc1, a);<br>    thread t2(proc2, a);<br>    t1.join();<br>    t2.join();<br>    return 0;<br>}</p><pre><code>### 加锁-lock_guard()* 声明一个局部的std::lock_guard对象，在其构造函数中进行加锁，在其析构函数中进行解锁    - 创建即加锁，作用域结束自动解锁```cpp#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;mutex&gt;using namespace std;mutex m;//实例化m对象，不要理解为定义变量void proc1(int a){    lock_guard&lt;mutex&gt; g1(m);//用此语句替换了m.lock()；lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m    cout &lt;&lt; &quot;proc1函数正在改写a&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;原始a为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;现在a为&quot; &lt;&lt; a + 2 &lt;&lt; endl;}//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁void proc2(int a){    {        lock_guard&lt;mutex&gt; g2(m);        cout &lt;&lt; &quot;proc2函数正在改写a&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;原始a为&quot; &lt;&lt; a &lt;&lt; endl;        cout &lt;&lt; &quot;现在a为&quot; &lt;&lt; a + 1 &lt;&lt; endl;    }//通过使用{}来调整作用域范围，可使得m在合适的地方被解锁    cout &lt;&lt; &quot;作用域外的内容3&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;作用域外的内容4&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;作用域外的内容5&quot; &lt;&lt; endl;}int main(){    int a = 0;    thread t1(proc1, a);    thread t2(proc2, a);    t1.join();    t2.join();    return 0;}</code></pre><ul><li>adopt_lock标识表示构造函数中不再进行互斥量锁定，因此此时需要提前手动锁定<br>```cpp<h1 id="include-3"><a href="#include-3" class="headerlink" title="include"></a>include<iostream></iostream></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include"></a>include<thread></thread></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include"></a>include<mutex></mutex></h1>using namespace std;<br>mutex m;//实例化m对象，不要理解为定义变量<br>void proc1(int a)<br>{<br>  m.lock();//手动锁定<br>  lock_guard<mutex> g1(m,adopt_lock);<br>  cout &lt;&lt; “proc1函数正在改写a” &lt;&lt; endl;<br>  cout &lt;&lt; “原始a为” &lt;&lt; a &lt;&lt; endl;<br>  cout &lt;&lt; “现在a为” &lt;&lt; a + 2 &lt;&lt; endl;<br>}//自动解锁</mutex></li></ul><p>void proc2(int a)<br>{<br>    lock_guard<mutex> g2(m);//自动锁定<br>    cout &lt;&lt; “proc2函数正在改写a” &lt;&lt; endl;<br>    cout &lt;&lt; “原始a为” &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; “现在a为” &lt;&lt; a + 1 &lt;&lt; endl;<br>}//自动解锁<br>int main()<br>{<br>    int a = 0;<br>    thread t1(proc1, a);<br>    thread t2(proc2, a);<br>    t1.join();<br>    t2.join();<br>    return 0;<br>}</mutex></p><pre><code>### 加锁-unique_lock()![](C++_MultiThreads/unique_lock.jpg)```cpp#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;mutex&gt;using namespace std;mutex m;void proc1(int a){    unique_lock&lt;mutex&gt; g1(m, defer_lock);//始化了一个没有加锁的mutex    cout &lt;&lt; &quot;xxxxxxxx&quot; &lt;&lt; endl;    g1.lock();//手动加锁，注意，不是m.lock();注意，不是m.lock(),m已经被g1接管了;    cout &lt;&lt; &quot;proc1函数正在改写a&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;原始a为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;现在a为&quot; &lt;&lt; a + 2 &lt;&lt; endl;    g1.unlock();//临时解锁    cout &lt;&lt; &quot;xxxxx&quot; &lt;&lt; endl;    g1.lock();    cout &lt;&lt; &quot;xxxxxx&quot; &lt;&lt; endl;}//自动解锁void proc2(int a){    unique_lock&lt;mutex&gt; g2(m, try_to_lock);//尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作。    if (g2.owns_lock()) {//锁成功        cout &lt;&lt; &quot;proc2函数正在改写a&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;原始a为&quot; &lt;&lt; a &lt;&lt; endl;        cout &lt;&lt; &quot;现在a为&quot; &lt;&lt; a + 1 &lt;&lt; endl;    }    else {//锁失败则执行这段语句        cout &lt;&lt; &quot;&quot; &lt;&lt; endl;    }}//自动解锁int main(){    int a = 0;    thread t1(proc1, a);    t1.join();    //thread t2(proc2, a);    //t2.join();    return 0;}</code></pre><h4 id="std-unique-lock所有权的转移"><a href="#std-unique-lock所有权的转移" class="headerlink" title="std::unique_lock所有权的转移"></a>std::unique_lock所有权的转移</h4><pre><code class="lang-cpp">mutex m;{      unique_lock&lt;mutex&gt; g2(m,defer_lock);    unique_lock&lt;mutex&gt; g3(move(g2));//所有权转移，此时由g3来管理互斥量m    g3.lock();    g3.unlock();    g3.lock();}</code></pre><h3 id="线程同步-condition-variable"><a href="#线程同步-condition-variable" class="headerlink" title="线程同步 - condition_variable"></a>线程同步 - condition_variable</h3><ul><li>std::condition_variable对象的作用不是用来管理互斥量的，它的作用是用来同步线程</li><li><p>它的用法相当于编程中常见的flag标志</p></li><li><p>wait函数需要传入一个std::mutex（一般会传入std::unique_lock对象）,即上述的locker。wait函数会自动调用 locker.unlock() 释放锁（因为需要释放锁，所以要传入mutex）并阻塞当前线程，本线程释放锁使得其他的线程得以继续竞争锁。一旦当前线程获得notify(通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数此时再自动调用 locker.lock()上锁。</p></li><li><p>cond.notify_one(): 随机唤醒一个等待的线程</p></li><li><p>cond.notify_all(): 唤醒所有等待的线程</p><pre><code class="lang-cpp">std::wait(MUTEX_NAME)</code></pre><h2 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h2><h3 id="async与future"><a href="#async与future" class="headerlink" title="async与future"></a>async与future</h3></li><li>std::async是一个函数模板，用来启动一个异步任务,它返回一个std::future类模板对象</li><li>future对象起到了占位的作用,调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future，即通过FutureObject.get()获取函数返回值<br>```cpp<h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <thread></thread></h1><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <mutex></mutex></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include"></a>include<future></future></h1><h1 id="include-10"><a href="#include-10" class="headerlink" title="include"></a>include<windows.h></windows.h></h1>using namespace std;<br>double t1(const double a, const double b)<br>{<br>double c = a + b;<br>Sleep(3000);//假设t1函数是个复杂的计算过程，需要消耗3秒<br>return c;<br>}</li></ul><p>int main()<br>{<br> double a = 2.3;<br> double b = 6.7;<br> future<double> fu = async(t1, a, b);//创建异步线程线程，并将线程的执行结果用fu占位；<br> cout &lt;&lt; “正在进行计算” &lt;&lt; endl;<br> cout &lt;&lt; “计算结果马上就准备好，请您耐心等待” &lt;&lt; endl;<br> cout &lt;&lt; “计算结果：” &lt;&lt; fu.get() &lt;&lt; endl;//阻塞主线程，直至异步线程return<br>        //cout &lt;&lt; “计算结果：” &lt;&lt; fu.get() &lt;&lt; endl;//取消该语句注释后运行会报错，因为future对象的get()方法只能调用一次。<br> return 0;<br>}</double></p><pre><code>### shared_future![](C++_MultiThreads/shared_future.jpg)## 原子类型atomic&lt;&gt;* 原子操作指“不可分割的操作”* 互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量(操作变量时加锁防止他人干扰)* std::atomic&lt;&gt;是一个模板类，使用该模板类实例化的对象，提供了一些保证原子性的成员函数来实现共享数据的常用操作&gt; std::atomic&lt;&gt;用来定义一个自动加锁解锁的共享变量，供多个线程访问而不发生冲突。&gt; std::atomic&lt;&gt;对象提供了常见的原子操作:store,load,exchange,++，–，+=，-=，&amp;=，|=，^=等# 生产者消费者问题* 生产者用于生产数据，生产一个就往共享数据区存一个，如果共享数据区已满的话，生产者就暂停生产，等待消费者的通知后再启动。* 消费者用于消费数据，一个一个的从共享数据区取，如果共享数据区为空的话，消费者就暂停取数据，等待生产者的通知后再启动。```cpp#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;queue&gt;#include&lt;condition_variable&gt;using namespace std;//缓冲区存储的数据类型 struct CacheData{    //商品id     int id;    //商品属性     string data;};queue&lt;CacheData&gt; Q;//缓冲区最大空间 const int MAX_CACHEDATA_LENGTH = 10;//互斥量，生产者之间，消费者之间，生产者和消费者之间，同时都只能一个线程访问缓冲区 mutex m;condition_variable condConsumer;condition_variable condProducer;//全局商品id int ID = 1;//消费者动作 void ConsumerActor(){    unique_lock&lt;mutex&gt; lockerConsumer(m);    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 获取了锁&quot; &lt;&lt; endl;     while (Q.empty())    {        cout &lt;&lt;  &quot;因为队列为空，所以消费者Sleep&quot; &lt;&lt; endl;         cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 不再持有锁&quot; &lt;&lt; endl;        //队列空， 消费者停止，等待生产者唤醒         condConsumer.wait(lockerConsumer);        cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] Weak, 重新获取了锁&quot; &lt;&lt; endl;     }    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] &quot;;     CacheData temp = Q.front();    cout &lt;&lt; &quot;- ID:&quot; &lt;&lt; temp.id &lt;&lt; &quot; Data:&quot; &lt;&lt; temp.data &lt;&lt; endl;    Q.pop();     condProducer.notify_one();    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 释放了锁&quot; &lt;&lt; endl; }//生产者动作 void ProducerActor(){    unique_lock&lt;mutex&gt; lockerProducer(m);    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 获取了锁&quot; &lt;&lt; endl;     while (Q.size() &gt; MAX_CACHEDATA_LENGTH)    {        cout &lt;&lt;  &quot;因为队列为满，所以生产者Sleep&quot; &lt;&lt; endl;         cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 不再持有锁&quot; &lt;&lt; endl;         //对列慢，生产者停止，等待消费者唤醒         condProducer.wait(lockerProducer);        cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] Weak, 重新获取了锁&quot; &lt;&lt; endl;     }    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] &quot;;     CacheData temp;    temp.id = ID++;    temp.data = &quot;*****&quot;;    cout &lt;&lt; &quot;+ ID:&quot; &lt;&lt; temp.id &lt;&lt; &quot; Data:&quot; &lt;&lt; temp.data &lt;&lt; endl;     Q.push(temp);    condConsumer.notify_one();    cout &lt;&lt; &quot;[&quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;] 释放了锁&quot; &lt;&lt; endl; }//消费者 void ConsumerTask(){    while(1)    {        ConsumerActor();    }    }//生产者 void ProducerTask(){    while(1)    {        ProducerActor();    }    }//管理线程的函数 void Dispatch(int ConsumerNum, int ProducerNum){    vector&lt;thread&gt; thsC;    for (int i = 0; i &lt; ConsumerNum; ++i)    {        thsC.push_back(thread(ConsumerTask));    }    vector&lt;thread&gt; thsP;    for (int j = 0; j &lt; ProducerNum; ++j)    {        thsP.push_back(thread(ProducerTask));    }    for (int i = 0; i &lt; ConsumerNum; ++i)    {        if (thsC[i].joinable())        {            thsC[i].join();        }    }    for (int j = 0; j &lt; ProducerNum; ++j)    {        if (thsP[j].joinable())        {            thsP[j].join();        }    }}int main(){    //一个消费者线程，5个生产者线程，则生产者经常要等待消费者     Dispatch(1,5);    return 0; }</code></pre><h1 id="C-多线程并发高级知识"><a href="#C-多线程并发高级知识" class="headerlink" title="C++多线程并发高级知识"></a>C++多线程并发高级知识</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>不采用线程池时<blockquote><p>创建线程 -&gt; 由该线程执行任务 -&gt; 任务执行完毕后销毁线程。即使需要使用到大量线程，每个线程都要按照这个流程来创建、执行与销毁。</p></blockquote></li></ul><blockquote><p>虽然创建与销毁线程消耗的时间 远小于 线程执行的时间，但是对于需要频繁创建大量线程的任务，创建与销毁线程 所占用的时间与CPU资源也会有很大占比。</p></blockquote><ul><li>采用线程池<blockquote><p> 减少创建与销毁线程所带来的时间消耗与资源消耗</p></blockquote></li></ul><blockquote><p> 程序启动后，预先创建一定数量的线程放入空闲队列中，这些线程都是处于阻塞状态，基本不消耗CPU，只占用较小的内存空间。<br> 接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。<br>  任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。</p></blockquote><h3 id="线程池解决的问题"><a href="#线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题</h3><ul><li>需要频繁创建与销毁大量线程的情况下，由于线程预先就创建好了，接到任务就能马上从线程池中调用线程来处理任务，减少了创建与销毁线程带来的时间开销和CPU资源占用。</li><li>) 需要并发的任务很多时候，无法为每个任务指定一个线程（线程不够分），使用线程池可以将提交的任务挂在任务队列上，等到池中有空闲线程时就可以为该任务指定线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> MultiThreads </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接概述和目标文件格式</title>
      <link href="/2021/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E9%93%BE%E6%8E%A5%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2021/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E9%93%BE%E6%8E%A5%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言的编译过程"><a href="#C语言的编译过程" class="headerlink" title="C语言的编译过程"></a>C语言的编译过程</h1>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4 Navmesh剖析</title>
      <link href="/2021/07/29/CG/UE4/Navmesh/UE4_Navmesh/"/>
      <url>/2021/07/29/CG/UE4/Navmesh/UE4_Navmesh/</url>
      
        <content type="html"><![CDATA[<h1 id="Navmesh原理"><a href="#Navmesh原理" class="headerlink" title="Navmesh原理"></a>Navmesh原理</h1><ul><li><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/359376662" target="_blank" rel="noopener">Navigation Mesh (NavMesh) 原理讲解（一） NavMesh概览 &amp; 一个最简实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/359393767" target="_blank" rel="noopener">Navigation Mesh (NavMesh) 原理讲解（二） 当地块都是三角形时的路径优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/74537236" target="_blank" rel="noopener">UE4 Navmesh寻路（一）Recast基础</a></li><li><a href="http://critterai.org/projects/nmgen_study/" target="_blank" rel="noopener">Study: Navigation Mesh Generation</a></li></ul></li><li><p>NavMesh是一个对基于导航网格寻路体系的统称(A*指代的是某一种寻路算法)</p><ul><li>基于凸多边形网格的寻路体系</li><li>分为 导航网格构建,寻路算法 两个部分</li></ul></li></ul><h2 id="导航网格构建"><a href="#导航网格构建" class="headerlink" title="导航网格构建"></a>导航网格构建</h2><ul><li><p>方式</p><ul><li>多边形裁剪<ul><li>多边形裁剪是直接对地形的多边形网格数据进行裁剪及合并，从而生成导航网格</li><li>havok引擎</li></ul></li><li>体素化<ul><li>体素化是对地形多边形网格进行栅格化，然后用这些“格子”重新生成导航网格</li><li>Recast(UE4,Unity)</li></ul></li></ul></li><li><p>UE4使用开源的recast其包括两个过程:Recast和Detour</p><ul><li>Recast:将场景网格模型生成用于寻路的导航网格</li><li>Detour：利用导航网格进行寻路</li></ul></li></ul><h3 id="Recast流程"><a href="#Recast流程" class="headerlink" title="Recast流程"></a>Recast流程</h3><ul><li>创建体素模型，把模型分割成简单的区域，把这些区域再分割成简单多边形（凸的）<ul><li>1.通过把输入的三角形mesh进行光栅化，形成一个多层的高度场，就能得到体素模型。之后可以对体素模型做一些简单的过滤，去掉玩家不可达的位置</li><li>2.体素模型描述的可行走区域被划分为重叠的2D区域，这些区域只有一个未重叠的等高线，这可以大大简化最后一步处理步骤</li><li>3.首先沿着边界划这些区域并进行化简可以剥离出导航多边形。然后把这些导航多边形处理为凸多边形，凸多边形可以更好的用于寻路和对场景进行空间推理。</li></ul></li></ul><h4 id="高度场"><a href="#高度场" class="headerlink" title="高度场"></a>高度场</h4><h5 id="实心高度场"><a href="#实心高度场" class="headerlink" title="实心高度场"></a>实心高度场</h5><h5 id="开放高度场"><a href="#开放高度场" class="headerlink" title="开放高度场"></a>开放高度场</h5><h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h4><h5 id="Voxelization-Create-a-solid-heightfield-from-the-source-geometry"><a href="#Voxelization-Create-a-solid-heightfield-from-the-source-geometry" class="headerlink" title="Voxelization( Create a solid heightfield from the source geometry)"></a>Voxelization( Create a solid heightfield from the source geometry)</h5><h5 id="Generate-Regions（Detect-the-top-surface-area-of-the-solid-heightfield-and-divide-it-up-into-regions-of-contiguous-spans-）"><a href="#Generate-Regions（Detect-the-top-surface-area-of-the-solid-heightfield-and-divide-it-up-into-regions-of-contiguous-spans-）" class="headerlink" title="Generate Regions（Detect the top surface area of the solid heightfield and divide it up into regions of contiguous spans.）"></a>Generate Regions（Detect the top surface area of the solid heightfield and divide it up into regions of contiguous spans.）</h5><h5 id="Generate-Contours-（-Detect-the-contours-of-the-regions-and-form-them-into-simple-polygons-）"><a href="#Generate-Contours-（-Detect-the-contours-of-the-regions-and-form-them-into-simple-polygons-）" class="headerlink" title="Generate Contours （ Detect the contours of the regions and form them into simple polygons.）"></a>Generate Contours （ Detect the contours of the regions and form them into simple polygons.）</h5><h5 id="Generate-Polygon-Mesh（-Sub-divide-the-contours-into-convex-polygons-）"><a href="#Generate-Polygon-Mesh（-Sub-divide-the-contours-into-convex-polygons-）" class="headerlink" title="Generate Polygon Mesh（ Sub-divide the contours into convex polygons.）"></a>Generate Polygon Mesh（ Sub-divide the contours into convex polygons.）</h5><h5 id="Generate-Detailed-Mesh（Triangulate-the-polygon-mesh-and-add-height-detail-）"><a href="#Generate-Detailed-Mesh（Triangulate-the-polygon-mesh-and-add-height-detail-）" class="headerlink" title="Generate Detailed Mesh（Triangulate the polygon mesh and add height detail.）"></a>Generate Detailed Mesh（Triangulate the polygon mesh and add height detail.）</h5><h2 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h2><ul><li>经过导航网格构建后的游戏场景,大致可以抽象成下面这样<blockquote><p>黑色是不可通过的地块，黄点是每个地块的中心点，黄线是将每个可通过地块的中心点进行了连接</p></blockquote></li></ul><blockquote><p>连接条件是：如果两个可通过地块有邻边，则连接</p></blockquote><p><img src="UE4_Navmesh/Transform%20polygons%20to%20node.jpg" alt></p><h3 id="寻路情况"><a href="#寻路情况" class="headerlink" title="寻路情况"></a>寻路情况</h3><ul><li>1.两个点在同一个地块内，走直线；</li><li>2.其中一个点不在合法地块内，此路不通；</li><li>3.两个点在不同地块，需要寻路。</li></ul><h4 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h4><ul><li>A<em>算法详见:[A</em>](<a href="https://sanctorum003.github.io/2021/06/03/Algorithm/A_Star/" target="_blank" rel="noopener">https://sanctorum003.github.io/2021/06/03/Algorithm/A_Star/</a>)</li><li><p>对于情况3,一个简单的寻路算法就是A*算法</p><script type="math/tex; mode=display">f(n) = g(n) + h(n)</script><ul><li>其中,<code>f(n)</code>是节点<code>n</code>的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li><li>其中,<code>g(n)</code>就是在Djikstra算法中计算的离起始点的距离,我们在Djikstra中取<code>g(n)</code>值最小的作为最高优先级</li><li>其中,<code>h(n)</code>为A*算法的启发函数,计算节点n距离终点的预计代价(距离).取<code>h(n)</code>值最小的作为最高优先级</li></ul><ul><li>对于在navmesh中,g(n)的计算可以通过每两个可通行块之间的连线(即图中黄线)来作为边</li><li>h(n)可以简单的用当前黄点与目标点直接连线</li></ul></li></ul><h4 id="行走优化（多边形网格）"><a href="#行走优化（多边形网格）" class="headerlink" title="行走优化（多边形网格）"></a>行走优化（多边形网格）</h4><ul><li>左一连接每个块的中心点</li><li>中间连接每个块最近边的中心点</li><li>右边沿着边走<br><img src="UE4_Navmesh/Three%20different%20ways%20to%20find%20a%20pathin%20C.jpg" alt></li></ul><h4 id="行走优化-三角网格-拉绳算法（漏斗算法）"><a href="#行走优化-三角网格-拉绳算法（漏斗算法）" class="headerlink" title="行走优化(三角网格) -  拉绳算法（漏斗算法）"></a>行走优化(三角网格) -  拉绳算法（漏斗算法）</h4><ul><li>规则:<ul><li>尝试挪动其中一条线，当本次挪动使夹角变小，则合法</li><li>两条线交替尝试挪动</li><li>若挪动将使夹角变大，则回退到挪动前的状态，并交换挪动权</li><li>若挪动使夹角变负，则合并路线，并从结果处重新开始</li></ul></li><li>具体看<a href="https://zhuanlan.zhihu.com/p/359393767" target="_blank" rel="noopener">Navigation Mesh (NavMesh) 原理讲解（二） 当地块都是三角形时的路径优化</a></li></ul><p><img src="UE4_Navmesh/funnel_explanation.png" alt></p><hr><ul><li>参考:<ul><li><a href="https://zhuanlan.zhihu.com/p/74537236" target="_blank" rel="noopener">UE4 Navmesh寻路（二）Detour寻路</a></li><li><a href="https://blog.csdn.net/needmorecode/category_9277680.html" target="_blank" rel="noopener">recast源码解析</a></li><li><a href="http://critterai.org/" target="_blank" rel="noopener">Practical Real-Time AI. For Critters.</a></li></ul></li></ul><hr><ul><li>行为树<ul><li><a href="https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php" target="_blank" rel="noopener">Behavior trees for AI: How they work</a></li><li><a href="https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/" target="_blank" rel="noopener">Behavior Trees</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> Navmesh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树算法</title>
      <link href="/2021/07/27/Algorithm/Tree/"/>
      <url>/2021/07/27/Algorithm/Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code class="lang-cpp">class Solution {public:    void preorder(TreeNode* root,vector&lt;int&gt;&amp; v)    {        if(root)        {            v.push_back(root-&gt;val);            preorder(root-&gt;left,v);            preorder(root-&gt;right,v);        }    }    vector&lt;int&gt; preorderTraversal(TreeNode* root) {        vector&lt;int&gt; v;        preorder(root,v);        return v;    }};</code></pre><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><pre><code class="lang-cpp">class Solution {public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) {        if(!root) return {};        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; v;        st.push(root);        while(!st.empty())        {            root = st.top();            st.pop();            v.push_back(root-&gt;val);            // 注意入栈的时候先右后左            if(t-&gt;right)                st.push(root-&gt;right);            if(t-&gt;left)                st.push(root-&gt;left);        }        return v;    }};</code></pre><h3 id="Mirros"><a href="#Mirros" class="headerlink" title="Mirros"></a>Mirros</h3><ul><li><p>有时间再学</p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><pre><code class="lang-cpp">class Solution {public:  void inorder(TreeNode* root,vector&lt;int&gt;&amp; v)  {      if(root)      {          inorder(root-&gt;left,v);          v.push_back(root-&gt;val);          inorder(root-&gt;right,v);      }  }  vector&lt;int&gt; inorderTraversal(TreeNode* root) {      vector&lt;int&gt; v;      inorder(root,v);      return v;  }};</code></pre><h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; inorderTraversal(TreeNode* root) {      if(!root) return {};      stack&lt;TreeNode*&gt; st;      vector&lt;int&gt; v;      while(!st.empty() || root != nullptr)      {          while(root != nullptr)          {              st.push(root);              root = root-&gt;left;          }          root  = st.top();          st.pop();          v.push_back(root-&gt;val);          root = root-&gt;right;      }      return v;  }};</code></pre><h3 id="Mirros-1"><a href="#Mirros-1" class="headerlink" title="Mirros"></a>Mirros</h3></li><li>有时间再学</li></ul><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><pre><code class="lang-cpp">class Solution {public:    void postOrder(TreeNode* root,vector&lt;int&gt;&amp; v)    {        if(root)        {            postOrder(root-&gt;left,v);            postOrder(root-&gt;right,v);            v.push_back(root-&gt;val);        }    }    vector&lt;int&gt; postorderTraversal(TreeNode* root) {        vector&lt;int&gt; v;        postOrder(root,v);        return v;    }};</code></pre><h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><pre><code class="lang-cpp">class Solution {public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) {        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; v;        TreeNode* prev = nullptr;        while(root != nullptr || !st.empty())        {            while(root != nullptr)            {                st.push(root);                root = root-&gt;left;            }            root = st.top();            st.pop();            if(root-&gt;right == nullptr || root-&gt;right == prev)            {                v.push_back(root-&gt;val);                prev = root;                root = nullptr;            }            else            {                st.push(root);                root = root-&gt;right;            }        }        return v;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lesson 3 Hidden_faces_removal_z_buffer</title>
      <link href="/2021/07/19/Project/TinyRenderer/Hidden_faces_removal_z_buffer/"/>
      <url>/2021/07/19/Project/TinyRenderer/Hidden_faces_removal_z_buffer/</url>
      
        <content type="html"><![CDATA[<ul><li>Lesson2中的渲染结果在嘴巴处出现层叠问题,在这讲中通过z-buffer来进行解决</li></ul><h1 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法:"></a>画家算法:</h1><ul><li><a href="https://www.wikiwand.com/en/Painter%27s_algorithm" target="_blank" rel="noopener">Painter’s algorithm</a></li></ul><h2 id="画家算法问题"><a href="#画家算法问题" class="headerlink" title="画家算法问题:"></a>画家算法问题:</h2><ul><li>在渲染三维物体时，三维模型在 z 轴上是连续的，三维模型间会互相组合交错，这种通过画家算法控制层级的方案很难奏效。</li><li>下图中三个互相交错的三角形，无法区分层级<br><img src="Hidden_faces_removal_z_buffer/day04_three_triangles.png" alt></li></ul><hr><ul><li>解决方法:<ul><li><a href="https://www.wikiwand.com/en/Newell%27s_algorithm" target="_blank" rel="noopener">Newell 算法</a></li><li>Z-buffer</li></ul></li></ul><h1 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h1><ul><li>z-buffer通过比较每个像素的深度信息来解决层级问题.</li></ul><p><img src="Hidden_faces_removal_z_buffer/day04_z-buffer.jpg" alt></p><ul><li>对于每个三角形，遍历每一个像素,像素取最靠近相机的那个三角形像素的深度信息,最终渲染时我们按这个深度缓冲逐像素渲染三角形即可</li></ul><pre><code class="lang-cpp">// 首先假设深度默认值都是负无穷 -∞(这里可以是无穷大，也可以是无穷小，依坐标系而定)for (each triangle T)              // 遍历每个三角形   for (each sample (x,y,z) in T)  // 遍历三角形里的每个像素        if (z &gt; zbuffer[x,y])        // 如果深度大于已有的值，            framebuffer[x,y] = rgb;  // 则更新颜色，            zbuffer[x,y] = z;        // 并更新 zbuffer        else            // do nothing            // 小于已有的值，就说明这个像素点被遮挡不需要绘制了</code></pre><ul><li>值得注意的一点是这里使用重心坐标跟上一节一样，对(x,y)进行插值.然后根据得到的(1-u-v,u,v)来计算深度值.</li><li>相关代码</li></ul><pre><code class="lang-cpp">void triangle(Vec3f t0, Vec3f t1, Vec3f t2, TGAImage &amp;image, TGAColor color,float* zbuffer) {     int minXVal = min(t0.x,min(t1.x,t2.x));    int maxXVal = max(t0.x,max(t1.x,t2.x));    int minYVal = min(t0.y,min(t1.y,t2.y));    int maxYVal = max(t0.y,max(t1.y,t2.y));    Vec3f pts[] = {t0,t1,t2};    for(int i = minXVal; i &lt;= maxXVal; ++i)    {        for(int j = minYVal; j &lt;= maxYVal; ++j)        {            Vec3f u = barycentric(pts,Vec2i(i,j));            if(u.x &lt; 0.0 || u.y &lt; 0.0 || u.z &lt; 0.0)     continue;            //根据重心坐标参数,计算当前三角形像素的深度.            float depthZ = 0.0;            depthZ += u.x*t0.z + u.y*t1.z + u.z*t2.z;            if(depthZ &gt; zbuffer[i*width+j])            {                zbuffer[i*width+j] = depthZ;                image.set(i,j,color);            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tinyrenderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背面剔除</title>
      <link href="/2021/07/19/CG/CG/%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/"/>
      <url>/2021/07/19/CG/CG/%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<ul><li>参考:<a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/04%20Face%20culling/" target="_blank" rel="noopener">面剔除</a></li><li>参考:<a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling" target="_blank" rel="noopener">lesson 2: Triangle rasterization and back face culling</a></li></ul><h1 id="方法一-环绕顺序"><a href="#方法一-环绕顺序" class="headerlink" title="方法一:环绕顺序:"></a>方法一:环绕顺序:</h1><ul><li>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的.</li></ul><p><img src="背面剔除/faceculling_windingorder.png" alt title="引用自learnopengl"></p><ul><li>每组组成三角形图元的三个顶点就包含了一个环绕顺序。opengl中逆时针顶点所定义的三角形将会被处理为正向三角形。</li><li>观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果：</li></ul><p><img src="背面剔除/faceculling_frontback.png" alt title="引用自learnopengl"></p><ul><li>在顶点数据中，我们定义的是两个逆时针顺序的三角形。然而，从观察者的方面看，后面的三角形是顺时针的，如果我们仍以1、2、3的顺序以观察者当面的视野看的话。即使我们以逆时针顺序定义后面的三角形，它现在还是变为顺时针。它正是我们打算剔除（丢弃）的不可见的面！</li></ul><h1 id="方法二-法线"><a href="#方法二-法线" class="headerlink" title="方法二: 法线"></a>方法二: 法线</h1><ul><li>通过光线与三角面的正法向量求点积,如果值大于0,为正面;小于0,为反面</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 Animation_Simulation</title>
      <link href="/2021/07/18/CG/Games/Animation_Simulation/"/>
      <url>/2021/07/18/CG/Games/Animation_Simulation/</url>
      
        <content type="html"><![CDATA[<h1 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h1><ul><li>动画是一种信息传递的工具<ul><li>美学经常比技术重要</li></ul></li><li>是模型的延伸→连续性<ul><li>Represent scene models as a function of time</li></ul></li><li>输出：sequence of images that when viewed sequentially provide a sense of motion<ul><li>电影：24FPS</li><li>视频：30FPS、29.994FPS</li><li>VR：90FPS （不晕的基础要求）</li></ul></li></ul><h2 id="Keyframe-animation关键帧动画"><a href="#Keyframe-animation关键帧动画" class="headerlink" title="Keyframe animation关键帧动画"></a>Keyframe animation关键帧动画</h2><ul><li>Animator (e.g. lead animator) creates keyframes 关键帧</li><li>Assistant (person or computer) creates in-between frames (“tweening”) 渐变帧</li></ul><h3 id="关键的技术难点-Interpolation-插值"><a href="#关键的技术难点-Interpolation-插值" class="headerlink" title="关键的技术难点 - Interpolation 插值"></a>关键的技术难点 - Interpolation 插值</h3><ul><li>Linear interpolation usually not good enough</li><li>Recall splines for smooth / controllable interpolation</li></ul><p>B样条……</p><h2 id="Physical-Simulation物理模拟"><a href="#Physical-Simulation物理模拟" class="headerlink" title="Physical Simulation物理模拟"></a>Physical Simulation物理模拟</h2><ul><li>模拟、仿真：推导、实现公式，模拟出物体应该怎么变化</li><li>例子：布料模拟、流体模拟</li></ul><h2 id="质点弹簧系统-Mass-Spring-System-Example-of-Modeling-a-Dynamic-System"><a href="#质点弹簧系统-Mass-Spring-System-Example-of-Modeling-a-Dynamic-System" class="headerlink" title="质点弹簧系统 Mass Spring System: Example of Modeling a Dynamic System"></a>质点弹簧系统 Mass Spring System: Example of Modeling a Dynamic System</h2><ul><li>A Simple Idealized Spring<ul><li>没有初始长度</li><li>随着拉力线性增长/缩短，线性系数是spring coefficient: stiffness</li><li>Force pulls points together</li><li>Strength proportional to displacement (Hooke’s Law)</li><li>问题：长度会倾向于0</li></ul></li><li><p>Non-Zero Length Spring</p><ul><li>初始长度Rest length不为零</li><li><p>Problem: oscillates forever 永远震荡</p><script type="math/tex; mode=display">\boldsymbol{f}_{a \rightarrow b}=k_{s} \frac{\boldsymbol{b}-\boldsymbol{a}}{\|\boldsymbol{b}-\boldsymbol{a}\|}(\|\boldsymbol{b}-\boldsymbol{a}\|-l)</script><ul><li>$\frac{\boldsymbol{b}-\boldsymbol{a}}{|\boldsymbol{b}-\boldsymbol{a}|}$表示受力方向</li><li>$|\boldsymbol{b}-\boldsymbol{a}|-l$表示弹簧拉伸长度</li></ul></li></ul></li><li>Dot Notation for Derivatives：(用点表示导数)</li></ul><script type="math/tex; mode=display">\begin{aligned} &\boldsymbol{x}\\ &\dot{\boldsymbol{x}}=\boldsymbol{v}\\ &\ddot{\boldsymbol{x}}=\boldsymbol{a} \end{aligned}</script><ul><li><p>Introducing Energy Loss</p><ul><li><p>Simple motion damping 阻尼(对弹簧全局作用)</p><script type="math/tex; mode=display">\boldsymbol{f}=-k_{d} \dot{\boldsymbol{b}}</script></li><li><p>Behaves like viscous drag on</p></li><li>Slows down motion in the direction of velocity</li><li>$k_d$ is a damping coefficient</li><li>问题：Slows down all motion<ul><li>Want a rusty spring’s oscillations to slow down, but should it also fall to the ground more slowly? 跟全局速度挂钩</li><li>无法表示弹簧内部的损耗</li></ul></li></ul></li><li><p>Internal Damping for Spring</p><p>  <img src="Games101/Internal_Damping_for_Spring.png" alt></p><ul><li>相对运动越快,f就越大,所以跟局部加速度有关</li><li><p>注意这里一定要将质量在相对加速度投影到弹簧ab方向,才是影响弹簧的力,比如旋转的时候加速度方向和弹簧方向垂直,不影响.</p></li><li><p>Viscous drag only on change in spring length</p><ul><li>粘性阻力仅在弹簧长度变化时</li><li>Won’t slow group motion for the spring system (e.g. global translation or rotation of the group)<ul><li>弹簧系统不会减慢群组运动（例如，群组的整体平移或旋转）</li></ul></li></ul></li><li>Note: This is only one specific type of damping 只是一种阻尼的近似</li></ul></li></ul><h3 id="Structures-from-Springs"><a href="#Structures-from-Springs" class="headerlink" title="Structures from Springs"></a>Structures from Springs</h3><ul><li>通过质点弹簧系统来进行布料模拟<br>Step 1: Sheets</li></ul><ul><li>This structure will not resist shearing切变会露馅</li><li>This structure will not resist out-of-plane bending…</li></ul><p>Step 2: 增加斜向方向弹簧</p><ul><li>This structure will resist shearing but has anisotropic bias 各向异性</li><li>This structure will not resist out-of-plane bending either…</li></ul><p>Step 3: 增加双斜向方向弹簧</p><ul><li>This structure will resist shearing. Less directional bias.</li><li>This structure will not resist out-of-plane bending either… 弯折</li></ul><p>Step 4: 增加横向和纵向 （skip connection）</p><ul><li>This structure will resist shearing. Less directional bias.</li><li>This structure will resist out-of-plane bending （横向和纵向的弹簧力比斜向的弱很多）(对折)</li></ul><hr><p>有限元方法(FEM (Finite Element Method) Instead of Springs)</p><ul><li>车辆碰撞</li></ul><p>力传导扩散适合用有限元方法建模做</p><h2 id="Particle-Systems"><a href="#Particle-Systems" class="headerlink" title="Particle Systems"></a>Particle Systems</h2><ul><li>建模定义很多粒子</li><li>每个粒子有自己的属性</li></ul><hr><ul><li>Model dynamical systems as collections of large numbers of particles </li><li>Each particle’s motion is defined by a set of physical (or non-physical) forces</li><li>Popular technique in graphics and games<ul><li>Easy to understand, implement</li><li>Scalable: fewer particles for speed, more for higher complexity</li></ul></li></ul><hr><ul><li>Challenges<ul><li>May need many particles (e.g. fluids)</li><li>May need acceleration structures (e.g. to find nearest particles for interactions)</li></ul></li></ul><hr><ul><li>简易算法</li></ul><pre><code class="lang-cpp">For each frame in animation  [If needed] Remove dead particles  Calculate forces on each particle  Update each particle’s position and velocity  [If needed] Create new particles  Render particles</code></pre><ul><li>定义个体和群体之间的关系</li></ul><h3 id="Particle-System-Forces"><a href="#Particle-System-Forces" class="headerlink" title="Particle System Forces"></a>Particle System Forces</h3><p>Attraction and repulsion forces</p><p>• Gravity, electromagnetism, …</p><p>• Springs, propulsion, … </p><p>Damping forces</p><p>• Friction, air drag, viscosity, … </p><p>Collisions</p><p>• Walls, containers, fixed objects, …</p><p>• Dynamic objects, character body parts, …</p><hr><p>Example: Simulated Flocking as an ODE(常微分方程)</p><ul><li>定义鸟儿之间交互的规则：个体对群体的观察</li><li>Model each bird as a particle Subject to very simple forces:</li><li>attraction to center of neighbors</li><li>repulsion from individual neighbors</li><li>alignment toward average trajectory of neighbors Simulate evolution of large particle system numerically Emergent complex behavior (also seen in fish, bees, …)</li></ul><p>Example: Molecular Dynamics</p><p>Example: Crowds + “Rock” Dynamics</p><h2 id="Kinematics"><a href="#Kinematics" class="headerlink" title="Kinematics"></a>Kinematics</h2><ul><li>运动学：正向和反向</li></ul><h3 id="Forward-Kinematics-正向运动学"><a href="#Forward-Kinematics-正向运动学" class="headerlink" title="Forward Kinematics 正向运动学"></a>Forward Kinematics 正向运动学</h3><p>明确骨骼之间的运动关系→计算出各个部位的位置</p><p>Articulated skeleton</p><ul><li>Topology (what’s connected to what)</li><li>Geometric relations from joints</li><li>Tree structure (in absence of loops)</li></ul><p>Joint types</p><ul><li>Pin (1D rotation)</li><li>Ball (2D rotation)</li><li>Prismatic joint (translation)</li></ul><p>Strengths</p><ul><li>Direct control is convenient </li><li>Implementation is straightforward</li></ul><p>Weaknesses</p><ul><li>Animation may be inconsistent with physics</li><li>Time consuming for artists</li></ul><h3 id="Inverse-Kinematics-逆运动学"><a href="#Inverse-Kinematics-逆运动学" class="headerlink" title="Inverse Kinematics 逆运动学"></a>Inverse Kinematics 逆运动学</h3><ul><li>限制各个部位（通常只有终端）的位置、限制骨骼的运动方式→计算骨骼的运动</li><li>方便控制形体整体形状</li><li>解特别复杂，可能并不唯一,也可能无解</li></ul><hr><p>解法：随机化算法（优化方法，梯度下降）</p><p>Numerical solution to general N-link IK problem</p><p>• Choose an initial configuration</p><p>• Define an error metric (e.g. square of distance between goal and current position)</p><p>• Compute gradient of error as function of configuration</p><p>• Apply gradient descent (or Newton’s method, or other optimization procedure)</p><p>例子：Style-Based IK</p><h3 id="Rigging"><a href="#Rigging" class="headerlink" title="Rigging"></a>Rigging</h3><p>通过控制点对三维物体进行控制(比如改变脸部表情,手势等)</p><ul><li><p>Rigging is a set of higher level controls on a character that allow more rapid &amp; intuitive modification of pose, deformations, expression, etc.</p></li><li><p>Important</p><ul><li>Like strings on a puppet</li><li>Captures all meaningful character changes</li><li>Varies from character to character </li></ul></li><li>Expensive to create<ul><li>Manual effort 定控制点，拉控制点（应该怎么定、应该怎么拉 → 动画师）</li><li>Requires both artistic and technical training</li></ul></li></ul><h3 id="Blend-Shapes-控制点间的位置插值计算"><a href="#Blend-Shapes-控制点间的位置插值计算" class="headerlink" title="Blend Shapes 控制点间的位置插值计算"></a>Blend Shapes 控制点间的位置插值计算</h3><ul><li>Instead of skeleton, interpolate directly between surfaces<ul><li>E.g., model a collection of facial expressions:</li></ul></li><li>Simplest scheme: take linear combination of vertex positions</li><li>Spline used to control choice of weights over time</li></ul><h2 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h2><ul><li>真人控制点反映到虚拟角色中去，需要建立真实和虚拟的联系</li></ul><p>Data-driven approach to creating animation sequences</p><ul><li>Record real-world performances (e.g. person executing an activity)</li><li>Extract pose as a function of time from the data collected</li></ul><p>Strengths</p><ul><li><p>Can capture large amounts of real data quickly</p></li><li><p>Realism can be high </p></li></ul><p>Weaknesses</p><ul><li><p>Complex and costly set-ups 复杂、花钱</p></li><li><p>Captured animation may not meet artistic needs, requiring alterations 不符合艺术家要求，不可能实现的动作</p></li><li><p>捕捉条件限制</p></li></ul><hr><p>不同的捕捉方法：</p><ul><li>Optical (More on following slides)<ul><li>Markers on subject</li><li>Positions by triangulation from multiple cameras</li><li>8+ cameras, 240 Hz, occlusions are difficult</li></ul></li><li>Magnetic Sense magnetic fields to infer position / orientation. Tethered.</li><li>Mechanical Measure joint angles directly. Restricts motion.</li></ul><hr><p>Challenges of Facial Animation</p><ul><li>Uncanny valley<ul><li>In robotics and graphics</li><li>As artificial character appearance approaches human realism, our emotional response goes negative, until it achieves a sufficiently convincing level of realism in expression</li></ul></li></ul><h2 id="动画的制作流程-The-Production-Pipeline"><a href="#动画的制作流程-The-Production-Pipeline" class="headerlink" title="动画的制作流程 The Production Pipeline"></a>动画的制作流程 The Production Pipeline</h2><p><img src="Games101/Animation_Pipeline.png" alt></p><h2 id="Single-Particle-Simulation"><a href="#Single-Particle-Simulation" class="headerlink" title="Single Particle Simulation"></a>Single Particle Simulation</h2><ul><li>假设粒子在的运动由速度场决定<ul><li>速度场是一个关于位置和时间的函数 $v(x,t)$</li></ul></li><li>对于粒子我们知道在时间$t_{0}$的速度$v_{t0}$和位置$x_{t0}$<ul><li>我们要求的是任意时间$t_{1}$的位置$x_{t1}$</li></ul></li></ul><h3 id="Ordinary-Differential-Equation-ODE-常微分方程"><a href="#Ordinary-Differential-Equation-ODE-常微分方程" class="headerlink" title="Ordinary Differential Equation (ODE) 常微分方程"></a>Ordinary Differential Equation (ODE) 常微分方程</h3><p>计算速度场内粒子的位置需要计算一阶常微分方程：</p><script type="math/tex; mode=display">\frac{d x}{d t}=\dot{x}=v(x, t)</script><p>解一阶常微分方程：</p><ul><li>连续：积分</li><li><p>离散：Euler’s Method欧拉方法</p><ul><li><p>Explicit Euler method （forward 前向、显式）</p><ul><li><p>始终用前一帧的状态来更新后一帧</p><script type="math/tex; mode=display">\begin{array}{l} \boldsymbol{x}^{t+\Delta t}=\boldsymbol{x}^{t}+\Delta t \dot{\boldsymbol{x}}^{t} \\ \dot{\boldsymbol{x}}^{t+\Delta t}=\dot{\boldsymbol{x}}^{t}+\Delta t \ddot{\boldsymbol{x}}^{t} \end{array}</script></li><li><p>Simple iterative method</p></li><li>Commonly used</li></ul></li><li>问题:<ul><li>Very inaccurate 很不准确:步长越大越不准确<ul><li>With numerical integration, errors accumulate</li><li>Euler integration is particularly bad</li></ul></li><li>Most often goes unstable 不稳定<ul><li>容易出现正反馈，离正确结果越来越远<br><img src="Games101/Euler_Method_Instability.png" alt></li></ul></li></ul></li></ul></li></ul><h2 id="Instability-and-improvements"><a href="#Instability-and-improvements" class="headerlink" title="Instability and improvements"></a>Instability and improvements</h2><p>Solving by numerical integration with finite differences leads to two problems:</p><p>Errors 误差 不是特别大的问题</p><ul><li>Errors at each time step accumulate. Accuracy decreases as simulation proceeds</li><li>Accuracy may not be critical in graphics applications</li></ul><p>Instability <strong>不稳定性 很要命！</strong></p><ul><li>Errors can compound, causing the simulation to <strong>diverge</strong> even when the underlying system does not 收敛很重要！</li><li>Lack of stability is a fundamental problem in simulation, and cannot be ignored</li></ul><h2 id="Combating-Instability"><a href="#Combating-Instability" class="headerlink" title="Combating Instability"></a>Combating Instability</h2><h3 id="Midpoint-method"><a href="#Midpoint-method" class="headerlink" title="Midpoint method"></a>Midpoint method</h3><ul><li>用一次欧拉方法得到a点</li><li>取起点到a点的终点b,得到对应的速度</li><li>在起始点应用b点的速度进行欧拉方法,得到c点</li></ul><p><img src="Games101/Euler_Midpoint_Method.png" alt></p><h3 id="Adaptive-Step-Size"><a href="#Adaptive-Step-Size" class="headerlink" title="Adaptive Step Size"></a>Adaptive Step Size</h3><ul><li>用一次欧拉方法得到$X_{T}$点</li><li>在中点处再用欧拉方法得到$X_{T/2}$点</li><li>判断两个点之间的距离,超过一定距离递归的缩小步长</li></ul><p><img src="Games101/Euler_Adaptive_Step_Size.png" alt></p><h3 id="Implicit-Eulr-Method"><a href="#Implicit-Eulr-Method" class="headerlink" title="Implicit Eulr Method"></a>Implicit Eulr Method</h3><ul><li>Use the velocity at the next time step (hard)</li></ul><script type="math/tex; mode=display">\begin{array}{l} \boldsymbol{x}^{t+\Delta t}=\boldsymbol{x}^{t}+\Delta t \dot{\boldsymbol{x}}^{t+\Delta t} \\ \dot{\boldsymbol{x}}^{t+\Delta t}=\dot{\boldsymbol{x}}^{t}+\Delta t \ddot{\boldsymbol{x}}^{t+\Delta t} \end{array}</script><ul><li>是一个方程组，有三个未知数，只能假设一个已知（猜）</li><li>Use root-finding algorithm, e.g. Newton’s method</li><li>Offers much better stability</li><li><p>Implicit Euler has order 1, which means that</p><ul><li>Local truncation error: O(h^2) and</li><li><p>Global truncation error: O(h) (h is the step, i.e. ∆t)</p><p>O(h)的理解</p></li><li><p>If we halve h, we can expect the error to halve as well</p></li><li>阶数越高越好，减小步长的情况下降低更快</li></ul></li></ul><h3 id="Runge-Kutta-Families"><a href="#Runge-Kutta-Families" class="headerlink" title="Runge-Kutta Families"></a>Runge-Kutta Families</h3><ul><li>A family of advanced methods for solving ODEs</li><li>Especially good at dealing with non-linearity</li><li>It’s order-four version is the most widely used, a.k.a. <strong>RK4</strong></li></ul><p><img src="Games101/Runge_kutta_Families.png" alt></p><p>更多：Numerical Analysis 对图形学有用 （其他的：信号处理）</p><h3 id="Position-Based-Verlet-Intergation"><a href="#Position-Based-Verlet-Intergation" class="headerlink" title="Position-Based / Verlet Intergation"></a>Position-Based / Verlet Intergation</h3><ul><li>Constrain positions and velocities of particles after time step</li></ul><p>假设弹簧无限大</p><p>Idea:</p><ul><li>After modified Euler forward-step, constrain positions of particles to prevent divergent, unstable behavior</li><li>Use constrained positions to calculate velocity</li><li>Both of these ideas will dissipate energy, stabilize</li></ul><p>Pros / cons</p><ul><li>Fast and simple</li><li>Not physically based, dissipates energy (error)</li></ul><h2 id="Rigid-body-simulation"><a href="#Rigid-body-simulation" class="headerlink" title="Rigid body simulation"></a>Rigid body simulation</h2><p>不会形变</p><p>Simple case</p><ul><li>Similar to simulating a particle</li><li>Just consider a bit more properties 拓展</li></ul><h2 id="Fluid-Simulation"><a href="#Fluid-Simulation" class="headerlink" title="Fluid Simulation"></a>Fluid Simulation</h2><h3 id="A-Simple-Position-Based-Method"><a href="#A-Simple-Position-Based-Method" class="headerlink" title="A Simple Position-Based Method"></a>A Simple Position-Based Method</h3><p>模拟只需要输出物体的位置，其他的就是渲染的问题了</p><p>Key idea</p><ul><li>Assuming water is composed of small rigid-body spheres 水是由小球组成的</li><li>Assuming the water cannot be compressed (i.e. const. density) 不可压缩</li><li>So, as long as the density changes somewhere, it should be “corrected” via changing the positions of particles 密度有变化，就要想着改回去，移动小球位置</li><li><p>You need to know the gradient of the density anywhere w.r.t. each particle’s position</p><p>  一个小球位置的变化对其周围密度的影响</p></li><li><p>Update? Just gradient descent! 梯度下降</p></li></ul><p>非物理</p><h2 id="流体模拟中两种不同的思路：Eulerian-vs-Lagrangian"><a href="#流体模拟中两种不同的思路：Eulerian-vs-Lagrangian" class="headerlink" title="流体模拟中两种不同的思路：Eulerian vs. Lagrangian"></a>流体模拟中两种不同的思路：Eulerian vs. Lagrangian</h2><p>Lagrangian：质点法，以每个元素为单位模拟</p><p>Eulerian：网格法，以空间为单位分割模拟</p><h3 id="Material-Point-Method-MPM"><a href="#Material-Point-Method-MPM" class="headerlink" title="Material Point Method (MPM)"></a>Material Point Method (MPM)</h3><p>Hybrid, combining Eulerian and Lagrangian views</p><ul><li>Lagrangian: consider particles carrying material properties 物质由粒子组成，粒子有属性</li><li>Eulerian: use a grid to do numerical integration 网格上计算如何运动</li><li>Interaction: particles transfer properties to the grid, grid performs update, then interpolate back to particles 网格属性写回网格内粒子上</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 Light Transport</title>
      <link href="/2021/07/18/CG/Games/Light_Transport/"/>
      <url>/2021/07/18/CG/Games/Light_Transport/</url>
      
        <content type="html"><![CDATA[<h1 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h1><p>使用光线追踪的原因:</p><ul><li>光栅化不能很好的处理全局效果.<ul><li>soft shadows</li><li>Glossy reflection</li><li>indriect Illumination</li></ul></li></ul><ul><li>光栅化：快速近似、质量低</li><li>光线追踪：准确、非常慢<ul><li>实时,offline渲染</li><li>实际生产中，渲染电影的一帧=～10000CPU小时</li></ul></li></ul><h2 id="Basic-Ray-Tracing-Algorithmn"><a href="#Basic-Ray-Tracing-Algorithmn" class="headerlink" title="Basic Ray-Tracing Algorithmn"></a>Basic Ray-Tracing Algorithmn</h2><ul><li>关于光线的定义:<ul><li>假设近似直线传播（实际物理中光线有波粒二象性）</li><li>光线交叉互不影响（实际物理存在交叉）</li><li>从光源到人眼～从人眼到光源（光路可逆性）</li></ul></li></ul><p>Tracing：从相机出发，向场景投射光线</p><h3 id="Ray-casting-appel-1968"><a href="#Ray-casting-appel-1968" class="headerlink" title="Ray casting(appel 1968)"></a>Ray casting(appel 1968)</h3><ol><li><p>Generate an image by casting one ray per pixel</p><p> 从眼睛出发，经过像素点，射向场景</p><p> 判断最近碰撞物体，Shading计算颜色</p></li><li><p>Check for shadows by sending a ray to the light</p></li></ol><p><img src="Games101/Ray%20casting.png" alt></p><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3><p>光线弹射多次：Recursive (Whitted-Style) Ray Tracing</p><ul><li>Shading：每次折射点都计算一次颜色值，最后累加</li></ul><p><img src="Games101/Recursive%20Ray%20Tracing.png" alt></p><h3 id="Ray-Surface-Intersection"><a href="#Ray-Surface-Intersection" class="headerlink" title="Ray-Surface Intersection"></a>Ray-Surface Intersection</h3><ul><li>Ray qeuation:</li></ul><p><img src="Games101/ray_equation.png" alt></p><h4 id="ray-Intersection-With-Sphere"><a href="#ray-Intersection-With-Sphere" class="headerlink" title="ray Intersection With Sphere"></a>ray Intersection With Sphere</h4><ul><li>球方程:$\mathbf{p}: (\mathbf{p} - \mathbf{c})^{2} - R^{2} = 0$</li><li>交点求法:联立光线方程和球方程,得</li></ul><script type="math/tex; mode=display">(\mathbf{o}+t \mathbf{d}-\mathbf{c})^{2}-R^{2}=0</script><ul><li>然后求根</li></ul><h3 id="ray-Intersection-with-隐式表面"><a href="#ray-Intersection-with-隐式表面" class="headerlink" title="ray Intersection with 隐式表面"></a>ray Intersection with 隐式表面</h3><ul><li>推广到隐式表面,联立下面方程求根<script type="math/tex; mode=display">\mathbf{p} : f(\mathbf{p}) = 0</script><script type="math/tex; mode=display">f(\mathbf{o}+t \mathbf{d})=0</script></li></ul><h3 id="ray-Intersection-with-显式表面-Triangle-Mesh"><a href="#ray-Intersection-with-显式表面-Triangle-Mesh" class="headerlink" title="ray Intersection with 显式表面-Triangle Mesh"></a>ray Intersection with 显式表面-Triangle Mesh</h3><ul><li>光线和三角形求交的作用<ul><li>Rendering:Visibility,shaows,lighting</li></ul></li><li>Geometry:inside/outside test<ul><li>射线法:对于封闭区域,对任意一点p射出一条线,如果与封闭区域有奇数个交点则在区域内,否则在区域外</li></ul></li><li><p>如何判断光线和物体相交.</p><ul><li>simple idea:intersect ray with each triangle\<ul><li>缺点:slow</li><li>加速方法:kdtree,bouding box</li></ul></li></ul></li><li><p>光线与三角形求交的方法</p><ul><li>Triangle is in a plane<ul><li>平面定义:点法式 $\mathbf{p}:(\mathbf{p}-\mathbf{p’} )\cdot \mathbf{N} = 0$<br><img src="Games101/Plane_equation.png" alt></li></ul></li><li>Get Ray-plane intersection<ul><li>联立平面方程和光线方程</li><li>Möller Trumbore Algorithm: 计算交点<ul><li>A faster approach, giving barycentric coordinate directly</li><li>判断合理：t为正</li><li>判断在三角形内：重心坐标三个系数均为正<br><img src="Games101/Moller_Trumbore_Algorithm.png" alt></li></ul></li></ul></li><li>Test if hit point is inside triangle</li></ul></li></ul><h2 id="Accelerating-Ray-Surface-Intersection"><a href="#Accelerating-Ray-Surface-Intersection" class="headerlink" title="Accelerating Ray-Surface Intersection"></a>Accelerating Ray-Surface Intersection</h2><p>原始：每根光线和每个三角形求交（太慢！）</p><p>加速：包围盒,kdtree</p><h3 id="Bounding-Volumes-包围盒"><a href="#Bounding-Volumes-包围盒" class="headerlink" title="Bounding Volumes 包围盒"></a>Bounding Volumes 包围盒</h3><ul><li>bound complex object with a simple volume</li><li>碰不到包围盒，就肯定碰不到里面的物体</li></ul><p>We often use an <strong>Axis-Aligned Bounding Box (AABB)</strong>(轴对其包围盒)</p><blockquote><p>三对面与坐标轴平行</p></blockquote><ul><li>有点<ul><li>光线与包围盒求相交的时候,只需要将光线分解为沿坐标轴的分量计算即可.</li></ul></li></ul><p><img src="Games101/Axis_Aligned_pros.png" alt></p><h4 id="Ray-Intersection-with-Axis-Aligned-Box"><a href="#Ray-Intersection-with-Axis-Aligned-Box" class="headerlink" title="Ray Intersection with Axis-Aligned Box"></a>Ray Intersection with Axis-Aligned Box</h4><ul><li>原理：<ul><li>The ray enters the box only when it enters all pairs of slabs.</li><li>The ray exits the box as long as it exits any pair of slabs</li></ul></li><li>首先,求出三对面形成的交集 xmin, xmax, ymin, ymax, zmin, zmax</li><li>判断求交：光线与三对面的交点：三组(tmin,tmax) 如果有交集（即有同时在三对面内的时间），则与盒子有交</li><li>$t_{enter} = max(t_{min})$</li><li>$t_{exit} = min(t_{max})$</li></ul><hr><ul><li>If $t_{enter} &lt; t_{exit}$<ul><li>光线在包围盒中停留了一段时间,光线与bb一定相交</li></ul></li><li>光线是一条射线<ul><li>should check whether t is negative for physical correctness!</li></ul></li><li>$t_{exit} &lt; 0$<ul><li>包围盒在盒子后方,肯定没有交点</li></ul></li><li>$t_{exit} &gt;= 0 and t_{enter} &lt; 0$<ul><li>光源在包围盒内部</li></ul></li></ul><ul><li>ray and AABB intersect <code>iﬀ</code> $t_{enter}&lt; t_{exit}$ And $t_{exit} &gt;= 0$</li></ul><h2 id="How-to-use-AABB-to-accelerate-ray-tracing"><a href="#How-to-use-AABB-to-accelerate-ray-tracing" class="headerlink" title="How to use AABB to accelerate ray tracing?"></a>How to use AABB to accelerate ray tracing?</h2><ul><li>Uniform grids 均一网格</li><li>Spatial partitions 空间划分</li></ul><h3 id="Uniform-grids-Partitions-均一网格划分"><a href="#Uniform-grids-Partitions-均一网格划分" class="headerlink" title="Uniform grids Partitions 均一网格划分"></a>Uniform grids Partitions 均一网格划分</h3><p>Preprocess - Build Acceleration Grid</p><ol><li>Find bounding box</li><li>Create grid</li><li>Store each object in overlapping cells</li></ol><p>Ray-Scene Intersection</p><ul><li>Step through grid in ray traversal order(Bresenham 线扫描)</li><li>For each grid cell<ul><li>Test intersection  with all objects stored at that cell</li></ul></li></ul><p>注意：</p><ul><li>格子不能太密集/稀疏<ul><li><h1 id="cells-格子数-C-objs-物体数"><a href="#cells-格子数-C-objs-物体数" class="headerlink" title="cells(格子数) = C * #objs(物体数)"></a>cells(格子数) = C * #objs(物体数)</h1><ul><li>C ~ 27 in 3D</li></ul></li></ul></li><li>Work in 当物体分布均匀时，还挺好用的</li><li>Fail in “Teapot in a stadium” problem</li></ul><h4 id="画线算法"><a href="#画线算法" class="headerlink" title="画线算法"></a>画线算法</h4><ul><li>DDA</li><li>bresenham</li></ul><h3 id="Sptial-Partition"><a href="#Sptial-Partition" class="headerlink" title="Sptial Partition"></a>Sptial Partition</h3><ul><li><p>Oct-tree </p><ul><li>八叉树（三维均匀切分）（与维数有关）</li></ul></li><li><p><strong>KD-Tree</strong> </p><ul><li><strong>每次只沿某一个轴划分 二叉树like</strong><ul><li>3D情况下,第一次对X轴,第二次y轴,第三次z轴,然后反复</li></ul></li></ul></li><li><p>BSP-Tree </p><ul><li>每次取一个方向（非横平竖直）将空间分为两部分 （会很麻烦）<ul><li>三维需要用一个屏幕去划分</li></ul></li></ul></li></ul><hr><p>KD-Tree Pre-Processing</p><ul><li>划分空间，存入二叉树</li><li><p>内部节点存储以下信息</p><p>  split axis: x-, y-, or Z-axis<br>  split position: coordinate of split plane along axis<br>  children: pointers to child nodes</p></li><li><p>叶节点存储</p><p>  list of objects</p></li></ul><hr><p>Traversing a KD-Tree</p><ul><li>光线从根结点开始向下遍历，若有交点则深入（可能与其子节点都有交点，继续判断），若无交点则离开（不可能与其子节点有交点），碰到叶子节点则与其中所有物体求交</li></ul><ul><li>存在问题<ul><li>问题1：三角形与Bounding Box(即空间划分的区域)包含情况求解困难<ul><li>（可能出现三角形三个顶点都不在Box内，三角形却有一部分在Box内的情况）</li></ul></li><li>问题2：一个物体可能存在于多个叶子节点中</li></ul></li></ul><h3 id="Object-Partitions-amp-BVH-Bounding-Volume-Hierarchy-层次包围盒"><a href="#Object-Partitions-amp-BVH-Bounding-Volume-Hierarchy-层次包围盒" class="headerlink" title="Object Partitions &amp; BVH(Bounding Volume Hierarchy)(层次包围盒)"></a>Object Partitions &amp; BVH(Bounding Volume Hierarchy)(层次包围盒)</h3><ul><li><p>以object为单位划分空间</p></li><li><p>形式:二叉树，两个子节点分别存两部分物体的AABB</p></li><li><p>特点:一个物体只可能出现在一个包围盒中</p><ul><li>如何划分很有讲究，不好的划分会使包围盒重合，降低效率</li></ul></li></ul><hr><ul><li>算法:</li></ul><ol><li>Find bounding box </li><li>Recursively split set of objects in two subsets <ul><li>Choose a dimension to split</li><li>Heuristic #1: Always choose the longest axis in node</li><li>Heuristic #2: Split node at location of median object(中位数）<ul><li>中位数</li></ul></li></ul></li><li>Recompute the bounding box of the subsets </li><li><p>Stop when necessary </p><p> Heuristic: stop when node contains few elements (e.g. 5)</p></li><li><p>Store objects in each leaf node</p></li></ol><hr><ul><li>数据结构:</li></ul><p>Internal nodes store</p><ul><li>Bounding box</li><li>Children: pointers to child nodes</li></ul><p>Leaf nodes store</p><ul><li>Bounding box</li><li>List of objects</li></ul><p>Nodes represent subset of primitives in scene(节点表示场景中基本体的子集)</p><ul><li>All objects in subtree</li></ul><hr><ul><li>动态场景需要每帧重新构建</li></ul><hr><ul><li>BVH Traversal</li></ul><pre><code class="lang-cpp">Intersect(Ray ray,BVH node){    if(ray missed node.bbox) return;    if(node is a leaf node)        test intersection with all objs;        return closest intersection;    hit1 = Intersect(ray,node.child1);    hit2 = Intersect(ray,node.child2);    return the closer of hit1,hit2;}</code></pre><hr><ul><li>Spatial vs Object Partitions<ul><li>Spatial partition(e.g. KD-tree)<ul><li>Partition space into non-overlapping regions</li><li>An object can be contained in multiple regions</li></ul></li><li>Object partition(e.g. BVH)<ul><li>Partition set of objects into disjoint subsets</li><li>Bounding boxes for each set may overlap in space</li></ul></li></ul></li></ul><h1 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry(辐射度量学)"></a>Basic radiometry(辐射度量学)</h1><ul><li>Whitted Style Ray Tracing 无法保证正确性</li><li>辐射度量学：精准度量光的一系列物理量 → Physically Based</li><li>特点:<ul><li>the basics of Path Tracing</li><li>Measurement system and units for illumination(照明测量系统和单位)</li><li>Accurately measure the spatial properties of light<ul><li>New terms: Radiant flux, intensity, irradiance, radiance</li></ul></li><li>Perform lighting calculations <strong>in a physically correct manner</strong></li></ul></li></ul><h2 id="各种物理量"><a href="#各种物理量" class="headerlink" title="各种物理量"></a>各种物理量</h2><ul><li>Radiant Energy[辐射能量]:   <ul><li>电磁辐射的能量<ul><li>每个光子都具有一定量的能量，和频率相关，频率越高，能量也越高。</li><li>符号：Q</li><li>单位：J（Joule焦耳）</li></ul></li></ul></li></ul><hr><ul><li>Radiant flux(power)[辐射功率=辐射通量]<ul><li>the energy emitted, reflected, transmitted or received, per unit time. （单位时间能量 → 功率）<ul><li>指单位时间内通过表面或者空间区域的能量的总量</li><li>符号：ϕ （phi）</li><li>单位：W（Watt），lm（lumen流明）</li><li>单位时间 很重要</li></ul></li></ul></li><li>flux:#photos flowing through a sensor in unit time(单位时间内接受到的光子数量)</li></ul><hr><ul><li>Radiant Intensity[辐射强度]<ul><li>Radiant(luminous) Intensity: the power per unit solid angle (立体角) emitted by a point light source.<ul><li>由点光源发射的单位立体角的的功率</li></ul></li><li>符号定义：$I(\omega) = \frac{\mathrm{d} \Phi}{\mathrm{d} \omega}$</li><li>单位：W/sr，lm/sr=cd(candela坎德拉)</li></ul></li></ul><ul><li><p>立体角</p><ul><li>弧度：弧长/半径</li><li><p>弧度在三维的延伸→立体角：面积/半径^2，</p><script type="math/tex; mode=display">\Omega=\frac{A}{r^{2}}</script></li><li><p>单位：sr, steradians</p></li><li>球面=4pi sr</li><li><p>单位(微分)立体角:</p><ul><li>在极点和赤道上$\theta$和$\phi$的变化造成的微分立体角的变化程度是不一样的。</li></ul><script type="math/tex; mode=display">\mathrm{d} \omega=\frac{\mathrm{d} A}{r^{2}}=\sin \theta \mathrm{d} \theta \mathrm{d} \phi</script></li><li><p>对于各向同性点光源(Istropic Point Source)</p><script type="math/tex; mode=display">I = \frac{\phi}{4\pi}</script></li></ul></li></ul><hr><ul><li><p>Irradiance[辐照度=辐射通量密度]</p><ul><li><p>power per unit area (perpendicular/ projected) incident on a surface point</p><ul><li>指单位时间内到达单位面积的辐射能量，或到达单位面积的辐射通量，也就是通量对于面积的密度<ul><li>投射到每单位投影面积上的功率</li></ul></li><li>要求光线垂直的表面<ul><li>符号定义:</li></ul></li></ul><script type="math/tex; mode=display">E(\mathbf{x}) \equiv \frac{\mathrm{d} \Phi(\mathbf{x})}{\mathrm{d} A^{\perp}}</script><p>$,A^{\perp} = Acos\theta,即光线与该点法线的夹角$</p></li></ul><ul><li>单位：$\frac{W}{m^{2}}$ or $\frac{lm}{m^{2}} = lux$</li><li>需要注意，是垂直方向<ul><li>Irradiance at surface is proportional to cosine of angle between light direction and surface normal.<ul><li>表面的Irradiance与光的方向和表面法线之间的角度的余弦成正比。</li><li>In general,power per unit area is proportional to $cos\theta = l \cdot n$<ul><li>$E = \frac{\phi}{A}cos\theta$</li></ul></li></ul></li><li>地球的四季:因为光照在地球不同位置的照射角度不同</li><li>Falloff: 点光源的能量散布,Intensity不衰减,衰减的是Irradiance</li></ul></li><li>无方向性</li></ul></li></ul><hr><ul><li><p>Radiance[辐射率]</p><ul><li>Radiance is the fundamental field quantity that describes the distribution of light in an environment(Radiance是描述环境中光分布的基本场量)<ul><li>Radiance is the quantity associated with a ray(Radiance是与光线相关联的量)</li><li>Rendering is all about computing radiance</li></ul></li><li>Radiance is the power per unit solid angle, per projected unit area.<ul><li>辐射率从一个微小面积表面出发，射向某个微小方向的通量（或者来自某个微小方向，照射到微小面积表面的通量）<ul><li>辐射率实际上可以看成是我们眼睛看到（或相机拍到）的物体上一点的颜色。在基于物理着色时，计算表面一点的颜色就是计算它的辐射率。</li></ul></li></ul></li><li>公式表示:<script type="math/tex; mode=display">L(\mathrm{p}, \omega) \equiv \frac{\mathrm{d}^{2} \Phi(\mathrm{p}, \omega)}{\mathrm{d} \omega \mathrm{d} A \cos \theta}</script> $,cos\theta$ accounts for projected surface</li><li>单位:[$\frac{W}{sr \cdot m^{2}}$] [$\frac{cd}{m^{2}} = \frac{lm}{sr \cdot m^{2}} = nit$]</li><li>某个单位面积往某个单位立体角辐射的能量密度<ul><li>Radiance: <strong>Irradiance</strong> per solid angle</li><li>Radiance: <strong>Intensity</strong> per projected unit area</li></ul></li><li><p>入射Radiance(Incident Radiance)</p><ul><li><p>Incident radiance is the irradiance per unit solid angle arriving at the surface. 某个小面接受来自某个方向的光线</p><script type="math/tex; mode=display">L(\mathrm{p}, \omega)=\frac{\mathrm{d} E(\mathrm{p})}{\mathrm{d} \omega \cos \theta}</script><p>$,E(p)$:Irradiance<br>$,L_{i}(p,\omega)$:Radiance</p></li><li>Incident radiance和irradiance的区别是irradiance是单位面积内接受来自所有方向的Power,radiance是单位面积内接收来自某一方向的power.</li></ul></li><li><p>Exiting Radiance[辐出度]</p><ul><li><p>Exiting surface radiance is the intensity per unit projected area leaving the surface. 某个小面发出向某个方向的光线</p><script type="math/tex; mode=display">L(\mathrm{p}, \omega)=\frac{\mathrm{d} I(\mathrm{p}, \omega)}{\mathrm{d} A \cos \theta}</script><p>$,I(p,\omega)$:Intensity<br>$,L_{i}(p,\omega)$:Radiance</p></li></ul></li></ul></li></ul><hr><ul><li>Irradiance vs. Radiance<ul><li>Irradiance:total power received by area dA</li><li>Radiance:power received by area dA from “direction” d$\omega$  </li><li>之间的关联(由入射Radiance(Incident Radiance)中的公式推导得):<script type="math/tex; mode=display">\begin{aligned} d E(\mathrm{p}, \omega) &=L_{i}(\mathrm{p}, \omega) \cos \theta \mathrm{d} \omega \\ E(\mathrm{p}) &=\int_{H^{2}} L_{i}(\mathrm{p}, \omega) \cos \theta \mathrm{d} \omega \end{aligned}</script>  ,对半球面上的所有角度积分<br> $,E(p,\omega)$:Irradiance<br> $,L_{i}(p,\omega)$:Radiance<br> $,H^{2}$：半球面</li></ul></li></ul><h2 id="Bidirectional-Reflectance-Distribution-Function-BRDF-双向反射分布函数"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF-双向反射分布函数" class="headerlink" title="Bidirectional Reflectance Distribution Function (BRDF) 双向反射分布函数"></a>Bidirectional Reflectance Distribution Function (BRDF) 双向反射分布函数</h2><blockquote><p>参考 <a href="(https://zhuanlan.zhihu.com/p/21376124">基于物理着色：BRDF</a>)</p></blockquote><ul><li>定义:BRDF用于描述表面入射光和反射光关系的。对于一个方向的入射光，表面会将光反射到表面上半球的各个方向，不同方向反射的比例是不同的，我们用BRDF来表示指定方向的反射光和入射光的比例关系<ul><li>反射的理解：光线打到某个点，（被吸收了）然后反弹（发出）到其他地方</li></ul></li></ul><p><img src="Games101/brdf_Reflection_at_a_point.png" alt></p><ul><li><p>BRDF定义:</p><p>  <img src="Games101/brdf_definition.png" alt></p><ul><li>$f_{r}(\omega_{i} \rightarrow \omega_{r})$:表示从$\omega_{i}$方向的入射光线$L_{r}$照射到微表面x上,微表面x吸收入射光线的Radiance后,向$\omega_{r}$反射光线的Radiance的比例，即BRDF.<ul><li>$\omega_{i}$为入射方向</li><li>$\omega_{r}$为出射方向</li></ul></li><li>$dL_{r}(\omega_{r})$:是表面反射到$\omega_{r}$方向的反射光的微分辐射率(Randiance)。<ul><li>表面反射到$\omega_{r}$方向的反射光的辐射率为$L_{r}(\omega_{r})$，来自于表面上半球所有方向的入射光线的贡献，而微分辐射率$dL_{r}(\omega_{r})$特指来自方向$\omega_{i}$的入射光贡献的反射辐射率。</li></ul></li><li>$dE_{i}(\omega_{i})$是表面上来自入射光方向$\omega_{i}$的微分辐照度(Irradiance)。<ul><li>表面接收到的辐照度为$E_{i}(\omega_{i})$，来自上半球所有方向的入射光线的贡献，而微分辐照度$dE_{i}(\omega_{i})$特指来自于方向$\omega_{i}$的入射光。</li></ul></li><li>表面对不同频率的光反射率可能不一样，因此BRDF和光的频率有关。在图形学中，将BRDF表示为RGB向量，三个分量各有自己的$f$(即BRDF)函数。</li></ul></li></ul><h3 id="为什么BRDF要定义成辐射率和辐照度的比值，而不是直接定义为辐射率和辐射率比值"><a href="#为什么BRDF要定义成辐射率和辐照度的比值，而不是直接定义为辐射率和辐射率比值" class="headerlink" title="为什么BRDF要定义成辐射率和辐照度的比值，而不是直接定义为辐射率和辐射率比值?"></a>为什么BRDF要定义成辐射率和辐照度的比值，而不是直接定义为辐射率和辐射率比值?</h3><p><a href="https://zhuanlan.zhihu.com/p/21376124" target="_blank" rel="noopener">基于物理着色：BRDF</a></p><h2 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h2><ul><li>针对一个输出源（着色点），积分所有方向输入源（光照）的BRDF，获得最后的输出</li></ul><script type="math/tex; mode=display">L_{r}\left(\mathrm{p}, \omega_{r}\right)=\int_{H^{2}} f_{r}\left(\mathrm{p}, \omega_{i} \rightarrow \omega_{r}\right) L_{i}\left(\mathrm{p}, \omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i}</script><ul><li><p>对于包含RGB分量的BRDF</p><script type="math/tex; mode=display">L_{r}\left(\mathrm{p}, \omega_{r}\right)=\int_{H^{2}} f_{r}\left(\mathrm{p}, \omega_{i} \rightarrow \omega_{r}\right) \otimes L_{i}\left(\mathrm{p}, \omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i}</script><ul><li>符号$\otimes$表示按向量的分量相乘，因为$f_{r}$和$L_{i}$都包含RGB三个分量</li></ul></li></ul><p><img src="Games101/Relfection_Equation_Simplifition.png" alt></p><p>Challenge: Recursive Equation</p><ul><li>不只有光源才是输入源，其他物体的反射光也有可能是输入源</li><li>递归的计算方式，计算量爆炸！</li></ul><h2 id="The-Rendering-Equation-渲染方程（绘制方程）"><a href="#The-Rendering-Equation-渲染方程（绘制方程）" class="headerlink" title="The Rendering Equation 渲染方程（绘制方程）"></a>The Rendering Equation 渲染方程（绘制方程）</h2><p><strong>Rendering Equation (Kajiya 86) 跨时代</strong></p><p>Adding an Emission term to the reflection equation to make it general!</p><script type="math/tex; mode=display">L_{o}\left(p, \omega_{o}\right)=L_{e}\left(p, \omega_{o}\right)+\int_{\Omega^{+}} L_{i}\left(p, \omega_{i}\right) f_{r}\left(p, \omega_{i}, \omega_{o}\right)\left(n \cdot \omega_{i}\right) \mathrm{d} \omega_{i}</script><ul><li>包括了物体自己会发光的情况，包括了所有光线的传播情况</li><li>assume that all directions are pointing outwards!<ul><li>所有光线朝向都是从照射点开始向外的</li></ul></li><li>$H^2$和$\Omega^{+}$ 都代表半球</li></ul><ul><li><p>对于一个点光源,渲染方程可写成:<br><img src="Games101/Dot_Point_Rendering_Equation.png" alt></p></li><li><p>对于多个点光源,渲染方程可写成:<br><img src="Games101/Multi_Dot_Light_Rendering_Equation.png" alt></p></li><li><p>对于一个面光源,渲染方程可写成:<br><img src="Games101/Flat_Light_Rendering_Equation.png" alt></p></li><li><p>对于其他物体反射的面光源,渲染方程可写成:<br><img src="Games101/Flat_Interreflection_Light_Rendering%20Equation.png" alt></p></li></ul><h3 id="渲染方程简化"><a href="#渲染方程简化" class="headerlink" title="渲染方程简化"></a>渲染方程简化</h3><script type="math/tex; mode=display">L_{r}\left(x, \omega_{r}\right)=L_{e}\left(x, \omega_{r}\right)+\int_{\Omega} L_{r}\left(x^{\prime},-\omega_{i}\right) f\left(x, \omega_{i}, \omega_{r}\right) \cos \theta_{i} d \omega_{i}</script><ul><li>这个方程是 Fredholm Integral Equation of second kind [extensively studied numerically] with canonical form → 简写为如下形式:</li></ul><script type="math/tex; mode=display">I(u)=e(u)+\int l(v)K(u,v)dv</script><ul><li>根据线性算子方程(Lineara Operator Equation)<ul><li>$K(u,v)dv$是Kernal of equation,Light Transport Operator</li></ul></li><li><p>Can be discretized to a simple matrix equation [or system of simultaneous linear equations] (L, E are vectors, K is the light transport matrix)</p><ul><li><p>可以离散为一个简单的矩阵方程[或联立线性方程组]（L，E是向量，K是光传输矩阵）</p><script type="math/tex; mode=display">L = E + KL</script><ul><li>L为未知数</li><li>k为反射算符</li></ul></li></ul></li></ul><p><img src="Games101/Solution_For_Rendering_Equation.png" alt></p><ul><li>Binomial Theorem:二项式定理<br><img src="Games101/Meaning_Of_Rendering_Equation_Solution.png" alt></li><li>光栅化的着色过程只有直接光照（间接光照需要间接计算）</li><li>全局光照：直接和间接光照的集合<ul><li>会收敛到一个亮度</li></ul></li></ul><h2 id="Probability-Review"><a href="#Probability-Review" class="headerlink" title="Probability Review"></a>Probability Review</h2><ul><li>随机变量$X$: 可能取很多数值的变量</li><li>随机变量的分布函数 $X \sim p(x)$: probability density function (PDF) 取不同数值的概率<ul><li>比如，uniform PDF, 骰子</li><li>概率$p_i$的数值非负，和为1，注意和p(x)的概念不一样。是p(x)的输出。</li></ul></li><li>期望：The average value that one obtains if repeatedly drawing samples from the random distribution. $E[X]=\sum_{i=1}^{n} x_{i} p_{i}$</li></ul><p>连续情况下：</p><ul><li>随机变量的分布函数 $X \sim p(x)$ 是连续的→<strong>Probability Distribution Function (PDF)</strong></li><li>某一个x对应的概率 = p(x)dx （细长条）</li><li>概率密度函数的性质 $p(x) \geq 0$ and $\int p(x) d x=1$</li><li>期望：$E[X]=\int x p(x) d x$</li></ul><p>随机变量的函数：</p><ul><li>如果某个随机变量Y是随机变量X的函数：$Y=f(X)$</li><li>期望的关系：$E[Y]=E[f(X)]=\int f(x) p(x) d x$</li></ul><h1 id="Monte-Carlo-Path-Tracing"><a href="#Monte-Carlo-Path-Tracing" class="headerlink" title="Monte Carlo Path Tracing"></a>Monte Carlo Path Tracing</h1><h2 id="Monte-Carlo"><a href="#Monte-Carlo" class="headerlink" title="Monte Carlo"></a>Monte Carlo</h2><ul><li>一种近似积分方法<ul><li>有时候定积分很难精确计算（解析式求不出），使用数值方法</li></ul></li></ul><ul><li><p>黎曼积分：分解成很多个长方形来积分</p></li><li><p>Monte Carlo积分：随机采样</p></li><li>用任意一个PDF去采样，都可以用下面的式子(蒙特卡洛估计器)求出积分的近似数值</li></ul><script type="math/tex; mode=display">F_{N}=\frac{1}{N} \sum_{i=1}^{N} \frac{f\left(X_{i}\right)}{p\left(X_{i}\right)}</script><blockquote><p>重要性采样</p><ul><li>上述公式等价于定积分的证明<br><a href="https://www.cnblogs.com/heben/p/10971235.html" target="_blank" rel="noopener">【图形学手记】蒙特卡洛积分</a></li></ul><p><a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration" target="_blank" rel="noopener">Monte Carlo Methods in Practice</a></p></blockquote><ul><li>Uniform: p(x) = 1/(b-a)</li></ul><script type="math/tex; mode=display">\int f(x) \mathrm{d} x=\frac{1}{N} \sum_{i=1}^{N} \frac{f\left(X_{i}\right)}{p\left(X_{i}\right)} \quad X_{i} \sim p(x)</script><ul><li>N: 采样数</li><li>样本越多，结果越准</li><li>在x上采样的样本就要在x上积分</li></ul><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><p>Motivation: Whitted-Style Ray Tracing</p><ul><li>Always perform specular reﬂections / refractions</li><li>Stop bouncing at diffuse surfaces</li><li>这些简化不一定正确<ul><li>Where should the ray be reflected for glossy materials? <ul><li>反射到镜面对应的方向附近一圈，而非单单镜面反射,长生类似金属有点模糊的镜面效果</li></ul></li><li>No reflections between diffuse materials? 漫反射不应停下，否则少了很多颜色<ul><li>Color bleeding: 由于漫反射，颜色流到了其他面上</li></ul></li></ul></li></ul><hr><ul><li>Whitted-Style Ray Tracing is Wrong</li><li><p>the rendering equation is correct (部分简化光线的性质)</p><script type="math/tex; mode=display">L_{o}\left(p, \omega_{o}\right)=L_{e}\left(p, \omega_{o}\right)+\int_{\Omega^{+}} L_{i}\left(p, \omega_{i}\right) f_{r}\left(p, \omega_{i}, \omega_{o}\right)\left(n \cdot \omega_{i}\right) \mathrm{d} \omega_{i}</script><ul><li>但是它包括了对半球面的积分，还有递归</li><li>但是我们只需要solve this integral numerically → Monte Carlo</li></ul></li></ul><h3 id="解直接光照下的渲染方程"><a href="#解直接光照下的渲染方程" class="headerlink" title="解直接光照下的渲染方程"></a>解直接光照下的渲染方程</h3><p><img src="Games101/Direct_Monte_Carlo_Solution.png" alt></p><ul><li>最简化：只考虑直接光照，只考虑非光源</li></ul><script type="math/tex; mode=display">\begin{aligned} L_{o}\left(p, \omega_{o}\right) &=\int_{\Omega^{+}} L_{i}\left(p, \omega_{i}\right) f_{r}\left(p, \omega_{i}, \omega_{o}\right)\left(n \cdot \omega_{i}\right) \mathrm{d} \omega_{i} \\ & \approx \frac{1}{N} \sum_{i=1}^{N} \frac{L_{i}\left(p, \omega_{i}\right) f_{r}\left(p, \omega_{i}, \omega_{o}\right)\left(n \cdot \omega_{i}\right)}{pdf\left(\omega_{i}\right)} \end{aligned}</script><ul><li>算法:</li></ul><pre><code class="lang-cpp">shape(p,wo)//p为着色点,wo为出射方向  Randomly choose N directions wi~pdf // wi为入射放射,pdf为采样的概率密度函数  Lo = 0.0//Lo为出射光线  For each wi    Trace a ray r(p,wi)    If ray r hit the light      Lo += (1/N) * L_i * f_r * cosine / pdf(wi)    return Lo;</code></pre><h3 id="解间接光照下的渲染方程"><a href="#解间接光照下的渲染方程" class="headerlink" title="解间接光照下的渲染方程"></a>解间接光照下的渲染方程</h3><ul><li>算法:</li></ul><pre><code class="lang-cpp">shape(p,wo)//p为着色点,wo为出射方向  Randomly choose N directions wi~pdf // wi为入射放射,pdf为采样的概率密度函数  Lo = 0.0//Lo为出射光线  For each wi    Trace a ray r(p,wi)    If ray r hit the light      Lo += (1/N) * L_i * f_r * cosine / pdf(wi)    Else If ray r hit an object at q      Lo += (1/N) * shade(q,-wi) * f_r * cosine / pdf(wi)//这是-wi指的是出射方向,记得所有的光线都定义为从着色点向外    return Lo;</code></pre><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><h4 id="Porblem-1-Explosion-of-rays-as-bounces-go-up"><a href="#Porblem-1-Explosion-of-rays-as-bounces-go-up" class="headerlink" title="Porblem 1 : Explosion of #rays as #bounces go up:"></a>Porblem 1 : Explosion of #rays as #bounces go up:</h4><ul><li>每次采样n条光线会导致间接光照按指数级递增,导致光线数量爆炸</li><li>解决方法:每次只射出一条光线(肯定会很noisy)<ul><li>N = 1 是路径追踪</li><li>N &gt; 1 是分布式光线追踪</li></ul></li></ul><pre><code class="lang-cpp">shape(p,wo)//p为着色点,wo为出射方向  Randomly choose ONE directions wi~pdf // wi为入射放射,pdf为采样的概率密度函数  Trace a ray r(p,wi)  If ray r hit the light    return  L_i * f_r * cosine / pdf(wi)  Else If ray r hit an object at q    return  shade(q,-wi) * f_r * cosine / pdf(wi)//这是-wi指的是出射方向,记得所有的光线都定义为从着色点向外</code></pre><ul><li>如何解决noisy问题</li></ul><ul><li>在像素中随机采样,然后从摄像机到该像素中的采样点生成不同的光线,每一个Pass执行一次路径追踪,最后平均.</li></ul><pre><code class="lang-cpp">Ray_generation(camPos,pixel)  Uniformly choose N sample position within the pixel  pixel_radiance = 0.0  For each smaple in the pixel    shoot a ray r(camPos,cam_to_sample/*从摄像机到像素*/)    If ray r hit the scence at p      pixel += 1/N * shade(p, sample_to_cam/*点p到摄像机,注意着色点光线向外*/)  return pixel_radiance</code></pre><h4 id="Porblem-2-the-light-does-not-stop-bouncing-indeed"><a href="#Porblem-2-the-light-does-not-stop-bouncing-indeed" class="headerlink" title="Porblem 2 : the light does not stop bouncing indeed"></a>Porblem 2 : the light does not stop bouncing indeed</h4><ul><li>递归算法要有终止条件,不然会导致递归爆炸.<h5 id="方法一-设置终止层数-弹跳次数"><a href="#方法一-设置终止层数-弹跳次数" class="headerlink" title="方法一:设置终止层数(弹跳次数)"></a>方法一:设置终止层数(弹跳次数)</h5></li><li>缺陷:结果能量损失</li></ul><h5 id="方法二-Russian-Roulette-RR-俄罗斯轮盘赌"><a href="#方法二-Russian-Roulette-RR-俄罗斯轮盘赌" class="headerlink" title="方法二:Russian Roulette(RR)(俄罗斯轮盘赌)"></a>方法二:Russian Roulette(RR)(俄罗斯轮盘赌)</h5><ul><li>设置一个随机变量P(比如0~1的均匀分布)</li><li>With probability p,继续发出光线，<strong>return the shading result divided by P: Lo / P</strong> </li><li>With probability 1 - P, 停止计算，返回0</li><li>最后得到的Lo的期望:$E= P <em>\frac{Lo}{P} + (1-p)</em>0=Lo$<ul><li>采样到无穷大的时候,结果能收敛到Lo</li></ul></li></ul><pre><code class="lang-cpp">shape(p,wo)//p为着色点,wo为出射方向  Manually specify a probability P_RR  Randomly select ksi in a uniform dist. in [0,1]  if(ksi &gt; P_RR) return 0.0  Randomly choose ONE directions wi~pdf // wi为入射放射,pdf为采样的概率密度函数  Trace a ray r(p,wi)  If ray r hit the light    return  L_i * f_r * cosine / pdf(wi) /P_RR  Else If ray r hit an object at q    return  shade(q,-wi) * f_r * cosine / pdf(wi)/P_RR//这是-wi指的是出射方向,记得所有的光线都定义为从着色点向外</code></pre><hr><h3 id="Problem-3-：it’s-not-really-efficient"><a href="#Problem-3-：it’s-not-really-efficient" class="headerlink" title="Problem 3 ：it’s not really efficient"></a>Problem 3 ：it’s not really efficient</h3><ul><li>low SPP(sample per pixel) 会非常的noisy<ul><li>原因:均匀采样导致，环境当中光线的来源往往不是均匀的。a lot of rays are “wasted” if we uniformly sample the hemisphere at the shading point.</li><li>在着色点对半球面进行采样,导致大量的采样光线not hit光源造成了浪费</li></ul></li></ul><hr><ul><li><p>解决方法:对光源进行采样.</p><ul><li>对光源积分是个很高效的想法，但是积分的对象和”Sample on x &amp; integrate on x”的要求不匹配→只需要找到光源对应$\omega_i$的关系就行→改变积分域</li></ul><p><img src="Games101/dw_dA_Relation.png" alt></p><ul><li>该关系通过立体角定义(微分立体角 = 微分面积/距离的平方)得出</li></ul></li><li><p>对光源采样的路径追踪</p><script type="math/tex; mode=display">\begin{aligned} L_{o}\left(x, \omega_{o}\right) &=\int_{\Omega^{+}} L_{i}\left(x, \omega_{i}\right) f_{r}\left(x, \omega_{i}, \omega_{o}\right) \cos \theta \mathrm{d} \omega_{i} \\ &=\int_{A} L_{i}\left(x, \omega_{i}\right) f_{r}\left(x, \omega_{i}, \omega_{o}\right) \frac{\cos \theta \cos \theta^{\prime}}{\left\|x^{\prime}-x\right\|^{2}} \mathrm{d} A \end{aligned}</script><ul><li>$x$ ~ $pdf(x) = \frac{1}{A}$</li></ul></li></ul><hr><ul><li>算法：然后我们就可以consider the radiance coming from two parts:<ul><li><ol><li>light source (direct, no need to have RR) 直接光照</li></ol></li><li><ol><li>other reflectors (indirect, RR) 间接光照</li></ol></li></ul></li></ul><pre><code class="lang-cpp">shape(p,wo)//p为着色点,wo为出射方向  // Contribution from the light source.  Uniformly sample the light at x_prime (pdf_light = 1 / A) // &#39; 读作 prime  L_dir = L_i * f_r * cos_theta * cos_theta_prime / | x_prime - p | ^ 2 / pdf_light  // Contribution from other reflections.  L_indir = 0.0  /*Test Russian Roulette with probability P_RR*/  Manually specify a probability P_RR  Randomly select ksi in a uniform dist. in [0,1]  if(ksi &gt; P_RR) return 0.0  Uniformly sample the hemisphere towards wi(pdf_hemi = 1 / 2pi) // wi为入射放射,pdf为采样的概率密度函数  Trace a ray r(p,wi)  If ray r hit a non-emitting object at q    L_indir +=  shade(q,-wi) * f_r * cos_theta / pdf_hemi /P_RR//这是-wi指的是出射方向,记得所有的光线都定义为从着色点向外  return L_dir + L_indir</code></pre><h4 id="Problem-3-1-：if-object-Block-the-light"><a href="#Problem-3-1-：if-object-Block-the-light" class="headerlink" title="Problem 3.1 ：if object Block the light"></a>Problem 3.1 ：if object Block the light</h4><ul><li>首先从着色点发出一条射线到光源判断是否有遮挡</li></ul><pre><code class="lang-cpp">// ...// Contribution from the light source.L_dir = 0.0Uniformly sample the light at x_prime (pdf_light = 1 / A) // &#39; 读作 primeshoot a ray from p to x_primeIf the ray is not blocked in the middle  L_dir = //...// Contribution from other reflections.//...`</code></pre><p>Ray tracing 概念的区分：</p><ul><li>Previous：Ray tracing == Whitted-style ray tracing</li><li>Modern<ul><li>The general solution of light transport, including<ul><li>(Unidirectional &amp; bidirectional) path tracing</li><li>Photon mapping</li><li>Metropolis light transport</li><li>VCM / UPBP…</li></ul></li></ul></li></ul><p>课上没讲的：</p><ul><li>Uniformly sampling the hemisphere<ul><li>How? And in general, how to sample any function?(sampling)</li></ul></li><li>Monte Carlo integration allows arbitrary pdfs<ul><li>What is the best choice? (importance sampling) <strong>重要性采样理论</strong></li></ul></li><li>Do random numbers matter?<ul><li>Yes! (low discrepancy sequences)比如蓝噪音</li></ul></li><li>I can sample the hemisphere and the light<ul><li>Can I combine them? Yes! (multiple imp. sampling)</li></ul></li><li>The radiance of a pixel is the average of radiance on all paths passing through it<ul><li>Why? (pixel reconstruction filter)</li></ul></li><li>Is the radiance of a pixel the color of a pixel?<ul><li>No. (gamma correction（radiance到color的对应关系）, curves(HDR), color space)</li></ul></li></ul><h1 id="Material-and-Appearances"><a href="#Material-and-Appearances" class="headerlink" title="Material and Appearances"></a>Material and Appearances</h1><ul><li><p><a href="https://www.wetafx.co.nz/research-and-tech/technology/manuka/" target="_blank" rel="noopener">Manuka | Weta Digital</a> 渲染器Renderer，支持40种材质。</p></li><li><p>以前只有Blinn Phong的时候，通过非物理的方式模拟出各种材质。</p></li><li><p>Material(材质) == BRDF 决定光如何被反射</p></li></ul><h2 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h2><ul><li>Diffuse / Lambertian Material (BRDF) 漫反射材质</li></ul><p><img src="Games101/Diffuse_Material.png" alt></p><script type="math/tex; mode=display">\begin{aligned} L_{o}\left(\omega_{o}\right) &=\int_{H^{2}} f_{r} L_{i}\left(\omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i} \\ &=f_{r} L_{i} \int_{H^{2}} \cos \theta_{i} \mathrm{d} \omega_{i} \\ &=\pi f_{r} L_{i} \end{aligned}</script><ul><li>能量守恒：进出的irradiance相同（总量）</li><li>漫反射：出的radiance均匀→ $f_r = c$ （常量）</li><li>假设入射光和出射光都是均匀的→ $L_i = L_o$</li></ul><script type="math/tex; mode=display">f_{r}=\frac{\rho}{\pi}</script><ul><li>ρ: albedo(反射率), 0~1（1为完全不吸收能量）</li><li>ρ可以是单通道的,也可以是RGB三通道的.</li></ul><h2 id="Glossy-Material"><a href="#Glossy-Material" class="headerlink" title="Glossy Material"></a>Glossy Material</h2><ul><li>类似铜镜,是镜面反射但仍然有点粗糙</li></ul><p><img src="Games101/Glossy_Material.png" alt></p><h2 id="Ideal-reflective-refractive-material-BSDF"><a href="#Ideal-reflective-refractive-material-BSDF" class="headerlink" title="Ideal reflective / refractive material (BSDF * )"></a>Ideal reflective / refractive material (BSDF * )</h2><ul><li>玻璃和水等</li></ul><p><img src="Games101/Reflective_Refractive_Material.png" alt></p><h3 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h3><ul><li>出射角 == 入射角</li></ul><p><img src="Games101/Reflective_Law.png" alt></p><h4 id="求法1：根据入射角-出射角"><a href="#求法1：根据入射角-出射角" class="headerlink" title="求法1：根据入射角 == 出射角"></a>求法1：根据入射角 == 出射角</h4><ul><li>$\theta=\theta_{o}=\theta_{i}$<ul><li>然后根据四边形法则,四边形的斜边等于$\omega_{i}$在法线上投影的2倍.</li></ul></li></ul><script type="math/tex; mode=display">\begin{aligned} &\omega_{o}+\omega_{i}=2 \cos \theta \vec{n}=2\left(\omega_{i} \cdot \vec{n}\right) \vec{n}\\ &\omega_{o}=-\omega_{i}+2\left(\omega_{i} \cdot \vec{n}\right) \vec{n} \end{aligned}</script><h4 id="求法2-将入射角和出射角-拆分成俯仰角和方位角"><a href="#求法2-将入射角和出射角-拆分成俯仰角和方位角" class="headerlink" title="求法2:将入射角和出射角 拆分成俯仰角和方位角."></a>求法2:将入射角和出射角 拆分成俯仰角和方位角.</h4><ul><li>俯仰角相等且等于$\theta$</li><li>方位角相差180度.</li></ul><script type="math/tex; mode=display">\phi_{o}=\left(\phi_{i}+\pi\right) \bmod 2 \pi</script><ul><li>进行上述变换后在还原成出射角.</li></ul><h3 id="折射和折射定律"><a href="#折射和折射定律" class="headerlink" title="折射和折射定律"></a>折射和折射定律</h3><ul><li>白光分解成彩虹：折射率不同</li><li>Caustics (不合适的翻译：焦散，因为只有聚焦才能被看到)</li><li>折射定律（Snell’s Law）：</li></ul><h4 id="Snell-s-Law-斯涅尔定律"><a href="#Snell-s-Law-斯涅尔定律" class="headerlink" title="Snell`s Law(斯涅尔定律)"></a>Snell`s Law(斯涅尔定律)</h4><script type="math/tex; mode=display">\eta_{i}sin\theta_{i} = \eta_{t}sin\theta_{t}</script><ul><li>$\eta_{i},\eta{t}$为入射材质折射率和折射材质折射率</li><li>$\theta_{i},\theta_{t}$为入射角和折射角</li></ul><ul><li><p>全反射：折射不可能发生的情况下，当入射介质折射率&gt;出射介质折射率时可能发生。</p></li><li><p>BSDF（散射） = BRDF（反射） + BTDF（折射）</p><ul><li>Bidirectional scattering distribution function</li></ul></li></ul><h3 id="Fresnel-Reflection-Term-菲涅尔项"><a href="#Fresnel-Reflection-Term-菲涅尔项" class="headerlink" title="Fresnel Reflection / Term(菲涅尔项)"></a>Fresnel Reflection / Term(菲涅尔项)</h3><ul><li>Reflectance depends on incident angle (and polarization of light)</li><li>和normal法线方向越接近，越少光被反射<ul><li>光线的夹角对<strong>绝缘体</strong>的反射的程度影响大<ul><li>与物体垂直时基本全反射,与物体水平是光线基本全部透过物体.</li></ul></li><li>光线的夹角对<strong>导体</strong>的反射的程度影响小</li></ul></li><li>因为光线有偏振现象,所以一般近似的时候取极化的平均</li></ul><ul><li>精确计算:十分复杂</li></ul><ul><li>近似：Schlick’s approximation</li></ul><script type="math/tex; mode=display">\begin{aligned} R(\theta) &=R_{0}+\left(1-R_{0}\right)(1-\cos \theta)^{5} \\ R_{0} &=\left(\frac{n_{1}-n_{2}}{n_{1}+n_{2}}\right)^{2} \end{aligned}</script><h2 id="Microfacet-Material-微表面材质"><a href="#Microfacet-Material-微表面材质" class="headerlink" title="Microfacet Material 微表面材质"></a>Microfacet Material 微表面材质</h2><p>基于如下假设：离得足够远的时候，微小的东西往往看不见，看见的是最后汇聚起来总体的样子</p><p>Rough surface</p><ul><li>Macroscale: flat &amp; rough<ul><li>远处是粗糙的平面</li></ul></li><li>Microscale: bumpy &amp; specular<ul><li>近处各种不规则的镜面</li></ul></li></ul><p>Individual elements of surface act like mirrors</p><ul><li>Known as Microfacets</li><li>Each microfacet has its own normal</li></ul><p>Microfacet BRDF 微表面模型</p><ul><li>the distribution of microfacets’ normals 法线<ul><li>根据微表面的法线分布来判断材质.</li></ul></li><li>Concentrated &lt;==&gt; glossy</li><li><p>Spread &lt;==&gt; diffuse</p></li><li><p>微表面的BRDF计算：</p><script type="math/tex; mode=display">f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h}) \mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h}) \mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n}, \mathbf{o})}</script><ul><li>$\mathbf{F}(\mathbf{i}, \mathbf{h})$: Fresnel term<ul><li>菲涅尔项,判断有多少光线被反射</li></ul></li><li>$\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})$: shadowing-masking term，微表面互相遮挡的损耗<ul><li>几乎和表面平行的光线方向：Grazing Angle，损耗很大</li><li>用于修正光线接近于Grazing Angle时,微表面自遮挡的亮度问题,不再这一项会导致边缘偏亮.</li></ul></li><li>$\mathbf{D}(\mathbf{h})$: 基于h的法线Distribution, h是half vector，<ul><li>对于法线分布中的与半程向量重合的法线才能被反射过去(根据反射定律)</li></ul></li></ul></li><li><p>效果十分强大</p></li><li>State-of-the-art</li><li>PBR：Physically Based Rendering / Shading</li><li>缺点<ul><li>Diffuse比较少，有时需要手动加</li></ul></li><li>是统称，有很多不同的模型</li></ul><h3 id="Isotropic-Anisotropic-Materials-BRDFs"><a href="#Isotropic-Anisotropic-Materials-BRDFs" class="headerlink" title="Isotropic / Anisotropic Materials (BRDFs)"></a>Isotropic / Anisotropic Materials (BRDFs)</h3><p>电梯间的条状高光→磨过的表面，各向异性Anisotropic</p><ul><li>关键区别<strong>Key: directionality of underlying surface</strong></li></ul><p><img src="Games101/Isotropic_Anisotropic_Material.png" alt></p><p>反映到BRDF上，各向异性的BRDF有如下性质：</p><script type="math/tex; mode=display">f_{r}\left(\theta_{i}, \phi_{i} ; \theta_{r}, \phi_{r}\right) \neq f_{r}\left(\theta_{i}, \theta_{r}, \phi_{r}-\phi_{i}\right)</script><ul><li>方位角不一样时，BRDF不保持一致(Reflection depends on azimuthal angle)</li><li>锅底 → 辐射状高光 （来自VRay 渲染器的一张例图）</li><li>Nylon（编织）, Velvet（天鹅绒，可以人为造成各向异性）</li></ul><h3 id="微表面BRDF的属性"><a href="#微表面BRDF的属性" class="headerlink" title="微表面BRDF的属性"></a>微表面BRDF的属性</h3><ul><li>Non-negativity:描述能量分布肯定是正的.<ul><li>$f_{r}(\omega_{i} \rightarrow \omega_{r}) &gt;=0$</li></ul></li><li>Linearity:<ul><li>brdf的计算可以进行拆分,然后直接加起来</li><li><img src="Games101/BRDF_Linearity.png" alt></li></ul></li><li>Reciprocity principle (可逆性)<ul><li>$f_{r}(\omega_{r} \rightarrow \omega_{i}) =f_{r}(\omega_{i} \rightarrow \omega_{r})$</li></ul></li><li>Energy conservation(能量守恒)<ul><li>入射能量 = 吸收能量 + 反射能量 + 折射能量</li><li>$\forall \int_{H^{2}}{f_{r}(\omega_{r} \rightarrow \omega_{i})cos\theta_{i}d\omega_{i}} \leq 1$</li></ul></li><li>各向同性<ul><li>$f_{r}\left(\theta_{i}, \phi_{i} ; \theta_{r}, \phi_{r}\right) = f_{r}\left(\theta_{i}, \theta_{r}, \phi_{r}-\phi_{i}\right)$<ul><li>从可逆性可得：</li></ul></li><li>$f_{r}\left(\theta_{i}, \theta_{r}, \phi_{r}-\phi_{i}\right)=f_{r}\left(\theta_{r}, \theta_{i}, \phi_{i}-\phi_{r}\right)=f_{r}\left(\theta_{i}, \theta_{r},\left|\phi_{r}-\phi_{i}\right|\right)$</li></ul></li></ul><h3 id="Measuring-BRDFs-测量BRDF"><a href="#Measuring-BRDFs-测量BRDF" class="headerlink" title="Measuring BRDFs(测量BRDF)"></a>Measuring BRDFs(测量BRDF)</h3><ul><li>Motivation:<ul><li>Avoid need to develop / derive models 不用费力推模型</li><li>Can accurately render with real-world materials</li><li>实际和推算出来的经常会有很大差距</li></ul></li></ul><p>方法：</p><ul><li>Image-Based BRDF Measurement<br><img src="Games101/Image_Based_BRDF_Measurement.png" alt></li></ul><h2 id="存储-BRDF"><a href="#存储-BRDF" class="headerlink" title="存储 BRDF"></a>存储 BRDF</h2><p>Desirable qualities</p><ul><li>Compact representation</li><li>Accurate representation of measured data</li><li>Efficient evaluation for arbitrary pairs of directions</li><li>Good distributions available for importance sampling</li></ul><p>一种方式：Tabular Representation</p><ul><li>Store regularly-spaced samples in $\left(\theta_{i}, \theta_{r},\left|\phi_{r}-\phi_{i}\right|\right)$</li><li>Better: reparameterize angles to better match specularities</li><li>Generally need to resample measured values to table</li><li>Very high storage requirements</li><li>实例：MERL BRDF Database [Matusik et al. 2004] 90 <em> 90 </em> 180 measurements</li></ul><h1 id="高级光线传播"><a href="#高级光线传播" class="headerlink" title="高级光线传播"></a>高级光线传播</h1><h2 id="Unbiased-light-transport-methods"><a href="#Unbiased-light-transport-methods" class="headerlink" title="Unbiased light transport methods"></a>Unbiased light transport methods</h2><p>Biased vs. Unbiased Monte Carlo Estimators</p><ul><li>无偏：An unbiased Monte Carlo technique does not have any systematic error<ul><li>无论取多少样本，期望永远是对的</li></ul></li><li>有偏：其他情况<ul><li>One special case, the expected value converges to the correct value as infinite #samples are used — consistent 有偏，但能收敛到无偏(叫做一致的)</li></ul></li></ul><h3 id="BDPT-Bidirectional-Path-Tracing-双向路径追踪"><a href="#BDPT-Bidirectional-Path-Tracing-双向路径追踪" class="headerlink" title="BDPT(Bidirectional Path Tracing 双向路径追踪)"></a>BDPT(Bidirectional Path Tracing 双向路径追踪)</h3><ul><li>实现方法:<ul><li>Traces sub-paths from both the camera and the light (半路径)</li><li>Connects the end points from both sub-paths 半路径末端互相连接，形成通路</li></ul></li></ul><p><img src="Games101/BDPT.png" alt></p><ul><li>好处：Suitable if the light transport is complex on the light’s side<ul><li>对于路径追踪来说对于一个着色点需要计算直接光照和间接光照,对于间接光照我们是在着色点散射之后递归计算radiance的,在采样率低的情况下,光线打到光源的需要经过很多次弹射.</li><li>对于双向路径追踪来说,通过光源半路径和相机半路径直接连接得到光路,可以节省很多次光线弹跳</li></ul></li><li>缺点：Difficult to implement &amp; quite slow 能做出来基本能自己写渲染器了</li></ul><h3 id="Metropolis-light-transport-MLT-梅特波利斯光照传输"><a href="#Metropolis-light-transport-MLT-梅特波利斯光照传输" class="headerlink" title="Metropolis light transport (MLT 梅特波利斯光照传输)"></a>Metropolis light transport (MLT 梅特波利斯光照传输)</h3><ul><li>A Markov Chain Monte Carlo (MCMC) application<ul><li>马尔可夫链帮助采样<ul><li>马尔可夫链：根据当前样本，根据一个概率分布，生成下一个相近的样本</li></ul></li><li>Jumping from the current sample to the next with some PDF</li></ul></li><li>可以做到以任意形状的函数为pdf生成样本<ul><li>蒙特卡罗方法在采样跟被积函数形状一样的pdf的时候variance最小</li></ul></li><li>Key idea: Locally perturb an existing path to get a new path 有一个路径的情况下，可以生成相似的路径(局部方法)</li></ul><p><img src="Games101/MLT.png" alt></p><ul><li>好处：Very good at locally exploring difficult light paths 有了种子，就能找到更多相似的<ul><li>Caustics, Indirect Light Source</li><li>越复杂的场景MLT做的越好</li></ul></li><li>缺点：<ul><li>Difficult to estimate the convergence rate<ul><li>Monte Carlo可以估计Variance，可以量化</li></ul></li><li>Does not guarantee equal convergence rate per pixel(局部方法,渲染过程中有些像素收敛了,有些没有收敛)<ul><li>So, usually produces “dirty” results 看上去比较脏</li><li>Therefore, usually not used to render animations</li></ul></li></ul></li></ul><h2 id="Biased-light-transport-methods"><a href="#Biased-light-transport-methods" class="headerlink" title="Biased light transport methods"></a>Biased light transport methods</h2><ul><li>A biased approach &amp; A two-stage method</li><li>Very good at handling Specular-Diffuse-Specular (SDS) paths and generating caustics<ul><li>caustics(焦散):间接照明光线（即光子）从光源发射出来后，先经过一次（或多次） Specular 表面反、折射作用，再投射到某个Diffuse表面上，最后以Diffuse的形式被摄影机 记录 。<ul><li>泳池波纹等</li></ul></li></ul></li></ul><p>很多种实现方法，这里是其中一种：</p><p>Photon Mapping — Approach (variations apply)</p><ul><li>Stage 1 — photon tracing<ul><li>光源出发，Emitting photons from the light source, bouncing them around, finally recording photons on diffuse surfaces</li></ul></li><li>Stage 2 — photon collection (final gathering)<ul><li>Shoot sub-paths from the camera, bouncing them around, until they hit diffuse surfaces</li></ul></li><li>Calculation — local density estimation 局部光子密度估计<ul><li>Idea: areas with more photons should be brighter</li><li>For each shading point, find the nearest N photons (通过树状结构实现算法，N是固定的). Take the surface area they over 面积计算，然后光子密度=光子数量/面积</li><li>光子数量少：面积大，噪声大；光子数量大：模糊</li></ul></li><li>模糊是因为有偏<ul><li>Local Density estimation dN / dA != ΔN / ΔA 光子密度估计在数量趋向无限时才与真正光子密度相等，所以biased but consistent!</li></ul></li></ul><p>有偏和无偏的实用辨别方法：</p><ul><li>在渲染中：Biased == blurry</li><li>一致的Consistent == not blurry with infinite #samples</li></ul><p><a href="https://www.zhihu.com/question/26683585" target="_blank" rel="noopener">如何理解 (un)biased render？ - 知乎</a></p><ul><li>为什么用最近的n个光子计算光子密度而不用周围一定范围内的光子数量计算光子密度.<ul><li>前一种方法是有偏但一致的</li><li>后一种方法是有偏且不一致的<ul><li>单位面积里求光子数量,随着光子变多,dA永远不会等于ΔA </li></ul></li></ul></li></ul><h3 id="Vertex-connection-and-merging-VCM"><a href="#Vertex-connection-and-merging-VCM" class="headerlink" title="Vertex connection and merging (VCM)"></a>Vertex connection and merging (VCM)</h3><ul><li>A combination of BDPT and Photon Mapping<ul><li>双向光线追踪+光子映射</li></ul></li><li>Key idea:  <ul><li>Let’s not waste the sub-paths in BDPT if their end points cannot be connected but can be merged</li><li>Use photon mapping to handle the merging of nearby “photons”</li></ul></li></ul><p><img src="Games101/VCM.png" alt></p><ul><li>比如，$x_2$和$x^{<em>}_{2}$ 在同一个面上，但是没有重合，按照BDPT，这种就是浪费,因为无法通过一次弹射从$x_2$到$x^{</em>}_{2}$</li><li>但是VCM将$x_2$和$x^{*}_{2}$通过光子映射进行分析.</li></ul><h2 id="Instant-Radiosity-IR-实时辐射度"><a href="#Instant-Radiosity-IR-实时辐射度" class="headerlink" title="Instant Radiosity(IR 实时辐射度)"></a>Instant Radiosity(IR 实时辐射度)</h2><ul><li>sometimes  also called many-light approaches 很多光源的方法</li><li>Key idea: <ul><li>Lit surfaces can be treated as light sources 被照亮的表面就像是光源<ul><li>模拟从光源发出光线，打到的地方相当于二级光源。如果此时Sample某个场景点的颜色，那么遍历这些二级光源，叠加计算即可</li></ul></li></ul></li><li>Approch:<ul><li>Shoot light sub-paths and assume the end point of each sub-path is a Virtual Point Light (VPL)</li><li>Then Render the scene as usual using these VPLs</li></ul></li></ul><p><img src="Games101/IR.png" alt></p><ul><li>Pros: <ul><li>fast and usually gives good results on diffuse scenes</li></ul></li><li>Cons:<ul><li>Spikes will emerge when VPLs are close to shading points<ul><li>蒙特卡洛路径积分的时候，需要对光源进行采样,其中通过面积除以距离的平方计算立体角,当场景中某一点被当做2次光源时,距离这些2次光源近的地方,该项会特别大,导致积分出来的Radiance就特别大.</li></ul></li><li>Cannot handle glossy materials</li></ul></li></ul><p>工业界：Path Tracing，不高端，但可靠</p><h1 id="高级表面建模"><a href="#高级表面建模" class="headerlink" title="高级表面建模"></a>高级表面建模</h1><h2 id="Non-surface-models"><a href="#Non-surface-models" class="headerlink" title="Non-surface models"></a>Non-surface models</h2><h3 id="participating-media-散射介质、参与介质-Fog-cloud"><a href="#participating-media-散射介质、参与介质-Fog-cloud" class="headerlink" title="participating media(散射介质、参与介质):Fog,cloud"></a>participating media(散射介质、参与介质):Fog,cloud</h3><ul><li>At any point as light travels through a participating medium, it can be (partially) absorbed and scattered. （部分）吸收和散射</li><li>散射：Use <strong>Phase Function</strong> to describe the angular distribution of light scattering at any point x within participating media. 规定如何散射</li><li>如何渲染Rendering:<ul><li>Randomly choose a direction to bounce</li><li>Randomly choose a distance to go straight</li><li>At each ‘shading point’, connect to the light</li></ul></li></ul><p>散射介质也有可能是巧克力酱、手指头（</p><h3 id="Hair-fur-fiber-BCSDF"><a href="#Hair-fur-fiber-BCSDF" class="headerlink" title="Hair / fur / fiber(BCSDF)"></a>Hair / fur / fiber(BCSDF)</h3><p>Kajiya-Kay Model</p><ul><li>一根光线，打到圆柱（头发）上，散射出一个圆锥上，同时向四面八方散射（Diffuse+Specular）</li><li>效果不好，很假</li></ul><p><img src="Games101/Kajiya-kay_Model.png" alt></p><hr><p>Marschner Model</p><ul><li>把头发看作Glass-like cylinder，有色素，会吸收能量</li><li>3 types of light interactions: R, TT, TRT (R: reflection, T: transmission)</li><li>一部分直接反射（R）</li><li>一部分穿进头发，再穿出（TT）</li><li>一部分穿进，内部反射，再穿出TRT</li><li>效果不错</li><li>只是单次散射</li></ul><p><img src="Games101/Marschner_Model.png" alt></p><hr><ul><li><p>动物毛发</p><ul><li>不能直接把头发模型用到动物毛发上，两者有差别</li></ul></li><li><p>动物毛发髓质(Medulla)很大，头发比较小，动物毛发忽略之后很明显</p></li></ul><p>方法: Double Cylinder Model：描述了头发和髓质的双层结构</p><ul><li>R，TT，TRT</li><li>TTs，TRTs：经过髓质，被散射过的光</li></ul><p><img src="Games101/Double_Cylinder_Model.png" alt></p><h3 id="Granular-material-颗粒材质"><a href="#Granular-material-颗粒材质" class="headerlink" title="Granular material(颗粒材质)"></a>Granular material(颗粒材质)</h3><p>Can we avoid explicit modeling of all granules?</p><ul><li>Yes with procedural definition.</li></ul><p>目前还没有很好的渲染优化</p><h2 id="Surface-models"><a href="#Surface-models" class="headerlink" title="Surface models"></a>Surface models</h2><h3 id="Translucent-material-BSSRDF-半透明-透光性材质"><a href="#Translucent-material-BSSRDF-半透明-透光性材质" class="headerlink" title="Translucent material(BSSRDF)(半透明,透光性材质)"></a>Translucent material(BSSRDF)(半透明,透光性材质)</h3><h3 id="Subsurface-Scattering-次表面散射-BSSRDF"><a href="#Subsurface-Scattering-次表面散射-BSSRDF" class="headerlink" title="Subsurface Scattering 次表面散射, BSSRDF"></a>Subsurface Scattering 次表面散射, BSSRDF</h3><p>Translucent: 不仅仅是半透明，光线在内部还会有折射，比如玉石，水母，牛奶，人耳</p><p>物理上：Subsurface Scattering 次表面散射</p><ul><li>Visual characteristics of many surfaces caused by light exiting at different points than it enters<ul><li>在不同点处出现的光线引起的许多表面的视觉特征</li></ul></li><li>Violates a fundamental assumption of the BRDF → BSSRDF<ul><li>违反了BRDF→BSSRDF的基本假设</li></ul></li></ul><p>BSSRDF: generalization of BRDF; exitant radiance at one point due to incident differential irradiance at another point: $S\left(x_{i}, \omega_{i}, x_{o}, \omega_{o}\right)$ 进来和出去的点不一定一样</p><p>Generalization of rendering equation: integrating over all points on the surface and all directions 对表面其他地方进入的光线也要考虑，过于复杂</p><script type="math/tex; mode=display">L\left(x_{o}, \omega_{o}\right)=\int_{A} \int_{H^{2}} S\left(x_{i}, \omega_{i}, x_{o}, \omega_{o}\right) L_{i}\left(x_{i}, \omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i} \mathrm{d} A</script><p><img src="Games101/BSSRDF.png" alt></p><p>→ Dipole Approximation [Jensen et al. 2001]: Approximate light diffusion by introducing two point sources. 用两个光源模拟次表面散射</p><p><img src="Games101/Dipole_Approx..png" alt></p><p>BSSRDF: Application</p><ul><li>真实的皮肤</li><li><a href="https://cgelves.com/10-most-realistic-human-3d-models-that-will-wow-you/" target="_blank" rel="noopener">https://cgelves.com/10-most-realistic-human-3d-models-that-will-wow-you/</a></li></ul><h3 id="Cloth-Fiber"><a href="#Cloth-Fiber" class="headerlink" title="Cloth:Fiber"></a>Cloth:Fiber</h3><p>布：A collection of twisted fibers! 由纤维缠绕而成</p><ul><li>每一根纱线是由纤维缠绕而成</li><li>每一股毛线是由纱线缠绕而成</li><li>规模很恐怖</li></ul><p>Render as Surface</p><ul><li>Given the weaving pattern, calculate the overall behavior</li><li>Render using a BRDF，根据不同的织法，给不同的BRDF</li><li>但是布料并不仅仅是表面，天鹅绒那样的效果无法展现</li></ul><p>Render as Participating Media</p><ul><li>Properties of individual fibers &amp; their distribution -&gt; scattering parameters</li><li>空间中分布的体积→细小的格子，对每个格子里布料的性质进行采样，转化成对光线的渲染 （像对云的渲染那样）计算量很恐怖</li></ul><p>Render as Actual Fibers</p><ul><li>Render every fiber explicitly!</li><li>计算量更恐怖</li></ul><h3 id="Detailed-material-non-statical-BRDF"><a href="#Detailed-material-non-statical-BRDF" class="headerlink" title="Detailed material(non-statical BRDF)"></a>Detailed material(non-statical BRDF)</h3><p>Not looking realistic, 因为太过完美</p><p>真实情况下，有很多复杂，不完美的东西</p><p>回顾Microfacet BRDF</p><ul><li>Surface = Specular microfacets + statistical normals</li><li>法线分布(NDF)用了正态分布，其实没有那么完美</li><li>把法线分布改的复杂一点，就会获得更复杂的结果</li><li>法线贴图200k x 200k，获得很好的效果，但是运算量爆炸（甚至一张图要一个月）</li><li>这是因为在法线分布复杂的情况下，很难建立valid的光线通路（光源→表面→摄像机）</li></ul><p>Solution: BRDF over a pixel</p><ul><li>一个像素对应了一块表面，把整块范围内的法线分布整合起来获得（P-NDF），以此简化计算</li><li>小范围的P-NDF会有很多奇妙的样子</li></ul><p>Application:</p><ul><li>Detailed / Glinty Material</li><li>海绵波光粼粼的效果</li></ul><h3 id="Recent-Trend-Wave-Optics"><a href="#Recent-Trend-Wave-Optics" class="headerlink" title="Recent Trend: Wave Optics"></a>Recent Trend: Wave Optics</h3><p>之前所有的计算都把光线当作粒子来计算，但光具有波粒二象性，有很多只有在把光当作波的时候才会有的性质就会被忽略。</p><ul><li>波动光学计算BRDF<ul><li>结果与几何光学类似，但不连续（干涉导致），不同波长也不一样</li></ul></li></ul><h2 id="procedural-appearance"><a href="#procedural-appearance" class="headerlink" title="procedural appearance"></a>procedural appearance</h2><ul><li>Explicitly or Implicitly 不一定需要真的生成，可以查询</li></ul><p>问题：三维模型，三维材质，存储量爆炸</p><p>Can we define details without textures?</p><ul><li>Yes! Compute a noise function on the fly.</li><li>3D noise -&gt; internal structure if cut or broken</li><li>Thresholding (noise -&gt; binary noise)</li></ul><p>Complex noise functions can be very powerful.</p><ul><li>Perlin Noise<ul><li>生成地形</li><li>木头的三维生成</li></ul></li><li>…</li></ul><p>Houdini: 程序化生成材质(Explicitly)</p><h1 id="Camera-Lenses-and-Light-Fields"><a href="#Camera-Lenses-and-Light-Fields" class="headerlink" title="Camera,Lenses and Light Fields"></a>Camera,Lenses and Light Fields</h1><p>Imaging = Synthesis + Capture</p><ul><li>Synthesis: raster | ray tracing 用合成的方法来成像</li><li>Capture: 捕捉真实世界来成像<ul><li>最典型：相机</li><li>Transient Imaging: 研究光在极短时间内的传播</li><li>Computational Photography: 计算成像学</li></ul></li></ul><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><ul><li>小孔成像<ul><li>针孔相机 Pinhole Camera<ul><li>无虚化</li><li>全部都是清晰的</li></ul></li></ul></li><li>Lens 透镜成像</li></ul><p>Shutter 快门，控制光进入相机</p><p>Sensor 传感器，Accumulates Irradiance During Exposure</p><ul><li>在曝光过程中的累积Irradiance</li></ul><p>Why Not Sensors Without Lenses</p><ul><li>Each sensor point would integrate light from all points on the object,so all pixel values would he similar<ul><li>所有东西都会糊掉</li></ul></li><li>the sensor records(记录) irradiance</li></ul><h2 id="Field-of-View-FOV-视场"><a href="#Field-of-View-FOV-视场" class="headerlink" title="Field of View(FOV 视场)"></a>Field of View(FOV 视场)</h2><p><img src="Games101/FOV.png" alt></p><script type="math/tex; mode=display">FOV = 2arctan(\frac{h}{2f})</script><ul><li>h: 传感器高度</li><li>f(focal length): 焦距，传感器与透镜的距离</li></ul><p>同样大小的传感器，焦距越大，视场越窄</p><p>同样焦距，传感器越大，视场越宽</p><p>同样视场，焦距和传感器等比</p><p>传感器Sensor和胶片Film不一定一样</p><ul><li>平时两者等价</li><li>在渲染器里面，Sensor收集irradiance，Film决定存成什么样的格式</li></ul><hr><p>通常以35mm(36 x 24mm)格式胶片为基准，通过定义焦距的方式来定义FOV：</p><ul><li>17mm is wide angle 104° 广角镜头</li><li>50mm is a “normal” lens 47°</li><li>200mm is telephoto lens 12°</li></ul><h2 id="Exposure"><a href="#Exposure" class="headerlink" title="Exposure"></a>Exposure</h2><ul><li><p>$H=T \cdot E$</p></li><li><p>Exposure = time x irradiance</p></li><li><p>Exposure time (T) </p><ul><li>Controlled by shutter</li></ul></li><li><p>Irradiance (E)</p><ul><li>Power of light falling on a unit area of sensor</li><li>Controlled by lens aperture（光圈） and focal length（焦距）</li></ul></li></ul><hr><h3 id="Exposure-Controls-in-photography"><a href="#Exposure-Controls-in-photography" class="headerlink" title="Exposure Controls in photography"></a>Exposure Controls in photography</h3><p>Aperture size 光圈大小</p><ul><li>Change the f-stop by opening / closing the aperture (if camera has iris control)</li><li>仿生学设计，模拟瞳孔</li><li>F-Number (F-Stop)</li></ul><p>Shutter speed 快门速度</p><ul><li>Change the duration the sensor pixels integrate light</li><li>越快，开放时间越短，相对越少光</li></ul><p>ISO gain 感光度</p><ul><li>后期处理,对接受到的光进行增益（比如乘以倍数）</li><li>Change the amplification (analog and/or digital) between sensor values and digital image values</li><li>硬件上 调节传感器灵敏度 或者 软件上 调整数字信号</li></ul><hr><h3 id="各个参数对expsoure的影像"><a href="#各个参数对expsoure的影像" class="headerlink" title="各个参数对expsoure的影像"></a>各个参数对expsoure的影像</h3><p><img src="Games101/Exposure_Control.png" alt></p><p>ISO:</p><ul><li>通过ISO增益光线的同时也会放大噪声</li><li>为什么会有噪声？<ul><li>光子数量少</li></ul></li><li>Film: trade sensitivity for grain</li><li>Digital: trade sensitivity for noise<ul><li>Multiply signal before analog-to-digital conversion</li><li>Linear effect (ISO 200 needs half the light as ISO 100) 线性</li></ul></li></ul><p>F-Number(F-Stop):Exposure Levels 曝光等级 - 光圈大小</p><ul><li>数字越小，光圈越大</li><li>Written as FN or F/N. N is the f-number.</li><li>Informal understanding: the inverse-diameter of a round aperture 简单地理解为直径的倒数</li></ul><p>Side Effect of Shutter Speed 快门速度过慢</p><ul><li>Motion blur: handshake, subject movement(运动模糊)</li><li>Doubling shutter time doubles motion blur</li><li>motion blur is not always bad! 表现快 or anti-aliasing~</li></ul><p>Rolling shutter: different parts of photo taken at different times</p><ul><li>物理快门并非瞬间打开，而是以某种方式“缓慢“打开的</li><li>会导致高速运动的物体的成像与预想不一致</li></ul><p>但是大光圈会有浅景深的效果，快门时间会导致运动模糊等效果，需要权衡</p><h2 id="Fast-and-Slow-Photography"><a href="#Fast-and-Slow-Photography" class="headerlink" title="Fast and Slow Photography"></a>Fast and Slow Photography</h2><p>High-Speed Photography 每秒极高帧率</p><ul><li>快门时间受限，</li><li>Normal exposure = extremely fast shutter speed x (large aperture and/or high ISO)</li></ul><p>Long-Exposure Photography 延时摄影</p><ul><li>快门时间很长</li><li>光圈变小</li></ul><h2 id="Thin-Lens-Approximation"><a href="#Thin-Lens-Approximation" class="headerlink" title="Thin Lens Approximation"></a>Thin Lens Approximation</h2><p><a href="http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html" target="_blank" rel="noopener">http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html</a></p><p>Real Lens Designs Are Highly Complex</p><ul><li>目前的相机都用透镜组来控制成像</li><li>真实的透镜并不那么理想：无法将光线聚于一点 Aberrations</li></ul><p>Ideal Thin Lens – Focal Point</p><ul><li>理想的透镜可将光聚于一点 - 焦点</li><li>(1) All parallel rays entering a lens pass through its focal point.</li><li>(2) All rays through a focal point will be in parallel after passing the lens.</li><li>(3) Focal length can be arbitrarily changed (in reality, yes! → 透镜组).</li></ul><hr><p>通过透镜组之间的相对位置变化来模拟焦距的改变</p><p>The (Gaussian) Thin Lens Equation(物距,向距和焦距之间的关系): </p><p><img src="Games101/Thin%20Lens%20Equation.png" alt></p><script type="math/tex; mode=display">\frac{1}{f}=\frac{1}{z_{i}}+\frac{1}{z_{o}}</script><ul><li>相似三角形证明</li></ul><h2 id="Defocus-Blur-散焦模糊"><a href="#Defocus-Blur-散焦模糊" class="headerlink" title="Defocus Blur(散焦模糊)"></a>Defocus Blur(散焦模糊)</h2><ul><li>产生散焦模糊的原因是因为物体不在Focal Plane上,这里假设在Focal Plane之后,导致成像在Image平面之前,由于光会一直传播,那物体上的一个点会在Sensor Plane上产生一个圆,产生弥散的现象.</li></ul><p><img src="Games101/CoC.png" alt></p><ul><li>各种距离固定情况下，CoC 与光圈大小成正比！<ul><li>大光圈会导致弥散圆更大</li></ul></li></ul><h2 id="Revisiting-F-Number"><a href="#Revisiting-F-Number" class="headerlink" title="Revisiting F-Number"></a>Revisiting F-Number</h2><ul><li>F-Number (a.k.a. F-Stop) ‘s Formal definition: The f-number of a lens is defined as <strong>the focal length divided by the diameter of the aperture </strong><ul><li>焦距/光圈直径</li></ul></li></ul><script type="math/tex; mode=display">C=A \frac{\left|z_{s}-z_{i}\right|}{z_{i}}=\frac{f}{N} \frac{\left|z_{s}-z_{i}\right|}{z_{i}}</script><ul><li>A是光圈直径</li></ul><h2 id="Ray-Tracing-Ideal-Thin-Lenses"><a href="#Ray-Tracing-Ideal-Thin-Lenses" class="headerlink" title="Ray Tracing Ideal Thin Lenses"></a>Ray Tracing Ideal Thin Lenses</h2><p>(One possible) Setup:</p><ul><li>Choose sensor size, lens focal length and aperture size</li><li>Choose depth of subject of interest $z_o$</li><li>Calculate corresponding depth of sensor $z_i$ from thin lens equation</li></ul><p>Rendering:</p><ul><li>For each pixel x’ on the sensor (actually, film (胶片))</li><li>Sample random points x’’ on lens plane</li><li>You know the ray passing through the lens will hit x’’’ (because x’’’ is in focus, consider virtual ray (x’, center of the lens))</li><li>Estimate radiance on ray x’’ -&gt; x’’’</li></ul><p><img src="Games101/Ray_Tracing_For_Defocus_Blur.png" alt></p><h2 id="Depth-of-Field-景深-成像清晰的一段范围"><a href="#Depth-of-Field-景深-成像清晰的一段范围" class="headerlink" title="Depth of Field(景深)[成像清晰的一段范围]"></a>Depth of Field(景深)[成像清晰的一段范围]</h2><p>Set circle of confusion as the maximum permissible blur spot on the image plane that will appear sharp under final viewing conditions</p><ul><li>将CoC设置为图像平面上的最大允许模糊点，这将在最终观看条件下显得锐利</li></ul><ul><li>depth range in a scene where the corresponding CoC is considered small enough.<ul><li>景深就是相应的COC被认为足够小的场景中的深度范围</li></ul></li></ul><p>首先，当CoC（Circle of Confusion）小到一定程度，认为是清晰的</p><p>$z_o$附近的一段距离内都可以看作清晰（CoC小到一定程度），关键是这段距离有多长。→景深</p><p>光圈越小，景深范围越大</p><p>焦距越大，景深范围越小</p><p><a href="http://graphics.stanford.edu/courses/cs178/applets/dof.html" target="_blank" rel="noopener">http://graphics.stanford.edu/courses/cs178/applets/dof.html</a></p><p><img src="Games101/DoF.png" alt></p><h2 id="Light-Field-Lumigraph"><a href="#Light-Field-Lumigraph" class="headerlink" title="Light Field / Lumigraph"></a>Light Field / Lumigraph</h2><h3 id="The-Plenoptic-Function-全光函数"><a href="#The-Plenoptic-Function-全光函数" class="headerlink" title="The Plenoptic Function(全光函数)"></a>The Plenoptic Function(全光函数)</h3><ul><li>定义:the set of all things that we can ever see</li></ul><hr><ul><li>Grayscale snapshot(灰度快照)：$\boldsymbol{P}(\theta, \phi)$  is intensity of light<ul><li>Seen from a single view point</li><li>At a single time</li><li>Averaged over the wavelengths of the visible spectrum → 没有具体的颜色</li></ul></li><li>Color snapshot：$\boldsymbol{P}(\theta, \phi, \lambda)$ is intensity of light<ul><li>Seen from a single view point</li><li>At a single time</li><li>As a function of wavelength 彩色</li></ul></li><li><p>Movie：</p><script type="math/tex; mode=display">\boldsymbol{P}(\theta, \phi, \lambda, t)</script><ul><li>is intensity of light</li><li>Seen from a single view point</li><li>Over time</li><li>As a function of wavelength 彩色</li></ul></li><li><p>Holographic movie 全息电影 or The Plenoptic Function</p><script type="math/tex; mode=display">\boldsymbol{P}\left(\theta, \phi, \lambda, t, V_X,V_Y,V_Z\right)</script><ul><li>is intensity of light</li><li>Seen from ANY viewpoint 任何位置看都可以</li><li>Over time</li><li>As a function of wavelength 彩色</li><li>Can reconstruct every possible view, at every moment, from every position, at every wavelength</li><li>Contains every photograph, every movie, everything that anyone has ever seen! it completely captures our visual reality!</li></ul></li></ul><h3 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h3><p>要实现这样一个函数，需要：空间中任意一点的全方向光线信息</p><p>Ray 光线：</p><script type="math/tex; mode=display">\boldsymbol{P}\left(\theta, \phi, V_X,V_Y,V_Z\right)</script><ul><li>5D: 3D position + 2D direction</li></ul><p>Ray Reuse</p><ul><li>4D: 2D direction + 2D position（表面为二维）</li><li>non-dispersive medium(non-dispersive medium)</li></ul><ul><li>要记录一个物体向四周展示的样子，只需要记录包围盒上表面各个点往各个方向发射的光线的信息：The surface of a cube holds all the radiance information due to the enclosed object. → 光场<ul><li>光场就是一个物体从任意方向看过去的radiance的场(场（field）在数学上是指一个向量到另一个向量或数的映射。).</li></ul></li></ul><p>光场记录的方式（四维）：</p><ul><li>2D position + 2D direction</li><li>2D position + 2D position：用两个面上两个点来定义光线的方向→2 plane parameterization (u,v) → (s,t)</li><li>固定(u,v), 所有的(s,t)组成一张image，显示从(u,v)点看到的外部世界的样子。<ul><li>Stanford camera array</li></ul></li><li>固定(s,t), 所有的(u,v)组成一张image，显示同一个点上从不同方向看过去的样子<ul><li>Integral Imaging (苍蝇的眼睛Lenslets)</li><li>从同一个点，将不同方向打过来的光线经过折射记录在不同的位置上</li><li>Spatially-multiplexed light field capture using lenslets: Impose fixed trade-off between spatial and angular resolution<ul><li>利用透镜捕获空间复用光场：在空间分辨率和角度分辨率之间施加固定的折衷</li></ul></li><li>将单单记录Irradiance变成了不同方向的Radiance</li></ul></li></ul><h2 id="Light-Field-Camera"><a href="#Light-Field-Camera" class="headerlink" title="Light Field Camera"></a>Light Field Camera</h2><ul><li><p>Lytro: founded by Prof. Ren Ng (UC Berkeley)</p><ul><li>Microlens design</li><li><p>Most significant function</p><ul><li><p>Computational Refocusing</p><p>(virtually changing focal length &amp; aperture size, etc. after taking the photo)</p></li></ul></li><li><p>Each pixel (irradiance) is now stored as a block of pixels (radiance)</p><ul><li>恢复：A simple case — always choose the pixel at the bottom of each block<ul><li>Then the central ones &amp; the top ones</li><li>Essentially “moving the camera around”</li></ul></li><li>Computational / digital refocusing<ul><li>Same idea: visually changing focal length, picking the refocused ray directions accordingly</li></ul></li></ul></li><li>The light field contains everything</li></ul></li><li>缺点<ul><li>Insufficient spatial resolution (same film used for both spatial and directional information) 分辨率不足</li><li>High cost (intricate designation of microlenses) 高成本、难设计</li><li>Computer Graphics is about trade-offs 调节更灵活↔分辨率更高</li></ul></li></ul><h1 id="physical-Basis-of-Color"><a href="#physical-Basis-of-Color" class="headerlink" title="physical Basis of Color"></a>physical Basis of Color</h1><ul><li><p>光=不同波长的电磁辐射（可见光光谱范围内400~700nm）</p></li><li><p>不同波长的光具有不同的折射率,产生不同的颜色</p></li><li><p>Spectrum 光谱：光线的能量在不同波长上的分布</p><ul><li>一条光线对应一种光谱.</li></ul></li><li><p>Spectral Power Distribution (SPD) 谱功率密度：描述一束光在所有波长的分布</p></li></ul><ul><li>线性：可叠加</li></ul><ul><li>什么是颜色<ul><li>是人的一种感知，不是光线的一种根本属性 <ul><li>a phenomenon of human perception; it is not a universal property of light<br>不同波长的光不是颜色</li><li>Different wavelengths of light are not “colors”</li></ul></li></ul></li></ul><h2 id="Biological-Basis-of-Color"><a href="#Biological-Basis-of-Color" class="headerlink" title="Biological Basis of Color"></a>Biological Basis of Color</h2><ul><li><p>人眼的简单介绍</p><ul><li>瞳孔=光圈，晶状体=透镜，视网膜=感光元件</li></ul></li><li><p>视网膜上的感光细胞 Retinal Photoreceptor Cells</p><ul><li>Rods：视杆细胞，棒状，很多，感知光的强度（而非波长）<ul><li>生成灰度图</li></ul></li><li>Cones：视锥细胞，锥形，较少，产生“颜色”的感觉<ul><li>Three types of cones S, M, and L (corresponding to peak response at short, medium, and long wavelengths), each with different spectral sensitivity</li><li>不同的人的视锥细胞分布大不一样 Fraction of Three Cone Cell Types Varies Widely</li></ul></li></ul></li></ul><h2 id="Tristimulus-Theory-of-Color-颜色的三色刺激理论"><a href="#Tristimulus-Theory-of-Color-颜色的三色刺激理论" class="headerlink" title="Tristimulus Theory of Color(颜色的三色刺激理论?)"></a>Tristimulus Theory of Color(颜色的三色刺激理论?)</h2><p>Spectral Response of Human Cone Cells</p><p>于是不同视锥细胞的信号强度=其对所有波长的光的响应的积分</p><script type="math/tex; mode=display">\begin{aligned} S &=\int r_{S}(\lambda) s(\lambda) d \lambda \\ M &=\int r_{M}(\lambda) s(\lambda) d \lambda \\ L &=\int r_{L}(\lambda) s(\lambda) d \lambda \end{aligned}</script><ul><li>$r(\lambda)$,不同视锥细胞对不同波长的光的响应曲线函数</li><li>$s(\lambda)$,在spd上的采样.</li></ul><p>于是有 任何一束光 → (S,M,L) → Color 的对应，人眼只知道(S,M,L)，不知道原来的光线分布（SPD）</p><h2 id="Metamerism-同色异谱"><a href="#Metamerism-同色异谱" class="headerlink" title="Metamerism(同色异谱)"></a>Metamerism(同色异谱)</h2><ul><li>同⾊异谱：不同的SPD → 同样的(S,M,L) = 同样的Color</li></ul><hr><p>Metamers are two different spectra (∞-dim) that project to the same (S,M,L) (3-dim) response.</p><ul><li>These will appear to have the same color to a human <ul><li>The existence of metamers is critical to color reproduction(Matching)</li></ul></li><li>Don’t have to reproduce the full spectrum of a real world scene</li><li>Example: A metamer can reproduce the perceived color of a real-world scene on a display with pixels of only three colors 通过显示器的三色光，也可以混合出现实中的种种色彩（虽然背后的光谱一般完全不一样）</li></ul><h2 id="Color-Reproductiom-Matching"><a href="#Color-Reproductiom-Matching" class="headerlink" title="Color Reproductiom / Matching"></a>Color Reproductiom / Matching</h2><ul><li>加色系统:所有颜色混合变白</li><li>减色系统:所有颜色混合变黑</li></ul><hr><p>计算机的成像系统是加色系统：</p><ul><li>给定一组主色（例如RGB）的光谱分布（S，M，L？）$s_{R}(\lambda), s_{G}(\lambda), s_{B}(\lambda)$</li><li>调整三种主色的强度并相加，得到一种颜色 $R s_{R}(\lambda)+G s_{G}(\lambda)+B s_{B}(\lambda)$</li><li>于是这种颜色就可以用(R,G,B)这三个标量表示。</li><li>于是也可以通过实验确定不同颜色的(R,G,B)表示-&gt;Additive Color Matching Experiment</li></ul><hr><ul><li>有些颜色怎么混合也混不出来，但是通过给原色加色，就可以混合出来，那么将最后混合的颜色中减去加上的颜色，就是对这种颜色的表示→系数会有负数！</li></ul><h3 id="CIE-RGB-Color-Matching-Experiment"><a href="#CIE-RGB-Color-Matching-Experiment" class="headerlink" title="CIE RGB Color Matching Experiment"></a>CIE RGB Color Matching Experiment</h3><ul><li>CIE：一个组织</li><li>主光 RGB 都是单一波长的光</li><li>测试光也都是单一波长的光</li></ul><hr><ul><li>颜色匹配函数  color matching functions <ul><li>描述了三种主光各自多少强度加起来会等于某单一波长的光的波长.<ul><li>Graph plots how much of each CIE RGB primary light must be combined to match a monochromatic light of wavelength given on x-axis</li><li>Careful: these are not response curves or spectra! </li></ul></li></ul></li></ul><h2 id="Color-Spaces-颜色空间"><a href="#Color-Spaces-颜色空间" class="headerlink" title="Color Spaces 颜色空间"></a>Color Spaces 颜色空间</h2><p>Standardized RGB (sRGB)</p><ul><li>makes a particular monitor RGB standard</li><li>other color devices simulate that monitor by calibration(校准)</li><li>widely adopted today</li><li>gamut (⾊域) is limited</li></ul><hr><p>同样定义了<strong>CIE XYZ color matching functions</strong>但是并非实验测得，而是人造，虚拟的</p><p><img src="Games101/CIE_XYZ_color.png" alt></p><p>Imaginary set of standard color primaries X, Y, Z</p><ul><li>Primary colors with these matching functions do not exist</li><li><strong>Y is luminance</strong> (brightness regardless of color) (表示亮度)</li></ul><p>为何如此设计？</p><ul><li>Matching functions are strictly positive 没有负数</li><li>Span all observable colors 覆盖所有可见光</li></ul><hr><ul><li>可视化CIE XYZ<ul><li>将(X,Y,Z) 归一化获得(x,y,z)（x + y + z = 1）, 然后对(x,y)做枚举，获得一张二维图像，表示在Y（亮度）固定的情况下，不同X，Z对应的颜色。<ul><li>since x + y + z = 1, we only need to record two of the three</li><li>usually choose x and y, leading to (x, y) coords at a specific brightness Y</li><li>The curved boundary: spectral locus</li><li>Any color inside is less pure, mixed</li></ul></li></ul></li></ul><hr><p>Gamut (⾊域)：the set of chromaticities generated by a set of color primaries(由一组原色生成的色度集)</p><ul><li>Different color spaces represent different ranges of colors</li><li>So they have different gamuts, i.e.</li><li>they cover different regions on the chromaticity diagram(色度图)</li></ul><h2 id="Perceptually-Organized-Color-Spaces-感官组织的色彩空间"><a href="#Perceptually-Organized-Color-Spaces-感官组织的色彩空间" class="headerlink" title="Perceptually Organized Color Spaces(感官组织的色彩空间)"></a>Perceptually Organized Color Spaces(感官组织的色彩空间)</h2><h3 id="HSV-Color-Space-Hue-Saturation-Value"><a href="#HSV-Color-Space-Hue-Saturation-Value" class="headerlink" title="HSV Color Space (Hue-Saturation-Value)"></a>HSV Color Space (Hue-Saturation-Value)</h3><p>Axes correspond to artistic characteristics of color </p><p>Widely used in a “color picker” 拾色器</p><p>Hue(⾊调):不同类型的颜色</p><ul><li>the “kind” of color, regardless of attributes</li><li>colorimetric correlate: dominant wavelength</li><li>artist’s correlate: the chosen pigment color</li></ul><p>Saturation (饱和度):颜色更接近白色还是单一颜色</p><ul><li>the “colorfulness”</li><li>colorimetric correlate: purity</li><li>artist’s correlate: fraction of paint from the colored tube</li></ul><p>Lightness (or value,Brightness) (亮度)</p><ul><li>the overall amount of light</li><li>colorimetric correlate: luminance</li><li>artist’s correlate: tints are lighter, shades are darker</li></ul><p><img src="Games101/HSV.png" alt></p><h2 id="CIELAB-Space-AKA-Lab"><a href="#CIELAB-Space-AKA-Lab" class="headerlink" title="CIELAB Space(AKA Lab)"></a>CIELAB Space(AKA L<em>a</em>b)</h2><p>A commonly used color space that strives for perceptual uniformity</p><ul><li>L* is lightness (brightness)</li><li>a<em> and b</em> are color-opponent pairs</li><li>a* is red-green 正方向：红色，负方向：绿色</li><li>b* is blue-yellow:正方向：黄色,负方向:蓝色</li></ul><p>基于互补色理论（Opponent Color Theory）</p><p>There’s a good neurological basis for the color space dimensions in CIE LAB</p><ul><li>the brain seems to encode color early on using three axes:</li><li>white — black, red — green, yellow — blue</li><li>the white — black axis is lightness; the others determine hue and saturation</li></ul><p>one piece of evidence: you can have a light green, a dark green, a yellow-green, or a blue-green, but you can’t have a reddish green (just doesn’t make sense) </p><p>• thus red is the opponent to green</p><p>another piece of evidence: afterimages (following slides)</p><hr><p>人眼是奇怪的</p><ul><li>视觉暂留</li><li>视错觉</li><li>颜色的相对性</li></ul><hr><h2 id="减色系统"><a href="#减色系统" class="headerlink" title="减色系统"></a>减色系统</h2><p>典型：CMYK: A Subtractive Color Space </p><p>墨水越混越黑</p><ul><li>Cyan, Magenta, Yellow, and Key</li><li>靛蓝、品红、黄色、黑色</li></ul><h2 id="还有什么没提"><a href="#还有什么没提" class="headerlink" title="还有什么没提"></a>还有什么没提</h2><ul><li>HDR</li><li>Gamma Correction矫正：Radiance → 颜色，因为显示器上颜色显示是非线性的，需要抵消</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 Rasterization</title>
      <link href="/2021/07/18/CG/Games/Rasterization/"/>
      <url>/2021/07/18/CG/Games/Rasterization/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学概述"><a href="#计算机图形学概述" class="headerlink" title="计算机图形学概述"></a>计算机图形学概述</h1><ul><li>Course Topics (mainly 4 parts)<ul><li>Rasterization</li><li>Curves and Meshes</li><li>Ray Tracing</li><li>Animation / Simulation</li></ul></li></ul><h1 id="向量与线性代数"><a href="#向量与线性代数" class="headerlink" title="向量与线性代数"></a>向量与线性代数</h1><h2 id="Dot-Product-in-Graphics"><a href="#Dot-Product-in-Graphics" class="headerlink" title="Dot Product in Graphics"></a>Dot Product in Graphics</h2><h3 id="Find-angle-between-two-vectors"><a href="#Find-angle-between-two-vectors" class="headerlink" title="Find angle between two vectors"></a>Find angle between two vectors</h3><ul><li>余弦定理</li></ul><h3 id="Find-projection-of-one-vector-on-another"><a href="#Find-projection-of-one-vector-on-another" class="headerlink" title="Find projection of one vector on another"></a>Find projection of one vector on another</h3><p><img src="Dot%20Product%20for%20Projection.png" alt></p><h3 id="Measure-how-close-two-directions-are"><a href="#Measure-how-close-two-directions-are" class="headerlink" title="Measure how close two directions are"></a>Measure how close two directions are</h3><ul><li>两个单位向量点乘越接近1则越接近，越接近-1则越远离</li></ul><h3 id="Decompose-a-vector"><a href="#Decompose-a-vector" class="headerlink" title="Decompose a vector"></a>Decompose a vector</h3><ul><li>利用点乘投影</li></ul><p><img src="Decompose%20a%20vector.png" alt></p><h3 id="Determine-forward-or-backward"><a href="#Determine-forward-or-backward" class="headerlink" title="Determine forward or backward"></a>Determine forward or backward</h3><ul><li>给定前向向量a,与向量b的点乘大于0则前向，小于0则后向</li></ul><p><img src="Games/../Games101/Determine%20forward%20or%20backward.png" alt></p><h2 id="Cross-Product-in-Graphics"><a href="#Cross-Product-in-Graphics" class="headerlink" title="Cross Product in Graphics"></a>Cross Product in Graphics</h2><h3 id="Determine-left-right"><a href="#Determine-left-right" class="headerlink" title="Determine left/right"></a>Determine left/right</h3><ul><li>对应给定坐标系如图右下角,判断向量a与向量b的关系,可通过$\vec{a} X \vec{b}$,根据右手螺旋定则（右手握拳，从b向量转到a向量，则大拇指朝z轴负方向.）,则向量a在向量b的右边.</li></ul><p><img src="Games101/Determine%20left%20or%20right.png" alt></p><ul><li>总结：任意两个向量a,b的叉乘<ul><li>结果为朝坐标轴正方向,a在b的左侧</li><li>结果为朝坐标轴负方向,a在b的右侧</li></ul></li></ul><h3 id="Determine-inside-outside"><a href="#Determine-inside-outside" class="headerlink" title="Determine inside/outside"></a>Determine inside/outside</h3><ul><li>如果某一点p在三角形所有边的同一侧,则该点在三角形内部,否则在外部.</li></ul><p><img src="Games101/Determine%20inside%20or%20outside.png" alt></p><h1 id="变换（二维与三维）"><a href="#变换（二维与三维）" class="headerlink" title="变换（二维与三维）"></a>变换（二维与三维）</h1><h2 id="2D变换"><a href="#2D变换" class="headerlink" title="2D变换"></a>2D变换</h2><ul><li><p>2D旋转变换矩阵（逆时针）</p><script type="math/tex; mode=display">\left[  \begin{matrix}      cos\theta & sin\theta \\      -sin\theta & cos\theta \\  \end{matrix}\right]</script></li><li><p>线性变换：缩放、对称、错切、旋转</p><blockquote><p>形式: $X^{‘} = Mx$,变换能写成<strong>同维</strong>矩阵</p></blockquote></li></ul><h3 id="Homogeneous-Coordinates（齐次坐标）"><a href="#Homogeneous-Coordinates（齐次坐标）" class="headerlink" title="Homogeneous Coordinates（齐次坐标）"></a>Homogeneous Coordinates（齐次坐标）</h3><ul><li>目的:让变换全部统一写成一个矩阵*一个向量</li></ul><h3 id="齐次坐标定义"><a href="#齐次坐标定义" class="headerlink" title="齐次坐标定义"></a>齐次坐标定义</h3><ul><li>2D point = $(x,y,1)^{T}$</li><li>2D vector = $(x,y,0)^{T}$</li></ul><h3 id="w坐标的意义"><a href="#w坐标的意义" class="headerlink" title="w坐标的意义"></a>w坐标的意义</h3><ul><li>vector + vector = vector;</li><li>point - point = vector;</li><li>point + vector = point;</li><li>point + point = 这两点的中点<blockquote><p>齐次坐标$(x,y,w)^{T}$代表的2D点为$(x/w,y/w,1)^{T},w!=1$</p></blockquote></li></ul><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><ul><li>仿射(Affine)变换 = 线性变换 + 平移</li></ul><h3 id="变换顺序"><a href="#变换顺序" class="headerlink" title="变换顺序"></a>变换顺序</h3><ul><li>变换顺序不存在交换律.先平移后旋转和先旋转在平移结果不一样</li><li>数学解释：矩阵乘法不存在交换律</li><li>几何解释：进行变换的时候坐标轴也会一起变换，旋转后的坐标轴和旋转前的坐标轴以及不一样.</li></ul><h3 id="变换的分解"><a href="#变换的分解" class="headerlink" title="变换的分解"></a>变换的分解</h3><ul><li>绕任一点P旋转:<ul><li>T(-c):将旋转点平移到原点.</li><li>R(alpha):旋转</li><li>T(c):平移回去</li></ul></li></ul><h3 id="仿射变换矩阵是先线性变换还剩先平移"><a href="#仿射变换矩阵是先线性变换还剩先平移" class="headerlink" title="仿射变换矩阵是先线性变换还剩先平移"></a>仿射变换矩阵是先线性变换还剩先平移</h3><ul><li>先线性变换再平移<blockquote><p>数学解释：可以利用分块矩阵的推导</p></blockquote></li></ul><h2 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h2><h3 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h3><ul><li>绕x,y,z轴旋转（右手系）</li></ul><p><img src="Games101/3D%20Rotation.png" alt></p><h4 id="为什么y的旋转矩阵是反的"><a href="#为什么y的旋转矩阵是反的" class="headerlink" title="为什么y的旋转矩阵是反的"></a>为什么y的旋转矩阵是反的</h4><ul><li>如果坐标轴按x,y,z顺序,则x与y叉乘得到z,y和z叉乘得到x，<strong>z和x叉乘得到y</strong></li><li><p>所以对于绕y轴旋绕与绕x轴与y轴是相反的.</p></li><li><p>roll,pitch,yaw.</p></li><li><p>Rodrigues’ Rotation Formula(罗德里格旋转公式)</p><blockquote><p>用于任意角度的旋转</p></blockquote></li></ul><h3 id="四元数和万向结死锁"><a href="#四元数和万向结死锁" class="headerlink" title="四元数和万向结死锁"></a>四元数和万向结死锁</h3><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><ul><li>待补</li></ul><h4 id="万向结死锁"><a href="#万向结死锁" class="headerlink" title="万向结死锁"></a>万向结死锁</h4><p><a href="https://zhuanlan.zhihu.com/p/42519819" target="_blank" rel="noopener">3D游戏世界里的万向节锁</a></p><ul><li>万向结死锁就是一个物体在一个3D世界里面随着旋转顺序和旋转角度的改变，导致物体只能在一个固定的平面旋转，无法旋转到你预想的角度。由于物体的旋转，物体的坐标轴方向也发生了改变，导致其中2条坐标轴发生了重合。当你围绕着重合的坐标轴旋转时，物体的旋转方向始终在一个平面上旋转。</li></ul><h2 id="Viewing（观测）变换"><a href="#Viewing（观测）变换" class="headerlink" title="Viewing（观测）变换"></a>Viewing（观测）变换</h2><h3 id="Model（模型）变形"><a href="#Model（模型）变形" class="headerlink" title="Model（模型）变形"></a>Model（模型）变形</h3><ul><li>将物体从局部坐标系变换到世界坐标系.</li></ul><h3 id="view（视图）变换"><a href="#view（视图）变换" class="headerlink" title="view（视图）变换"></a>view（视图）变换</h3><ul><li>how to define the camera<ul><li>Position $\vec{e}$</li><li>Look-at /gaze direction $\hat{g}$</li><li>Up direction $\vec{t}$(assuming perp. to loo-at)</li></ul></li></ul><p><img src="Games101/camera%20setup.png" alt></p><h4 id="相机摆放通用做法"><a href="#相机摆放通用做法" class="headerlink" title="相机摆放通用做法"></a>相机摆放通用做法</h4><pre><code>- The origin,up at Y,look at -Z- And transform the objects along with the camera</code></pre><ul><li>原因：为了方便之后的投影变换</li></ul><p><img src="Games101/transform%20camera.png" alt></p><ul><li>如何操作<ul><li>平移直接操作</li><li>旋转操作难以写出,先写逆变换，再算逆矩阵</li></ul></li></ul><h2 id="Proejection（投影）变换"><a href="#Proejection（投影）变换" class="headerlink" title="Proejection（投影）变换"></a>Proejection（投影）变换</h2><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><ul><li><p>特点； 不会近大远小</p></li><li><p>方法: We want to map a cuboid [l, r] x [b, t] x [f, n] (注意越远z值越小) to<br>the “canonical (正则、规范、标准)” cube $[-1, 1]^{3}$</p><ul><li>Center cuboid by translating</li><li>Scale into “canonical” cube</li></ul></li></ul><p><img src="Games101/orthographic%20projection.png" alt></p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><ul><li><p>特点：近大远小</p></li><li><p>方法：</p><ul><li>First “squish（挤压）” the frustum（椎体） into a cuboid (n -&gt; n, f -&gt; f) ($M_{persp-&gt;ortho}$)<ul><li>Do orthographic projection (Mortho, already known!)</li></ul></li></ul></li><li><p>透视投影变换矩阵</p><script type="math/tex; mode=display">M_{persp} = M_{ortho}M_{persp->ortho}</script></li><li><p>其中M_{persp-&gt;ortho}推导</p><ul><li>挤压规则<ul><li>近平面不变-(1)</li><li>远平面z值不变-(2)</li><li>远平面中点不变-(3)</li></ul></li><li>变换矩阵推导<ul><li>通过相似三角形求出变换矩阵第1,2,4行</li><li>通过(2),(3)解出第三行参数<blockquote><p>详细见ppt</p></blockquote></li></ul></li></ul></li></ul><script type="math/tex; mode=display">M_{persp->ortho} =\left[    \begin{matrix}        n & 0 & 0 & 0 \\        0 & n & 0 & 0 \\        0 & 0 & n+f & -nf \\        0 & 0 & 1 & 0 \\    \end{matrix}\right]</script><ul><li>其中n为近平面z值,f为远平面z值</li></ul><h4 id="进行挤压后在近平面和远平面之间的点会这么移动？"><a href="#进行挤压后在近平面和远平面之间的点会这么移动？" class="headerlink" title="进行挤压后在近平面和远平面之间的点会这么移动？"></a>进行挤压后在近平面和远平面之间的点会这么移动？</h4><ul><li>待补</li></ul><h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><h2 id="透视投影补充"><a href="#透视投影补充" class="headerlink" title="透视投影补充"></a>透视投影补充</h2><ul><li>fovY(field-of-view)(Y方向视角)</li><li>aspect ratio(宽高比)</li></ul><p><img src="Games101/frustum.png" alt></p><h2 id="viewport-transform"><a href="#viewport-transform" class="headerlink" title="viewport transform"></a>viewport transform</h2><ul><li><p>将经过投影变换转换到裁剪空间的坐标通过视口变换转换到屏幕坐标</p></li><li><p>方法：</p><ul><li>Irrelevant(忽略) to z</li><li>Transform in xy plane: $[-1, 1]^{2}$ to [0, width] x [0, height]</li></ul></li></ul><p><img src="Games101/viewport%20transform.png" alt></p><h2 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h2><ul><li>CRT(阴极射线管)<ul><li>隔行扫描</li></ul></li><li>LCD(液晶)</li><li>LED(发光二极管)</li><li>Electrophoretic Display(墨水瓶)</li></ul><h2 id="Triangle-Meshes"><a href="#Triangle-Meshes" class="headerlink" title="Triangle Meshes"></a>Triangle Meshes</h2><ul><li><p>优点</p><ul><li>最基本的多边形<ul><li>任何多边形都可以拆成多边形</li></ul></li><li>三角形内部一定是平面的</li><li>三角形内外定义明确</li><li>容易使用重心坐标插值</li></ul></li><li><p>Sampling(采样)</p><ul><li>连续函数离散化的过程</li></ul></li><li><p>如何光栅化,判断每个像素点是否在三角形内部</p><ul><li>遍历像素点</li><li>通过叉积判断点是否在三角形内部</li></ul></li><li><p>如果点在三角形边界上,要么不处理要么特殊处理</p></li><li>可以通过包围盒减少需要采样的像素</li></ul><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><ul><li>走样定义：High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal<br>Two frequencies that are indistinguishable at a given sampling rate are called “aliases”<blockquote><p>高频信号采样不足：样本错误地显示为来自低频信号,在给定的采样率下无法区分的两个频率称为走样</p></blockquote></li></ul><h3 id="Sampling-Artifacts（采样伪影）的表现"><a href="#Sampling-Artifacts（采样伪影）的表现" class="headerlink" title="Sampling Artifacts（采样伪影）的表现"></a>Sampling Artifacts（采样伪影）的表现</h3><ul><li>Jaggies(锯齿) - Sampling in space</li><li>Moire Patterns(摩尔纹) - understanding images</li><li>Wagon wheel effect(倒着转的轮子) - sampling in time</li></ul><hr><ul><li>产生走样的表现：Signals are changing too fast (high frequency), but sampled too slowly</li></ul><h3 id="频域"><a href="#频域" class="headerlink" title="频域"></a>频域</h3><ul><li>Fourier Transform(傅里叶变换)</li><li>spatial domain -&gt; 傅里叶变换 -&gt; frequency domain</li></ul><h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><ul><li>Filtering = Getting rid of certain frequency contents</li><li>一个图像可以通过傅里叶变换转换到频域空间<ul><li>高频信息是图像中的细节或边界<ul><li>高通滤波可以获取图像边界</li></ul></li><li>低筒信息是图像的其他信息<ul><li>低筒滤波获取的是缺少细节的图片</li></ul></li></ul></li></ul><hr><ul><li>Filtering = Convolution(=Averaging)</li><li>卷积定理<br>Convolution in the spatial domain is equal to multiplication in the frequency domain, and vice versa(反之亦然)<ul><li>卷积方法<ul><li>Option 1: <ul><li>Filter by convolution in the spatial domain </li></ul></li><li>Option 2:<ul><li>Transform to frequency domain (Fourier transform) </li><li>Multiply by Fourier transform of convolution kernel </li><li>Transform back to spatial domain (inverse Fourier)</li></ul></li></ul></li></ul></li><li>反过来,时域上的乘积在频域上是卷积</li></ul><hr><ul><li>Box Filter = Low Pass Filter</li></ul><script type="math/tex; mode=display">\frac{1}{9} *\left[    \begin{matrix}    1 & 1 & 1 \\    1 & 1 & 1 \\    1 & 1 & 1 \\    \end{matrix}\right]</script><ul><li>Wider Filter Kernel = Low Frequencies<blockquote><p>卷积核越大，低通部分越少(考虑边界情况,卷积核越大越模糊，越模糊，越只有低通部分)</p></blockquote></li></ul><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul><li>采样 = Reapeating Frequency Contents<ul><li>(c),(d)为在时域和频域上的冲击函数</li><li>在时域上采样相当于在频域上将原始波形按照在频域上的冲击函数进行复制</li></ul></li></ul><p><img src="Games101/Sampling%20=%20Repeating%20Frequency%20Contents.png" alt></p><ul><li>Aliasing = Mixed Frequency Contents<ul><li>在时域上采样越稀疏,在时域上复制的间隔就会越小,小到一定程度,波形之间就会产生堆叠,造成走样</li></ul></li></ul><p><img src="Games101/Aliasing%20=%20Mixed%20Frequency%20Contents.png" alt></p><h3 id="反走样的方法"><a href="#反走样的方法" class="headerlink" title="反走样的方法"></a>反走样的方法</h3><ul><li>Option 1: Increase sampling rate<ul><li>increasing the distance between replicas in the Fourier domain</li><li>Higher resolution displays, sensors, framebuffers</li><li>costly &amp; may need very high resolution</li></ul></li><li>Option 2: Antialiasing<ul><li>Filtering out high frequencies before sampling</li><li>于是就不会有重叠了：<ul><li>先Filter(滤波)再采样 -&gt; Antianliasing(反走样)<ul><li>对图像进行模糊就说对图像进行高通滤波</li></ul></li><li>先采样再Filter -&gt; Blurred Aliasing<ul><li>先采样后模糊（Filter）是不行的,波形重叠的情况下截断依然会有重叠</li></ul></li></ul></li></ul></li></ul><ul><li>补充:<blockquote><p>不论是高频的锯齿，还是低频的模糊，对于原信号来说，都是损失了信息。不同的是，不滤波直接采样的话对信息的提取是截断式的，它直接丢弃了原信号的一部分信息，所以你看上图右边图像信息出现了跳跃；而进行低通滤波是对原信号进行了加权平均，原信号携带的大部分信息多多少少以一定的比例存在于模糊后的信号中。信息多总比信息少好，此为什么要先滤波，后采样之原因之一。</p></blockquote></li></ul><blockquote><p><a href="https://www.zhihu.com/question/351820035" target="_blank" rel="noopener">渲染时采完样后为什么要移除高频部分后再采样，想问为什么要移除高频，直接重采样不就好了？</a></p></blockquote><p>作者：幽玄<br>链接：<a href="https://www.zhihu.com/question/351820035/answer/870609167" target="_blank" rel="noopener">https://www.zhihu.com/question/351820035/answer/870609167</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ul><li>Antialiasing = Limiting, then repeating<br><img src="Games101/Aliasing%20=%20Mixed%20Frequency%20Contents.png" alt></li></ul><h3 id="抗锯齿方法"><a href="#抗锯齿方法" class="headerlink" title="抗锯齿方法"></a>抗锯齿方法</h3><ul><li>最理想的状态：像素的颜色为该像素内各颜色的均值。但是连续域的平均值是很难求的，计算量巨大</li><li>SSAA<ul><li>比如4x ssaa,先渲染到4x的buffer上，然后每4个像素采样后取平均值，计算量和缓存都提高了4x.</li></ul></li><li>MSAA(做的是模糊这个操作,sample只是包含在了模糊操作内):<ul><li>在光栅化阶段,判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample）,在pixel shader着色阶段计算像素颜色的只计算一次,将该像素颜色定义为各个采样点颜色的均值.</li><li>可以通过只检测边缘、检测点复用等方法提高效率.</li><li>不兼容延迟渲染.</li></ul></li><li>FXAA(Fast Approximate AA)<ul><li>先得到带锯齿的图片，然后找到锯齿边界，替换带锯齿的边界.<ul><li>找到边界，换成没有锯齿的边界，（图像匹配）非常快</li><li>方法和采样无关，采样虽然有误，但是这种方法可以弥补</li></ul></li></ul></li><li>TAA(Temporal AA)<ul><li>时间抗锯齿<ul><li>静态场景，相邻两帧同一像素用不同的位置来sample</li><li>把MSAA的Sampling分布在时间上</li></ul></li></ul></li><li>超分辨率<ul><li>From low resolution to high resolution</li><li>Essentially still “not enough samples” problem 类似抗锯齿</li><li>DLSS (Deep Learning Super Sampling) </li></ul></li></ul><h2 id="可见性-遮挡"><a href="#可见性-遮挡" class="headerlink" title="可见性/遮挡"></a>可见性/遮挡</h2><ul><li>画家算法<blockquote><p>将画从最远的地方开始画</p></blockquote></li></ul><blockquote><p>不能解决场景中出现互相遮挡的情况</p></blockquote><p><img src="Games101/self%20occulsion.png" alt></p><h3 id="Z-Buffer"><a href="#Z-Buffer" class="headerlink" title="Z-Buffer"></a>Z-Buffer</h3><ul><li><p>方法:</p><ul><li>对每个像素多存一个深度</li><li>Frame buffer存储每个像素的颜色信息</li><li>depth buffer(z-buffer)存储每个颜色的深度信息<ul><li>z总是正的(距离原点的距离),越小越近,越大越远</li></ul></li></ul></li><li><p>复杂度：O(n) for n triangles 并不是排序，而是只要最值</p></li><li><p>需要保证三角形进入顺序和结果无关</p></li><li><p>无法处理透明物体</p></li><li><p>结合msaa的话z-buffer需要对每个采样点记录深度</p></li></ul><h1 id="shading-着色"><a href="#shading-着色" class="headerlink" title="shading(着色)"></a>shading(着色)</h1><ul><li>shading:The process of applying a material to an object.</li></ul><h2 id="Blinn-Phong-Reflectance-Model"><a href="#Blinn-Phong-Reflectance-Model" class="headerlink" title="Blinn-Phong Reflectance Model"></a>Blinn-Phong Reflectance Model</h2><ul><li>shading is Local<ul><li>shading  != shaow</li></ul></li></ul><h3 id="Diffuse-Reflection"><a href="#Diffuse-Reflection" class="headerlink" title="Diffuse Reflection"></a>Diffuse Reflection</h3><ul><li>Light is scattered uniformly in all directions<ul><li>Surface color is the same for all viewing directions</li></ul></li><li>Lambert’s cosine law:定义物体接受到多少光照</li></ul><script type="math/tex; mode=display">L_{d}=k_{d}\left(I / r^{2}\right) \max (0, \mathbf{n} \cdot \mathbf{l})</script><ul><li>$L_{d}$:漫反射</li><li>$k_{d}$:漫反射系数(定义该shading point的颜色(材质))</li><li>$I/r^{2}$:到达着色点的能量大小<ul><li>I:单位光照强度</li><li>r:距离</li></ul></li><li>$max(0,\mathbf{n} \cdot \mathbf{l})$:着色点接受的能量</li></ul><p><img src="Lambert_Shading.png" alt></p><hr><ul><li>漫反射跟view(观测方向)没有关系</li></ul><h3 id="Specular"><a href="#Specular" class="headerlink" title="Specular"></a>Specular</h3><ul><li><p>高光的强度取决于光线的反射方向和人的观察方法之间的距离.</p><ul><li>镜面反射方向越接近观察方向就越亮</li></ul></li><li><p>原始phong模型,计算镜面反射方向与观察方向的接近程度.</p><ul><li>缺点:计算复杂</li></ul></li><li>blinn-phong改进:比较半程向量和shaing poing的法线的接近程度.</li></ul><p><img src="specular.png" alt></p><ul><li>$L_{s}$:高光</li><li>$K_{s}$:高光系数:调节高光亮度.</li><li>$p$:光泽度:一般100~200，调节高光区域大小.</li></ul><h3 id="Ambient"><a href="#Ambient" class="headerlink" title="Ambient"></a>Ambient</h3><ul><li>Add constant color to account for disregarded illumination and fill in black shadows<blockquote><p>添加恒定的颜色以考虑忽略的照明并填充黑色阴影</p></blockquote></li><li>this is approximate / fake</li></ul><script type="math/tex; mode=display">L_{a} = k_{a}I_{a}</script><ul><li>$L_{a}$:环境光</li><li>$k_{a}$:环境光系数:环境光颜色</li><li>$I_{a}$:光照强度</li></ul><hr><ul><li>Blinn-Phong Reflection Model</li></ul><script type="math/tex; mode=display">    L = L_{a} + L_{d} + L_{s} \\     = K_{a}I_{a} + k_{d}(I/r^{2})max(0,\mathbf{n} \cdot \mathbf{l}) + k_{s}(I/r^{2})max(0,\mathbf{n} \cdot \mathbf{h})^{p})</script><h2 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h2><ul><li>Flat shading<ul><li>恒定着色指的是根据多边形上某个像素的光照情况对整个多边形着色。换句话说，假设多边形是由一种材质构成的。<ul><li>每一个三角面一个法线,对每一个面进行一次着色.</li></ul></li><li>缺点:对于平面组成的物体，这种方法是可行的;但是对于由曲面组成的物体，使用多边形近似，这种方法导致物体看起来是由多边形组成的。</li></ul></li><li>Gouraud(高洛德) shading<ul><li>Gouraud 着色是分别计算三角形三个顶点的光照情况，然后通过重心坐标插值的方式来决定三角形内每一点的颜色。</li><li>缺点:对高光的插值不好，因为高光往往比较锐利，如果原本该面上有高光，但是顶点处没有高光，那么插值后，这个面就没有高光。</li><li>优点：效果不错，计算量小</li></ul></li><li><p>Phong shading</p><ul><li>phong着色通过插值计算屏幕空间多边形每个像素的法线，然后根据法线来执行光照计算。</li><li>优点：它对每个像素执行光照计算，真实感比gouraud着色强些，提高了镜面反射效果。</li><li>缺点：计算量比较大<blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/362201067" target="_blank" rel="noopener">着色模型(频率)</a></p></blockquote></li></ul></li><li><p>几何足够复杂的情况下，用简单的Shading方法也可以达到好的效果</p></li><li>好的效果一般需要大的计算量</li></ul><h3 id="定义逐定点法线"><a href="#定义逐定点法线" class="headerlink" title="定义逐定点法线"></a>定义逐定点法线</h3><ul><li>相邻面的法线的加权平均(根据相邻三角面的面积进行加权)</li></ul><h3 id="定义逐像素法线"><a href="#定义逐像素法线" class="headerlink" title="定义逐像素法线"></a>定义逐像素法线</h3><ul><li>Barycentric interpolation<ul><li>求出的法线需要归一化</li></ul></li></ul><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p><img src="Games101/Graphics%20Pipline.png" alt></p><ul><li>Vertex Processing<ul><li>MVP Transform</li><li>Shading<ul><li>Gouraud(高洛德) shading</li></ul></li></ul></li><li>Rasterization Processing<ul><li>Sampling triangle converage</li></ul></li><li>Fragment Processing<ul><li>Z-Buffer Visiblity Tests</li><li>Shading<ul><li>Phong shading</li></ul></li></ul></li></ul><h2 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射(Texture Mapping)"></a>纹理映射(Texture Mapping)</h2><ul><li>三维物体表面都是二维的.</li><li>纹理：图，有弹性，可以映射到表面</li><li>UV和物体的对应关系是美工干的事情</li><li>UV坐标:在纹理上简历的坐标系<ul><li>$UV \in [0,1]^{2}$</li></ul></li></ul><ul><li>一张纹理可以使用多次</li><li>纹理本身设计可以无缝衔接→tilable<ul><li>一种方法：Wang Tiling</li></ul></li></ul><h2 id="Barycentric-Coordiantes-重心坐标"><a href="#Barycentric-Coordiantes-重心坐标" class="headerlink" title="Barycentric Coordiantes(重心坐标)"></a>Barycentric Coordiantes(重心坐标)</h2><ul><li>插值目的: obtain smoothly varying values across triangles.</li><li>插值内容: texture coordinates.colors,normal vectors,…</li><li>插值方法: 重心坐标</li></ul><script type="math/tex; mode=display">(x,y) =  \alpha * \mathbf{A} + \beta * \mathbf{B} + \gamma * \mathbf{C}</script><script type="math/tex; mode=display">\alpha + \beta + \gamma = 1</script><ul><li>如果三个系数都为非负 &lt;=&gt; (x,y)在三角形内部<ul><li>通过面积比求系数</li></ul></li></ul><p><img src="Games101/BarycentricCoordiante.png" alt></p><ul><li>重心坐标在投影变换后不一定一样.<ul><li>深度<br>  -在空间中做插值,不能在投影后进行插值.</li></ul></li></ul><h2 id="Appying-Textures"><a href="#Appying-Textures" class="headerlink" title="Appying Textures."></a>Appying Textures.</h2><pre><code class="lang-cpp">for each rasterized screen sample(x,y)//Usually a pixel&#39;s center.    (u,v) = evaluate texture coordinate at (x,y);//重心坐标    texcolor = texture.sample(u,v);    set sample&#39;s color to texcolor;//Usually the diffuse albedo Kd</code></pre><h2 id="Texture-Magnidication-what-if-the-texture-is-too-small"><a href="#Texture-Magnidication-what-if-the-texture-is-too-small" class="headerlink" title="Texture Magnidication - what if the texture is too small"></a>Texture Magnidication - what if the texture is too small</h2><ul><li><p>texel(纹理元素,纹素):A pixel on a texture(纹理上的像素)</p></li><li><p>多个pixel映射到了同一个texel</p></li><li>纹理查询时对于非整数uv坐标应该如何处理<ul><li>Nearest(找最近的点)</li><li>Bilinear(双线性插值)</li><li>Bicubic(双向三次插值)<ul><li>周围16个点做三次插值</li><li>运算量更大，结果更好</li></ul></li></ul></li></ul><h2 id="Texture-Magnification-What-if-the-texture-is-too-large"><a href="#Texture-Magnification-What-if-the-texture-is-too-large" class="headerlink" title="Texture Magnification - What if the texture is too large"></a>Texture Magnification - What if the texture is too large</h2><ul><li><p>一个pixel对应了多个texel → 采样频率不足导致 摩尔纹+锯齿（走样）</p></li><li><p>方法</p><ul><li>Supersampling<ul><li>太慢</li></ul></li><li>Just need to get the average value within a range<ul><li>Point Query vs. (Avg.) Range Query.<ul><li>点查询:线性插值.</li><li>范围查询:范围内平均查询</li></ul></li></ul></li></ul></li></ul><h3 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h3><ul><li>Allowing(fast,approx.,square(正方向))range queries<ul><li>方法:每一层把前一层高宽缩小一半.</li><li>生成Mipmap要多1/3的存储量</li></ul></li><li>计算Mipmap层级D<ul><li>通过待求像素和其邻居来求在纹理上纹素的范围.<ul><li>如果纹素为L*L为整数<ul><li>在$log_{2}L$层查询对应的某一个纹素.</li></ul></li><li>如果L不为整数.<ul><li>三线性插值.<ul><li>分别在floor(D)和ceil(D)上做Bilinear Interpolation取颜色值之后再插值</li></ul></li></ul></li></ul></li></ul></li></ul><hr><ul><li><p>overblur:mipmap的缺点,在远处模糊的太过损失细节.</p><ul><li>原因:方块查询,各种近似</li></ul></li><li><p>Anisotropic Filtering(各向异性过滤)</p><ul><li>各向异性:在各个方向表现不同</li><li>Ripmaps and summed area tables</li><li>Can look up axis-aligned rectangular zones</li><li>长/宽/长和宽 各减半</li><li>生成需要3倍的存储量</li><li>2(4,8,16)x:长宽压缩2(4,8,16)倍<ul><li>存储逐渐收敛到3倍</li></ul></li></ul></li><li>EWA filtering<ul><li>在形状分解为不同的圆形</li><li>利用多次查询求平均值的方法来处理不规则区域</li></ul></li></ul><h2 id="Application-of-Texture"><a href="#Application-of-Texture" class="headerlink" title="Application of Texture"></a>Application of Texture</h2><ul><li>In modern GPUs,texture = memory + range query(filtering)<ul><li>General method to bring data to fragment calculations</li></ul></li></ul><p>Many applications</p><ul><li>Environment lighting - Environment Map<ul><li>环境光贴图:记录场景中的环境光</li><li>例子：Utah Teapot<ul><li>经典：Stanford Bunny,Dragon，Cornell Box</li></ul></li><li>Spherical Environment Map<ul><li>球心：世界中心</li><li>一个问题：球面展开会发生拉伸,导致畸变</li><li>解决方法：Cube Map</li></ul></li><li>Cube Map：立方体表面，从球心到球面的投影向外<ul><li>扭曲更少，但是Need dir-&gt;face computation，计算量更大</li></ul></li></ul></li></ul><p>Many applications</p><ul><li><p>Store microgeometry(储存微几何)</p><ul><li><p>Textures can affect shading! → define height/normal → Bump / Normal Map</p><ul><li>两者类似，都可以以假乱真</li><li>改变表面的法线</li></ul></li><li><p>Bump Mapping 凹凸贴图</p><p>  Bump Mapping的Texture记录了高度移动</p><ul><li>不改变几何信息(不改变三角形信息)</li><li>逐像素扰动法线方向</li><li>高度 offset 相对变化，从而改变法线方向</li><li>计算法线方向：切线的垂直方向</li></ul></li><li><p>Displacement mapping 位移贴图</p><ul><li>输入相同（Texture与Bump Mapping可共用）</li><li>改变几何信息，对顶点做位移</li><li>相比上更逼真，要求模型足够细致，运算量更高</li><li>DirectX有Dynamic的插值法，对模型做插值，使得初始不用过于细致</li></ul></li><li>Procedural textures<ul><li>3D Procedural Noise + Solid Modeling<ul><li>定义空间中任意点的颜色</li><li>噪声+映射→</li><li>Perlin Noise</li></ul></li></ul></li><li>Provide Precomputed Shading<ul><li>Ambient occlusion texture map<ul><li>计算好的环境光遮蔽贴图</li><li>空间换时间</li></ul></li></ul></li><li>Solid modeling &amp; Volume rendering<ul><li>三维渲染</li></ul></li></ul></li></ul><h2 id="shaow-mapping"><a href="#shaow-mapping" class="headerlink" title="shaow mapping"></a>shaow mapping</h2><p>光栅化下对全局光线传输、阴影的处理十分麻烦。</p><ul><li>draw shadows using rasterization</li><li>An Image-space Algorithm<ul><li>不需要场景的几何信息</li><li>有走样现象</li><li>思想：the points NOT in shadow must be seen both by the light and by the camera</li></ul></li></ul><ul><li><p>步骤</p><ul><li>Pass1: Render from Light<ul><li>generate depth image from light source</li></ul></li><li>Pass2A: Render from Eye<ul><li>generate Standrad image(with depth) from eye</li></ul></li><li>Pass2B: Project to light<ul><li>Project visible points in eye view back to light source</li></ul></li></ul></li><li><p>问题：</p></li></ul><ul><li>走样、分辨率</li><li>数值精度问题<ul><li>Involves equality comparison of ﬂoating point depth values means issues of scale, bias, tolerance<ul><li>涉及浮点数深度值的相等性比较意味着比例、偏差、公差等问题</li></ul></li></ul></li><li>只能点光源、硬阴影</li><li>Quality depends on shaow map resolution</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101 Geometry</title>
      <link href="/2021/07/18/CG/Games/Geometry/"/>
      <url>/2021/07/18/CG/Games/Geometry/</url>
      
        <content type="html"><![CDATA[<h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h1><h2 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h2><ul><li>隐式表示<ul><li>形式: $f(x,y,z) = 0$</li><li>based on classifying points<ul><li>points satisfy some specified relationship</li></ul></li><li>pros<ul><li>compact description (e.g., a function)</li><li>certain queries easy (inside object, distance to surface)</li><li>good for ray-to-surface intersection (光线求交,more later)</li><li>for simple shapes, exact description / no sampling error</li><li>easy to handle changes in topology (e.g., fluid) </li></ul></li><li>cons<ul><li>Sampling can be hard</li><li>difficult to model complex shapes</li></ul></li><li>many implicit representations in graphics:<ul><li>Algebraic surface<ul><li>最直接的，用数学公式</li><li>不直观</li></ul></li><li>Constructive solid geomentry(CSG)<ul><li>基本形状的布尔操作组合成复杂形状</li><li>Combine implicit geometry via Boolean operations</li></ul></li><li>Distance Functions(距离场)<ul><li>giving minimum distance(could be signed distance) from anywhere to object.</li></ul></li><li>level set methods(s水平集)<ul><li>store a grid of values approximating function</li><li>例子：CT扫描,等高线</li></ul></li><li>fractals<ul><li>自相似</li><li>递归</li></ul></li></ul></li></ul></li><li>显式表示<ul><li>形式:$f:R^{2} \rightarrow R^{3}; (u,v) \rightarrow (x,y,z)$</li><li>All points are given directly or via parameter mapping</li><li>Pros<ul><li>Sampling is Easy</li></ul></li><li>cons<ul><li>Inside/outside Test Hard</li></ul></li><li>many explicit Representations in Graphics<ul><li>point cloud<ul><li>一堆点</li><li>可以表示任何几何</li><li>Useful for LARGE datasets (&gt;&gt;1 point/pixel)</li><li>Often converted into polygon mesh</li><li>Difficult to draw in undersampled regions(在采样不足的区域很难绘制)</li></ul></li><li>Polygon mesh<ul><li>store vertices &amp; polygons(often triangles or quads)</li><li>easier to do processing /simulation,adaptive sampling</li><li>more complicated data structures</li><li>perhaps most common representation in graphics<ul><li>obj文件</li></ul></li></ul></li><li>subdivision surfaces</li><li>NURBS</li><li>Bezier surfaces</li></ul></li></ul></li></ul><h2 id="曲线-Curve"><a href="#曲线-Curve" class="headerlink" title="曲线 Curve"></a>曲线 Curve</h2><h3 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves  贝塞尔曲线"></a>Bézier Curves  贝塞尔曲线</h3><p>一条由四个点（其实是任意≥3个点）定义的曲线：</p><ul><li>p0和p3定义起点和终点</li><li>p1和p2定义起点与终点的切线方向（与p0和p3一起）</li></ul><p>Evaluating Bézier Curves (de Casteljau Algorithm)</p><p>例子：(quadratic Bezier 二次贝塞尔曲线)</p><p><img src="Games101/quadratic%20Bezier.png" alt></p><p>计算方法：</p><p><img src="Games101/Bezier%20Formula.png" alt></p><p>一些性质：</p><p><img src="Games101/properties%20of%20bezier.png" alt></p><ul><li>仿射变换前后统一</li><li>凸包性质：形成的曲线一定在控制点形成的凸包内</li></ul><h2 id="piecewise-Bezier-Curves-分段贝塞尔曲线"><a href="#piecewise-Bezier-Curves-分段贝塞尔曲线" class="headerlink" title="piecewise Bezier Curves(分段贝塞尔曲线)"></a>piecewise Bezier Curves(分段贝塞尔曲线)</h2><ul><li><p>高阶bezier曲线不容易控制</p></li><li><p>instead,chain many low-order bezier curve</p><ul><li>Piecewise cubic bezier the most common technique</li></ul></li><li><p>连续性</p><ul><li>$C^{0}$连续:连接处值相等</li><li>$C^{1}$连续:连接处一阶可导</li><li>…</li><li>$G^{0}$连续:等于$C^{0}$</li><li>$G^{1}$连续:</li></ul></li></ul><h2 id="样条"><a href="#样条" class="headerlink" title="样条"></a>样条</h2><ul><li>Spline (样条)：a continuous curve constructed so as to pass through a given set of points and have a certain number of continuous derivatives. （a curve under control）<blockquote><p>样条曲线：一种连续曲线，构造成通过一组给定的点并具有一定数量的连续导数(控制下的曲线）</p></blockquote></li></ul><h3 id="B-splines"><a href="#B-splines" class="headerlink" title="B-splines"></a>B-splines</h3><ul><li>bezier曲线缺点<ul><li>一旦确定特征多边形，就确定了曲线的阶次</li><li>Bezier曲线拼接复杂（需要满足几何连续性，参数连续性等）</li><li>Bezier曲线不能作局部修改（只能整体修改）</li></ul></li></ul><ul><li>basis splines 基函数样条</li><li>满足局部性</li><li>可能是图形学里面最复杂的一部分</li><li>是贝塞尔曲线的超集</li></ul><ul><li>Further：B样条、NURBS（非均匀有理B样条）<a href="https://www.bilibili.com/video/av66548502" target="_blank" rel="noopener">https://www.bilibili.com/video/av66548502</a></li></ul><h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><ul><li>两个不同时间t（u,v）<ul><li>4x4个点，四条4个控制点的贝塞尔曲线，取同一时间（比如说u）获得四个控制点，取时间v，即获得最后的曲面上的点</li></ul></li></ul><h2 id="Mesh-Subdivision"><a href="#Mesh-Subdivision" class="headerlink" title="Mesh Subdivision"></a>Mesh Subdivision</h2><ul><li>Increase resolution</li></ul><ul><li>细分的应用场景：Displacement mapping 位移贴图 需要模型足够细致，于是需要细分（最好是动态细分）</li></ul><h3 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h3><p><strong>Loop是发明者名字，跟循环没关系</strong></p><ul><li>局限<br>  需要三角形Mesh</li></ul><p>步骤： </p><ol><li><p>create more triangles (vertices)</p><p> Split each triangle into four</p></li><li><p><strong>tune their positions （形状需要有改变）</strong></p><p> Assign new vertex positions according to weights</p><p> New / old vertices updated differently 新老点分别改变</p></li></ol><p><img src="Games101/Loop_Subdivision_1.png" alt></p><p><img src="Games101/Loop_Subdivision_2.png" alt></p><h3 id="Catmull-Clark-Subdivision-General-Mesh"><a href="#Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="Catmull-Clark Subdivision(General Mesh)"></a>Catmull-Clark Subdivision(General Mesh)</h3><ul><li><p>适用任何Mesh</p></li><li><p>方法</p></li></ul><p><img src="Games101/Catmull-clark_subdivision_1.png" alt></p><ul><li>顶点调整</li></ul><p><img src="Games101/Catmull-clark_subdivision_2.png" alt></p><h2 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h2><ul><li>Decrease resolution</li><li>Try to preserve shape/appearance</li></ul><hr><ul><li>Goal: reduce number of mesh elements while maintaining the overall shape</li></ul><h3 id="Edge-collapse-边坍缩"><a href="#Edge-collapse-边坍缩" class="headerlink" title="Edge collapse:边坍缩"></a>Edge collapse:边坍缩</h3><ul><li>哪些边合并？如何合并？<ul><li>Quadric Error Metrics（⼆次误差度量）放在二次误差之和最小的地方<ul><li>Quadric Error: new vertex should minimize its sum of square distance(L2 distance) to previously related triangle planes.</li></ul></li></ul></li></ul><p><img src="Games101/Edge_collapse_Error_Quadric.png" alt></p><p>Simplification via Quadric Error</p><ul><li>Garland &amp; Heckbert 1997.</li><li>iteratively collapse edge with smallest score</li><li>有问题，一条边的操作会影响其它边，需要更新<ul><li>数据结构：优先队列 or 堆</li></ul></li><li>贪心算法，非全局最优</li><li>可以有的放矢</li></ul><h2 id="Mesh-Regularizatiom"><a href="#Mesh-Regularizatiom" class="headerlink" title="Mesh Regularizatiom"></a>Mesh Regularizatiom</h2><ul><li>（不会出现特别奇怪的三角形）</li><li>Modify sample distribution to improve quality</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统整理</title>
      <link href="/2021/07/17/Recruitment/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/"/>
      <url>/2021/07/17/Recruitment/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><ul><li>什么是操作系统?<ul><li>操作系统用于控制和管理整个计算机系统的硬件与软件资源,合理地组织、调度计算机的工作与资源的分配,进而为用户和其他软件提供方便接口与环境的程序集合.</li><li>操作系统是计算机系统中最基本的系统软件.</li></ul></li></ul><h1 id="操作系统的主要目"><a href="#操作系统的主要目" class="headerlink" title="操作系统的主要目"></a>操作系统的主要目</h1><ul><li>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。</li><li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li><li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lesson 2 Triangle rasterization and back face culling</title>
      <link href="/2021/07/14/Project/TinyRenderer/Triangle_rasterization_and_back_face_culling/"/>
      <url>/2021/07/14/Project/TinyRenderer/Triangle_rasterization_and_back_face_culling/</url>
      
        <content type="html"><![CDATA[<ul><li>参考: <a href="https://zhuanlan.zhihu.com/p/348764466" target="_blank" rel="noopener">【十天自制软渲染器】DAY 03：画一个三角形（向量叉乘算法 &amp; 重心坐标算法）</a></li><li>参考: <a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling" target="_blank" rel="noopener">Lesson 2: Triangle rasterization and back face culling</a></li></ul><h1 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h1><h2 id="扫描线填充算法"><a href="#扫描线填充算法" class="headerlink" title="扫描线填充算法"></a>扫描线填充算法</h2><ul><li>扫描线通过水平方向遍历每一行的像素,将在三角形内的像素进行填充来得到三角形.</li></ul><hr><ul><li>Step1 : 将三角形的三个定点按照y方向进行排序.<ul><li>做完这步后,我们可以确定$t_{0}t_{2}$为最长边,而$t_{1}$将三角形在竖直方向划分为两部分<pre><code class="lang-cpp">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) if (t0.y&gt;t1.y) std::swap(t0, t1); if (t0.y&gt;t2.y) std::swap(t0, t2); if (t1.y&gt;t2.y) std::swap(t1, t2);</code></pre></li></ul></li><li>Step 2:如图对于红色的最长边我们可以一次画完,但对于绿色部分,我们只能拆成两个部分.</li></ul><p><img src="Triangle_rasterization_and_back_face_culling/3a5643f513.png" alt></p><ul><li>Step 3:每次通过计算水平上的三角形的两端点,并且填充内部像素来绘制三角形</li></ul><pre><code class="lang-cpp">void triangle(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color) {     //保证能构成三角形    if (t0.y==t1.y &amp;&amp; t0.y==t2.y) return;     //排序保证t0,t1,t2的相对位置    if (t0.y&gt;t1.y) std::swap(t0, t1);     if (t0.y&gt;t2.y) std::swap(t0, t2);     if (t1.y&gt;t2.y) std::swap(t1, t2);     //计算y方向的需遍历的像素个数    int total_height = t2.y-t0.y;     //扫描线填充法    for (int i=0; i&lt;total_height; i++) {         // 是否是上半部分或者没有上下两部分        bool second_half = i&gt;t1.y-t0.y || t1.y==t0.y;         int segment_height = second_half ? t2.y-t1.y : t1.y-t0.y;         float alpha = (float)i/total_height;         float beta  = (float)(i-(second_half ? t1.y-t0.y : 0))/segment_height; // be careful: with above conditions no division by zero here         Vec2i A =               t0 + (t2-t0)*alpha;         Vec2i B = second_half ? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta;         if (A.x&gt;B.x) std::swap(A, B);         for (int j=A.x; j&lt;=B.x; j++) {             image.set(j, t0.y+i, color); // attention, due to int casts t0.y+i != A.y         }     } }</code></pre><ul><li>扫描线法的缺点<ul><li>设计场景是单线程CPU</li></ul></li></ul><h2 id="包围盒和三角形内部判断"><a href="#包围盒和三角形内部判断" class="headerlink" title="包围盒和三角形内部判断"></a>包围盒和三角形内部判断</h2><h3 id="向量叉乘判断法"><a href="#向量叉乘判断法" class="headerlink" title="向量叉乘判断法"></a>向量叉乘判断法</h3><ul><li>具体见Games101笔记</li></ul><hr><ul><li>通过叉乘可以判断两个向量的相对位置.因此我们可以将待判断的某一点与三角形的三个定点连接.如图:</li><li>此时我们只需判断$\vec{AD}$和$\vec{AB}$,$\vec{BD}$和$\vec{BC}$,$\vec{CD}$和$\vec{CA}$中含有点D的向量的相对位置.</li><li>如果对应向量全在另外一条向量的同一层,则改点在三角形内部.否则在三角形外部.</li></ul><p><img src="Triangle_rasterization_and_back_face_culling/CTimes.jpg" alt></p><pre><code class="lang-cpp">// 利用叉乘判断是否在三角形内部Vec3i crossProduct(Vec2i *pts, Vec2i P) {    // 构建出三角形 ABC 三条边的向量    Vec2i AB(pts[1].x - pts[0].x, pts[1].y - pts[0].y);    Vec2i BC(pts[2].x - pts[1].x, pts[2].y - pts[1].y);    Vec2i CA(pts[0].x - pts[2].x, pts[0].y - pts[2].y);    // 三角形三个顶点和 P 链接形成的向量    Vec2i AP(P.x - pts[0].x, P.y - pts[0].y);    Vec2i BP(P.x - pts[1].x, P.y - pts[1].y);    Vec2i CP(P.x - pts[2].x, P.y - pts[2].y);    return Vec3i(AB^AP, BC^BP, CA^CP);}</code></pre><h3 id="重心坐标表示方法"><a href="#重心坐标表示方法" class="headerlink" title="重心坐标表示方法"></a>重心坐标表示方法</h3><ul><li><p>参考:<a href="https://zhuanlan.zhihu.com/p/348764466" target="_blank" rel="noopener">【十天自制软渲染器】DAY 03：画一个三角形（向量叉乘算法 &amp; 重心坐标算法）</a></p></li><li><p>设$\triangle ABC$平面内有一点P,则$\vec{AP}$可以使用$\vec{AB}$和$\vec{AC}$线性表示:</p><script type="math/tex; mode=display">\vec{AP} = u \vec{AB} + v \vec{AC} ... (1)</script></li><li><p>进行如下变换:</p></li></ul><script type="math/tex; mode=display">A - P = u ( A - B ) + v ( A - C ) ... (2)</script><script type="math/tex; mode=display">P = (1-u-v) A + uB + vC ... (3)</script><ul><li>u,v,(1-u-v)与点p的关系如下:<ul><li>当三个分量均大于 0 小于 1 时，P 位于三角形内部</li><li>有一个分量等于 0 时，P 在三角形边上</li><li>有两个变量等于 0 时，P 在某个顶点上</li><li>否则在三角形外</li></ul></li></ul><p><img src="Triangle_rasterization_and_back_face_culling/重心坐标推导过程.jpg" alt></p><ul><li>最后判断 [u/g v/g g/g]中的符号的范围,即可判断点p的位置.</li></ul><pre><code class="lang-cpp">Vec3f  barycentric(Vec2i *pts, Vec2i P) {     Vec2f AB(pts[1].x-pts[0].x,pts[1].y - pts[0].y);    Vec2f AC(pts[2].x-pts[0].x,pts[2].y - pts[0].y);    Vec2f PA(pts[0].x-P.x,pts[0].y-P.y);    Vec3f u =Vec3f(AB.x,AC.x,PA.x)^Vec3f(AB.y,AC.y,PA.y);    if(std::abs(u.z) &lt; 1)        return Vec3f(-1,1,1);    u.x /= u.z;    u.y /= u.z;    u.z /= u.z;    return Vec3f(1-u.x-u.y,u.x,u.y);}void triangle(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color) {     int minXVal = min(t0.x,min(t1.x,t2.x));    int maxXVal = max(t0.x,max(t1.x,t2.x));    int minYVal = min(t0.y,min(t1.y,t2.y));    int maxYVal = max(t0.y,max(t1.y,t2.y));    for(int i = minXVal; i &lt;= maxXVal; ++i)    {        for(int j = minYVal; j &lt;= maxYVal; ++j)        {            Vec2i pts[] = {t0,t1,t2};            Vec3f u = barycentric(pts,Vec2i(i,j));            if(u.x &gt; 0 &amp;&amp; u.y &gt; 0 &amp;&amp; u.z &gt; 0)            {                image.set(i,j,color);            }        }    }}</code></pre><h2 id="Flat-shading-render"><a href="#Flat-shading-render" class="headerlink" title="Flat shading render"></a>Flat shading render</h2><ul><li>详细看games101笔记</li></ul><ul><li>着色频率<ul><li>Flat shading<ul><li>逐多边形</li></ul></li><li>高洛德shading<ul><li>逐定点</li></ul></li><li>Phong shading<ul><li>逐像素</li></ul></li></ul></li><li>Blinn-Phong Reflectance Model<ul><li>Diffuse Reflection</li><li>Specular</li><li>Ambient<script type="math/tex; mode=display">L = L_{a} + L_{d} + L_{s} \\ = K_{a}I_{a} + k_{d}(I/r^{2})max(0,\mathbf{n} \cdot \mathbf{l}) + k_{s}(I/r^{2})max(0,\mathbf{n} \cdot \mathbf{h})^{p})</script></li></ul></li></ul><pre><code class="lang-cpp">int main(int argc, char** argv) {    if (2==argc) {        model = new Model(argv[1]);    } else {        model = new Model(&quot;obj/african_head.obj&quot;);    }    TGAImage image(width, height, TGAImage::RGB);    Vec3f light_dir(0,0,-1);    for (int i=0; i&lt;model-&gt;nfaces(); i++) {        std::vector&lt;int&gt; face = model-&gt;face(i);        Vec2i screen_coords[3];        Vec3f world_coords[3];        for (int j=0; j&lt;3; j++) {            Vec3f v = model-&gt;vert(face[j]);            screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);            world_coords[j]  = v;        }        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);        n.normalize();        float intensity = n*light_dir;        if (intensity&gt;0) {            triangle(screen_coords[0], screen_coords[1], screen_coords[2], image, TGAColor(intensity*255, intensity*255, intensity*255, 255));        }    }    image.flip_vertically(); // i want to have the origin at the left bottom corner of the image    image.write_tga_file(&quot;output.tga&quot;);    delete model;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tinyrenderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector深入探索</title>
      <link href="/2021/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/vector/"/>
      <url>/2021/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/vector/</url>
      
        <content type="html"><![CDATA[<ul><li>容器vector的代码如下:<ul><li>sizeof(vector<t>) = 12Byte(32位下3个4字节的指针)</t></li></ul></li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc= alloc&gt;class vector {public:    typedef T value_type;    typedef value_type* iterator;    typedef value_type&amp; reference;    typedef size_t size_type;protected:    iterator start;    iterator finish;    iterator end_of_storage;public:    iterator begin() { return start; }    iterator end() { return finish; }    size_type size() const { return size_type(end() - begin()); }    size_type capacity() const { return size_type(end_of_storage - begin()); }    bool empty() const { return begin() == end(); }    reference operator[](size_type n) { return *(begin() + n); }    reference front() { return *begin(); }    reference back() { return *(end() - 1); }};</code></pre><h1 id="vector的内存分布"><a href="#vector的内存分布" class="headerlink" title="vector的内存分布"></a>vector的内存分布</h1><p><img src="vector_memory.png" alt></p><ul><li>start指向第一个元素</li><li>finish指向最后一个元素的下一个元素</li><li>end_of_storage指向最大容量的内存块的下一个位置</li><li>size是当前大小</li><li>capacity是当前vector的最大容量</li></ul><hr><ul><li>vector对使用者是连续的,因此重载了[]运算符.</li><li>vector的实现也是连续的,因此使用指针类型做迭代器(即迭代器vector<t>::iterator的实际类型是原生指针T*).</t></li></ul><h1 id="vector的内存扩容"><a href="#vector的内存扩容" class="headerlink" title="vector的内存扩容"></a>vector的内存扩容</h1><ul><li>vector::push_back方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用insert_aux函数先扩容两倍再插入元素.<pre><code class="lang-cpp">void push_back(const T &amp;x) {  if (finish != end_of_storage) { // 尚有备用空间,则直接插入,并调整finish迭代器      construct(finish, x);        // 全局函数      ++finish;                    // 调整finsh位置  } else                             // 已无备用空间则调用 insert_aux 先扩容再插入元素      insert_aux(end(), x);}</code></pre></li><li><p>insert_aux被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</p><pre><code class="lang-cpp">template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_ux(iterator position, const T &amp;x) {   // 这里的重复检测工作是因为这个函数除了给push_back使用还会给其他函数使用(比如insert)  if (finish != end_of_storage) {     // 尚有备用空间,则将插入点后元素后移一位并插入元素       construct(finish, *(finish - 1));   // 以vector最后一个元素值为新节点的初值      ++finish;      T x_copy = x;      copy_backward(position, finish - 2, finish - 1);      *position = x_copy;  } else {      // 已无备用空间,则先扩容,再插入      const size_type old_size = size();      const size_type len = old_size != 0 ?: 2 * old_size:1;  // 分配原则:如果原大小为0,则分配1(个元素大小)                                                              //          如果原大小不为0,则分配原大小的2倍.                                                              //          前半段用来放置原数据,后半段准备用来放置新数据      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      try {          new_finish = uninitialized_copy(start, position, new_start);    // 拷贝插入点前的元素          construct(new_finish, x);                                       // 插入新元素并调整水位          ++new_finish;          new_finish = uninitialized_copy(position, finish, new_finish);  // 拷贝插入点后的元素,用于保证insert操作的准确性      }      catch (expection e) {          // 插入失败则回滚,释放内存并抛出错误          destroy(new_start, new_finish) :          data_allocator::deallocate(new_start, len);          throw;      }      // 释放原容器所占内存      destroy(begin(), end());      deallocate();      // 调整迭代器      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;  }};</code></pre></li></ul><h1 id="gcc2-9的vector源码"><a href="#gcc2-9的vector源码" class="headerlink" title="gcc2.9的vector源码"></a>gcc2.9的vector源码</h1><pre><code class="lang-cpp">//G++ 2.91.57，cygnus\cygwin-b20\include\g++\stl_vector.h 完整列表/* * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.  Hewlett-Packard Company makes no * representations about the suitability of this software for any * purpose.  It is provided &quot;as is&quot; without express or implied warranty. * * * Copyright (c) 1996 * Silicon Graphics Computer Systems, Inc. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.  Silicon Graphics makes no * representations about the suitability of this software for any * purpose.  It is provided &quot;as is&quot; without express or implied warranty. *//* NOTE: This is an internal header file, included by other STL headers. *   You should not attempt to use it directly. */#ifndef __SGI_STL_INTERNAL_VECTOR_H#define __SGI_STL_INTERNAL_VECTOR_H__STL_BEGIN_NAMESPACE #if defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)#pragma set woff 1174#endiftemplate &lt;class T, class Alloc = alloc&gt;  // 預設使用 alloc 為配置器class vector {public:  // 以下標示 (1),(2),(3),(4),(5)，代表 iterator_traits&lt;I&gt; 所服務的5個型別。  typedef T value_type;                // (1)  typedef value_type* pointer;             // (2)  typedef const value_type* const_pointer;  typedef const value_type* const_iterator;  typedef value_type&amp; reference;         // (3)  typedef const value_type&amp; const_reference;  typedef size_t size_type;  typedef ptrdiff_t difference_type;     // (4)  // 以下，由於vector 所維護的是一個連續線性空間，所以不論其元素型別為何，  // 原生指標都可以做為其迭代器而滿足所有需求。  typedef value_type* iterator;  /* 根據上述寫法，如果客端寫出這樣的碼：      vector&lt;Shape&gt;::iterator is;      is 的型別其實就是Shape*      而STL 內部運用 iterator_traits&lt;is&gt;::reference 時，獲得 Shape&amp;                 運用iterator_traits&lt;is&gt;::iterator_category 時，獲得                       random_access_iterator_tag        (5)      （此乃iterator_traits 針對原生指標的特化結果）  */#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  typedef reverse_iterator&lt;iterator&gt; reverse_iterator;#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */  typedef reverse_iterator&lt;const_iterator, value_type, const_reference,                            difference_type&gt;  const_reverse_iterator;  typedef reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;          reverse_iterator;#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */protected:  // 專屬之空間配置器，每次配置一個元素大小  typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  // vector採用簡單的線性連續空間。以兩個迭代器start和end分別指向頭尾，  // 並以迭代器end_of_storage指向容量尾端。容量可能比(尾-頭)還大，  // 多餘即備用空間。  iterator start;  iterator finish;  iterator end_of_storage;  void insert_aux(iterator position, const T&amp; x);  void deallocate() {    if (start)         data_allocator::deallocate(start, end_of_storage - start);  }  void fill_initialize(size_type n, const T&amp; value) {    start = allocate_and_fill(n, value);  // 配置空間並設初值    finish = start + n;                // 調整水位    end_of_storage = finish;             // 調整水位  }public:  iterator begin() { return start; }  const_iterator begin() const { return start; }  iterator end() { return finish; }  const_iterator end() const { return finish; }  reverse_iterator rbegin() { return reverse_iterator(end()); }  const_reverse_iterator rbegin() const {     return const_reverse_iterator(end());   }  reverse_iterator rend() { return reverse_iterator(begin()); }  const_reverse_iterator rend() const {     return const_reverse_iterator(begin());   }  size_type size() const { return size_type(end() - begin()); }  size_type max_size() const { return size_type(-1) / sizeof(T); }  size_type capacity() const { return size_type(end_of_storage - begin()); }  bool empty() const { return begin() == end(); }  reference operator[](size_type n) { return *(begin() + n); }  const_reference operator[](size_type n) const { return *(begin() + n); }  vector() : start(0), finish(0), end_of_storage(0) {}  // 以下建構式，允許指定大小 n 和初值 value  vector(size_type n, const T&amp; value) { fill_initialize(n, value); }  vector(int n, const T&amp; value) { fill_initialize(n, value); }  vector(long n, const T&amp; value) { fill_initialize(n, value); }  explicit vector(size_type n) { fill_initialize(n, T()); }  vector(const vector&lt;T, Alloc&gt;&amp; x) {    start = allocate_and_copy(x.end() - x.begin(), x.begin(), x.end());    finish = start + (x.end() - x.begin());    end_of_storage = finish;  }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  vector(InputIterator first, InputIterator last) :    start(0), finish(0), end_of_storage(0)  {    range_initialize(first, last, iterator_category(first));  }#else /* __STL_MEMBER_TEMPLATES */  vector(const_iterator first, const_iterator last) {    size_type n = 0;    distance(first, last, n);    start = allocate_and_copy(n, first, last);    finish = start + n;    end_of_storage = finish;  }#endif /* __STL_MEMBER_TEMPLATES */  ~vector() {     destroy(start, finish);  // 全域函式，建構/解構基本工具。    deallocate();   // 先前定義好的成員函式  }  vector&lt;T, Alloc&gt;&amp; operator=(const vector&lt;T, Alloc&gt;&amp; x);  void reserve(size_type n) {    if (capacity() &lt; n) {      const size_type old_size = size();      iterator tmp = allocate_and_copy(n, start, finish);      destroy(start, finish);      deallocate();      start = tmp;      finish = tmp + old_size;      end_of_storage = start + n;    }  }  // 取出第一個元素內容  reference front() { return *begin(); }  const_reference front() const { return *begin(); }  // 取出最後一個元素內容  reference back() { return *(end() - 1); }  const_reference back() const { return *(end() - 1); }  // 增加一個元素，做為最後元素  void push_back(const T&amp; x) {    if (finish != end_of_storage) {  // 還有備用空間      construct(finish, x);           // 直接在備用空間中建構元素。      ++finish;                              // 調整水位高度    }    else                                  // 已無備用空間      insert_aux(end(), x);              }  void swap(vector&lt;T, Alloc&gt;&amp; x) {    __STD::swap(start, x.start);    __STD::swap(finish, x.finish);    __STD::swap(end_of_storage, x.end_of_storage);  }  iterator insert(iterator position, const T&amp; x) {    size_type n = position - begin();    if (finish != end_of_storage &amp;&amp; position == end()) {      construct(finish, x);        // 全域函式，建構/解構基本工具。      ++finish;    }    else      insert_aux(position, x);    return begin() + n;  }  iterator insert(iterator position) { return insert(position, T()); }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  void insert(iterator position, InputIterator first, InputIterator last){    range_insert(position, first, last, iterator_category(first));  }#else /* __STL_MEMBER_TEMPLATES */  void insert(iterator position,              const_iterator first, const_iterator last);#endif /* __STL_MEMBER_TEMPLATES */  void insert (iterator pos, size_type n, const T&amp; x);  void insert (iterator pos, int n, const T&amp; x) {    insert(pos, (size_type) n, x);  }  void insert (iterator pos, long n, const T&amp; x) {    insert(pos, (size_type) n, x);  }  void pop_back() {    --finish;    destroy(finish);    // 全域函式，建構/解構基本工具。  }  // 將迭代器 position 所指之元素移除  iterator erase(iterator position) {    if (position + 1 != end()) // 如果 p 不是指向最後一個元素      // 將 p 之後的元素一一向前遞移      copy(position + 1, finish, position);     --finish;  // 調整水位    destroy(finish);    // 全域函式，建構/解構基本工具。    return position;  }  iterator erase(iterator first, iterator last) {    iterator i = copy(last, finish, first);    destroy(i, finish);    // 全域函式，建構/解構基本工具。    finish = finish - (last - first);    return first;  }  void resize(size_type new_size, const T&amp; x) {    if (new_size &lt; size())       erase(begin() + new_size, end());    else      insert(end(), new_size - size(), x);  }  void resize(size_type new_size) { resize(new_size, T()); }  // 清除全部元素。注意，並未釋放空間，以備可能未來還會新加入元素。  void clear() { erase(begin(), end()); }protected:  iterator allocate_and_fill(size_type n, const T&amp; x) {    iterator result = data_allocator::allocate(n); // 配置n個元素空間    __STL_TRY {      // 全域函式，記憶體低階工具，將result所指之未初始化空間設定初值為 x，n個      // 定義於 &lt;stl_uninitialized.h&gt;。      uninitialized_fill_n(result, n, x);        return result;    }     // &quot;commit or rollback&quot; 語意：若非全部成功，就一個不留。    __STL_UNWIND(data_allocator::deallocate(result, n));  }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class ForwardIterator&gt;  iterator allocate_and_copy(size_type n,                             ForwardIterator first, ForwardIterator last) {    iterator result = data_allocator::allocate(n);    __STL_TRY {      uninitialized_copy(first, last, result);      return result;    }    __STL_UNWIND(data_allocator::deallocate(result, n));  }#else /* __STL_MEMBER_TEMPLATES */  iterator allocate_and_copy(size_type n,                             const_iterator first, const_iterator last) {    iterator result = data_allocator::allocate(n);    __STL_TRY {      uninitialized_copy(first, last, result);      return result;    }    __STL_UNWIND(data_allocator::deallocate(result, n));  }#endif /* __STL_MEMBER_TEMPLATES */#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  void range_initialize(InputIterator first, InputIterator last,                        input_iterator_tag) {    for ( ; first != last; ++first)      push_back(*first);  }  // This function is only called by the constructor.  We have to worry  //  about resource leaks, but not about maintaining invariants.  template &lt;class ForwardIterator&gt;  void range_initialize(ForwardIterator first, ForwardIterator last,                        forward_iterator_tag) {    size_type n = 0;    distance(first, last, n);    start = allocate_and_copy(n, first, last);    finish = start + n;    end_of_storage = finish;  }  template &lt;class InputIterator&gt;  void range_insert(iterator pos,                    InputIterator first, InputIterator last,                    input_iterator_tag);  template &lt;class ForwardIterator&gt;  void range_insert(iterator pos,                    ForwardIterator first, ForwardIterator last,                    forward_iterator_tag);#endif /* __STL_MEMBER_TEMPLATES */};template &lt;class T, class Alloc&gt;inline bool operator==(const vector&lt;T, Alloc&gt;&amp; x, const vector&lt;T, Alloc&gt;&amp; y) {  return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());}template &lt;class T, class Alloc&gt;inline bool operator&lt;(const vector&lt;T, Alloc&gt;&amp; x, const vector&lt;T, Alloc&gt;&amp; y) {  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDERtemplate &lt;class T, class Alloc&gt;inline void swap(vector&lt;T, Alloc&gt;&amp; x, vector&lt;T, Alloc&gt;&amp; y) {  x.swap(y);}#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */template &lt;class T, class Alloc&gt;vector&lt;T, Alloc&gt;&amp; vector&lt;T, Alloc&gt;::operator=(const vector&lt;T, Alloc&gt;&amp; x) {  if (&amp;x != this) {    // 判斷是否 self-assignment    if (x.size() &gt; capacity()) {        // 如果標的物比我本身的容量還大      iterator tmp = allocate_and_copy(x.end() - x.begin(),                                       x.begin(), x.end());      destroy(start, finish);    // 把整個舊的vector 摧毀      deallocate();            // 釋放舊空間      start = tmp;                // 設定指向新空間      end_of_storage = start + (x.end() - x.begin());    }    else if (size() &gt;= x.size()) {    // 如果標的物大小 &lt;= 我的大小      iterator i = copy(x.begin(), x.end(), begin());      destroy(i, finish);    }    else {      copy(x.begin(), x.begin() + size(), start);      uninitialized_copy(x.begin() + size(), x.end(), finish);    }    finish = start + x.size();  }  return *this;}template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) {  if (finish != end_of_storage) {  // 還有備用空間    // 在備用空間起始處建構一個元素，並以vector 最後一個元素值為其初值。        construct(finish, *(finish - 1));    // 調整水位。    ++finish;    // 以下做啥用？    T x_copy = x;    copy_backward(position, finish - 2, finish - 1);    *position = x_copy;  }  else {        // 已無備用空間    const size_type old_size = size();    const size_type len = old_size != 0 ? 2 * old_size : 1;    // 以上配置原則：如果原大小為0，則配置 1（個元素大小）；    // 如果原大小不為0，則配置原大小的兩倍，    // 前半段用來放置原資料，後半段準備用來放置新資料。    iterator new_start = data_allocator::allocate(len); // 實際配置    iterator new_finish = new_start;    __STL_TRY {      // 將原vector 的內容拷貝到新 vector。      new_finish = uninitialized_copy(start, position, new_start);      // 為新元素設定初值x      construct(new_finish, x);      // 調整水位。      ++new_finish;      // 將原vector 的備用空間中的內容也忠實拷貝過來（啥用途？）      new_finish = uninitialized_copy(position, finish, new_finish);    }#       ifdef  __STL_USE_EXCEPTIONS     catch(...) {      // &quot;commit or rollback&quot; 語意：若非全部成功，就一個不留。      destroy(new_start, new_finish);       data_allocator::deallocate(new_start, len);      throw;    }#       endif /* __STL_USE_EXCEPTIONS */    // 解構並釋放原 vector    destroy(begin(), end());    deallocate();    // 調整迭代器，指向新vector    start = new_start;    finish = new_finish;    end_of_storage = new_start + len;  }}// 從 position 開始，安插 n 個元素，元素初值為 xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n, const T&amp; x) {  if (n != 0) { // 當 n != 0  才進行以下所有動作    if (size_type(end_of_storage - finish) &gt;= n) {       // 備用空間大於等於「新增元素個數」      T x_copy = x;      // 以下計算安插點之後的現有元素個數      const size_type elems_after = finish - position;          iterator old_finish = finish;      if (elems_after &gt; n) {         // 「安插點之後的現有元素個數」大於「新增元素個數」        uninitialized_copy(finish - n, finish, finish);        finish += n;    // 將vector 尾端標記後移        copy_backward(position, old_finish - n, old_finish);        fill(position, position + n, x_copy);    // 從安插點開始填入新值      }      else {            // 「安插點之後的現有元素個數」小於等於「新增元素個數」        uninitialized_fill_n(finish, n - elems_after, x_copy);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        fill(position, old_finish, x_copy);      }    }    else {      // 備用空間小於「新增元素個數」（那就必須配置額外的記憶體）      // 首先決定新長度：舊長度的兩倍，或舊長度+新增元素個數。      const size_type old_size = size();              const size_type len = old_size + max(old_size, n);      // 以下配置新的vector 空間      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        // 以下首先將舊vector 的安插點之前的元素複製到新空間。        new_finish = uninitialized_copy(start, position, new_start);        // 以下再將新增元素（初值皆為 n）填入新空間。        new_finish = uninitialized_fill_n(new_finish, n, x);        // 以下再將舊vector 的安插點之後的元素複製到新空間。        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef  __STL_USE_EXCEPTIONS       catch(...) {        // 如有異常發生，實現 &quot;commit or rollback&quot; semantics.        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      // 以下清除並釋放舊的 vector       destroy(start, finish);      deallocate();      // 以下調整水位標記      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#ifdef __STL_MEMBER_TEMPLATEStemplate &lt;class T, class Alloc&gt; template &lt;class InputIterator&gt;void vector&lt;T, Alloc&gt;::range_insert(iterator pos,                                    InputIterator first, InputIterator last,                                    input_iterator_tag) {  for ( ; first != last; ++first) {    pos = insert(pos, *first);    ++pos;  }}template &lt;class T, class Alloc&gt; template &lt;class ForwardIterator&gt;void vector&lt;T, Alloc&gt;::range_insert(iterator position,                                    ForwardIterator first,                                    ForwardIterator last,                                    forward_iterator_tag) {  if (first != last) {    size_type n = 0;    distance(first, last, n);    if (size_type(end_of_storage - finish) &gt;= n) {      const size_type elems_after = finish - position;      iterator old_finish = finish;      if (elems_after &gt; n) {        uninitialized_copy(finish - n, finish, finish);        finish += n;        copy_backward(position, old_finish - n, old_finish);        copy(first, last, position);      }      else {        ForwardIterator mid = first;        advance(mid, elems_after);        uninitialized_copy(mid, last, finish);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        copy(first, mid, position);      }    }    else {      const size_type old_size = size();      const size_type len = old_size + max(old_size, n);      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        new_finish = uninitialized_copy(start, position, new_start);        new_finish = uninitialized_copy(first, last, new_finish);        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef __STL_USE_EXCEPTIONS      catch(...) {        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      destroy(start, finish);      deallocate();      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#else /* __STL_MEMBER_TEMPLATES */template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position,                               const_iterator first,                               const_iterator last) {  if (first != last) {    size_type n = 0;    distance(first, last, n);    if (size_type(end_of_storage - finish) &gt;= n) {      const size_type elems_after = finish - position;      iterator old_finish = finish;      if (elems_after &gt; n) {        uninitialized_copy(finish - n, finish, finish);        finish += n;        copy_backward(position, old_finish - n, old_finish);        copy(first, last, position);      }      else {        uninitialized_copy(first + elems_after, last, finish);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        copy(first, first + elems_after, position);      }    }    else {      const size_type old_size = size();      const size_type len = old_size + max(old_size, n);      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        new_finish = uninitialized_copy(start, position, new_start);        new_finish = uninitialized_copy(first, last, new_finish);        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef __STL_USE_EXCEPTIONS      catch(...) {        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      destroy(start, finish);      deallocate();      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#endif /* __STL_MEMBER_TEMPLATES */#if defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)#pragma reset woff 1174#endif__STL_END_NAMESPACE #endif /* __SGI_STL_INTERNAL_VECTOR_H */// Local Variables:// mode:C++// End:</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/2021/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/array/"/>
      <url>/2021/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/array/</url>
      
        <content type="html"><![CDATA[<ul><li>将数组封装成容器array是为了使之与STL算法兼容,其内部实现只是简单封装了一下数组,甚至没有构造函数和析构函数.与vector一样使用原生指针做迭代器.</li></ul><pre><code class="lang-cpp">//没有构造函数,没有析构函数template&lt;typename _Tp, std::size_t _Nm&gt;struct array {    typedef _Tp value_type;    typedef _Tp *pointer;    typedef value_type *iterator;    value_type _M_instance[_Nm ? _Nm : 1];    // Support for zero-sized arrays mandatory    iterator begin() {        return iterator(&amp;_M_instance[0]);    }    iterator end() {        return iterator(&amp;_M_instance[_Nm]);    }};</code></pre><pre><code class="lang-cpp">arrar&lt;int,10&gt; myArray;auto ite = myArray.begin();// array&lt;int,10&gt;::iterator ite = ...ite += 3;cout&lt;&lt;*ite;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator_Traits</title>
      <link href="/2021/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/Iterator_Traits/"/>
      <url>/2021/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/Iterator_Traits/</url>
      
        <content type="html"><![CDATA[<h1 id="Iterator需要遵循的原则"><a href="#Iterator需要遵循的原则" class="headerlink" title="Iterator需要遵循的原则"></a>Iterator需要遵循的原则</h1><ul><li>iterator是算法和容器之间的桥梁</li><li>iterator必须有能力回答algorithm的提问<ul><li>总共有5中iterator的相关类型: iterator_category,value_type,pointer,reference,difference_type</li></ul></li></ul><h1 id="iterator的相关类型"><a href="#iterator的相关类型" class="headerlink" title="iterator的相关类型"></a>iterator的相关类型</h1><p><img src="iterator_associated_types.jpg" alt></p><h1 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h1><ul><li>迭代器的5个关联类型在类中均有定义,但是指针类型的关联类型需要根据指针类别进行确定,为了使STL算法同时兼容迭代器和一般指针,就在迭代器(指针)和算法之间加一个中间层萃取器(traits).</li><li>迭代器萃取器iterator_traits的目的就是能够兼容迭代器和一般指针,获取其5个关联类型:iterator_category、value_type、difference_type、pointer和pointer.<ul><li>就是这个traits能够分别它所获得的iterator是(1)class iterator T或是(2)native pointer to T.</li><li>利用parital specialization可达到目标.</li></ul></li></ul><p><img src="iterator_traits.jpg" alt></p><hr><ul><li>在实现上,iterator_traits类使用模板的偏特化(范围上),对于一般的迭代器类型,直接取迭代器内部定义的关联类型;对于指针和常量指针进行偏特化,指定关联类型的值.<br>```cpp<br>// 针对一般的迭代器类型,直接取迭代器内定义的关联类型<br>template<class i><br>struct iterator_traits {<br>  typedef typename I::iterator_category     iterator_category;<br>  typedef typename I::value_type             value_type;<br>  typedef typename I::difference_type     difference_type;<br>  typedef typename I::pointer             pointer;<br>  typedef typename I::reference             reference;<br>};</class></li></ul><p>// 针对指针类型进行特化,指定关联类型的值<br>template<class t><br>struct iterator_traits<t *> {<br>    typedef random_access_iterator_tag         iterator_category;<br>    typedef T                                 value_type;<br>    typedef ptrdiff_t                         difference_type;<br>    typedef T*                                pointer;<br>    typedef T&amp;                                reference;<br>};</t></class></p><p>// 针对指针常量类型进行特化,指定关联类型的值<br>template<class t><br>struct iterator_traits<const t *> {<br>    typedef random_access_iterator_tag         iterator_category;<br>    typedef T                                 value_type;        // value_tye被用于声明变量,而声明一个无法被赋值的变量没什么用,<br>                                                            // 所以iterator的value type不应该加上const<br>    typedef ptrdiff_t                         difference_type;<br>    typedef const T*                        pointer;<br>    typedef const T&amp;                        reference;<br>};</const></class></p><pre><code>* 想要在算法内获取关联类型的值,只需像下面这样写:```cpptemplate&lt;typename T&gt;void algorithm(...) {    typename iterator_traits&lt;I&gt;::value_type v1;}</code></pre><h1 id="各种各样的traits"><a href="#各种各样的traits" class="headerlink" title="各种各样的traits"></a>各种各样的traits</h1><ul><li>type traits</li><li>iterator traits</li><li>char traits</li><li>allocator traits</li><li>pointer traits</li><li>array traits</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2021/07/05/Algorithm/String/"/>
      <url>/2021/07/05/Algorithm/String/</url>
      
        <content type="html"><![CDATA[<h1 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h1><h2 id="BF-暴力"><a href="#BF-暴力" class="headerlink" title="BF(暴力)"></a>BF(暴力)</h2><pre><code class="lang-cpp">* 遍历所有的字符串可能性,然后与模式串进行比较.class Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size();        int n = needle.size();        if(n==0) return 0;        for(int i = 0; i &lt;= m-n; ++i)        {            int j;            for(j = 0; j &lt; n; ++j)            {                if(haystack[i+j] != needle[j])                    break;            }            if(j == n) return i;        }        return -1;    }};</code></pre><ul><li>时间复杂度:O(MN)<ul><li>最坏情况:每次与模式串最后一个关键字不同,导致遍历了所有字符串可能性.</li></ul></li><li>空间复杂地:O(1)</li></ul><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li>参考:<a href="https://www.zhihu.com/question/21923021/answer/1032665486" target="_blank" rel="noopener">如何更好地理解和掌握 KMP 算法?</a></li><li>参考:<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/" target="_blank" rel="noopener">宫水三叶】简单题学 KMP 算法</a></li><li>王道数据结构</li></ul><hr><ul><li>KMP的关键点<ul><li>求next数组<ul><li>next[i]表示匹配串中前i个字符中前缀和后缀字符相同的最大个数.<ul><li>普通的next数组的方法为n^2</li><li>利用next[i-1]的值可以递推出next[i]的值<ul><li>如果next[i-1] = k,则子串中前k个字符和后k个字符相同,只需比较s[k]和s[i]的大小<ul><li>如果 s[k] == s[i],则next[i] = next[i-1]+1;</li><li>如果 s[k] != s[i],这时候需要看前缀的不匹配位置前的子串,通过将s[next[k-1]]和s[i]比较.不断重复该操作直到为0或者达到匹配.<ul><li>这一步相当于拿needle的前缀去匹配后缀,得到前缀和后缀中的最大子前缀和后缀相同的大小.(具体可以看王道)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>匹配过程和求next数组类似</li></ul></li></ul><pre><code class="lang-cpp">class Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size();        int n = needle.size();        if(n==0) return 0;        // 生成next数组        // 该next数组为非优化的,next[i]表示前i个字符的最大前后缀个数        vector&lt;int&gt; next(n,0);        next[0] = 0;        int j = 0;        for(int i = 1; i &lt; n; ++i)        {            while(j &gt; 0 &amp;&amp; needle[i] != needle[j])            {                //这一步相当于拿needle的前缀去匹配后缀,得到前缀和后缀中的最大子前缀和后缀相同的大小.                j = next[j-1];            }            if(needle[i] == needle[j])                ++j;            next[i] = j;        }        j = 0;        for(int i = 0; i &lt; m; ++i)        {            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j])                j = next[j-1];            if(haystack[i] == needle[j])                ++j;            if(j == n)                return i - n+1;        }        return -1;        return 0;    }};</code></pre><h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><ul><li>待补</li></ul><h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><ul><li>待补</li></ul><h2 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h2><ul><li>待补</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2021/07/04/Algorithm/Search/"/>
      <url>/2021/07/04/Algorithm/Search/</url>
      
        <content type="html"><![CDATA[<h1 id="线性结构查找"><a href="#线性结构查找" class="headerlink" title="线性结构查找"></a>线性结构查找</h1><ul><li>顺序查找</li><li>折半查找</li><li>分块查找</li></ul><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>多级存储系统中使用B-树,可针对外部查找，大大减少I/O次数<ul><li>对于普通的AVL树来说，在1G个记录中进行查找,平均需要30次I/O操作,并且每次只能读取一个关键码</li><li>对于b树来说，充分利用外存对<strong>批量访问</strong>的高效支持，将此特点转换为有点<ul><li>每下降一层，都以超级节点为单位，读入一组关键码</li></ul></li></ul></li></ul><h2 id="超级结点"><a href="#超级结点" class="headerlink" title="超级结点"></a>超级结点</h2><ul><li>B树的超级结点等价于二叉搜索树中经过适当合并得到的结点</li></ul><p><img src="B_Tree_SuperNode.jpg" alt></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>所谓<code>m</code>阶b树,即m路平衡搜索树(m &gt;=2)</li><li>外部节点的深度统一相等,所有叶结点的深度统一相等<ul><li>外部节点用于沟通不同级别的存储介质</li></ul></li><li>树高<code>h</code> = 外部节点的深度</li><li>对于内部节点的最大值<ul><li>不超过<code>m-1</code>个关键码</li><li>不超过<code>m</code>个分支</li></ul></li><li>对于内部节点的最小值<ul><li>树根<code>m &gt;= 2</code></li><li>其余<code>m &gt;= ceil(m/2)</code></li></ul></li></ul><hr><ul><li>也可以称<code>m阶</code>b树为<code>(ceil(m/2),m)-树</code></li></ul><p><img src="B_Tree_Structure.jpg" alt></p><h2 id="b树的高度"><a href="#b树的高度" class="headerlink" title="b树的高度"></a>b树的高度</h2><ul><li>b树的高度对应<code>磁盘的存取次数</code>,对于包含n个关键码、高度为h、阶数为m的b树<script type="math/tex; mode=display">h_{max} >= log_{m}{(n+1)}</script><script type="math/tex; mode=display">h_{max} <= log_{ceil(m/2)}{((n+1)/2)}+1</script></li></ul><h2 id="b树的插入"><a href="#b树的插入" class="headerlink" title="b树的插入"></a>b树的插入</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li>通过查找算法,找到失败位置,这个失败位置就是插入位置<h3 id="插入-2种情况"><a href="#插入-2种情况" class="headerlink" title="插入(2种情况)"></a>插入(2种情况)</h3><h4 id="普通插入"><a href="#普通插入" class="headerlink" title="普通插入"></a>普通插入</h4></li><li>插入后关键码的个数 &lt; m 则直接插入<h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4></li><li>插入后关键码的个数 = m 则需要进行分裂.</li><li>进行分裂时,取中间的结点插入到父节点,然后产生两个新的超级结点</li><li>然后一次检查父节点,如果分裂超过传到到树根，则b树高度增加1</li></ul><p><img src="B_Tree_Insert.jpg" alt></p><h3 id="删除（3种情况）"><a href="#删除（3种情况）" class="headerlink" title="删除（3种情况）"></a>删除（3种情况）</h3><h4 id="普通删除"><a href="#普通删除" class="headerlink" title="普通删除"></a>普通删除</h4><ul><li>如果删除相应关键字后，超级结点的关键码个数<code>&gt;= ceil(m/2) - 1</code>,则直接删除该关键字<h4 id="兄弟够借（旋转）"><a href="#兄弟够借（旋转）" class="headerlink" title="兄弟够借（旋转）"></a>兄弟够借（旋转）</h4></li><li>如果删除相应关键字后，超级结点的关键码个数<code>&lt; ceil(m/2) - 1</code>,且此时他的左右兄弟结点中的关键码个数<code>&gt;= ceil(m/2)</code>.</li><li>此时采用旋转，父节点向下溢结点借出结点,父节点向下溢的兄弟结点要一个结点,注意要保证中序遍历的顺序性</li></ul><p><img src="B_Tree_Delete_2.jpg" alt></p><h4 id="兄弟不够借（合并）"><a href="#兄弟不够借（合并）" class="headerlink" title="兄弟不够借（合并）"></a>兄弟不够借（合并）</h4><ul><li>如果删除相应关键字后，超级结点的关键码个数<code>&lt; ceil(m/2) - 1</code>,且此时他的左右兄弟结点中的关键码个数<code>= ceil(m/2)-1</code>.</li><li>此时采用合并操作,对于合并操作父节点会减少一个关键码，因此需要依次检查相应结点,如果传导到树根则b树高度减1</li></ul><p><img src="B_Tree_Delete_3.jpg" alt></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树需要满足的条件"><a href="#B-树需要满足的条件" class="headerlink" title="B+树需要满足的条件"></a>B+树需要满足的条件</h2><ul><li>每个分支最多m根子树(孩子结点)</li><li>根结点最少2根子树,分支结点至少<code>ceil(m/2)</code>根子树</li><li>结点的子树个数与关键字个数<code>相等</code></li><li>所有叶结点包含所有关键字及对应记录的指针,按大小排序且相互链接起来</li><li>分支结点仅保存子节点中<code>关键字的最大值</code>及<code>指向子节点的指针</code></li></ul><h2 id="m阶b树和b-树的区别"><a href="#m阶b树和b-树的区别" class="headerlink" title="m阶b树和b+树的区别"></a>m阶b树和b+树的区别</h2><ul><li>关键码和子树的关系<ul><li>B+:n个关键码对应n根子树</li><li>B-:n个关键码对应n+1根子树</li></ul></li><li>关键字范围<ul><li>B+: ceil(m/2) &lt;= n &lt;= m ( 根 : 1 &lt;= n &lt;= m)</li><li>B-: ceil(m/2)- &lt;= n &lt;= m-1 ( 根 : 1 &lt;= n &lt;= m-1)</li></ul></li><li>结点存储信息<ul><li>B+ : 叶结点包含所有信息,分支结点仅起索引作用</li><li>B- : 每个结点都保存信息</li></ul></li><li>叶结点关键字<ul><li>B+ : 叶结点包含所有关键字</li><li>B- : 结点关键字不重复</li></ul></li></ul><p><img src="B_Plus_Tree_Structure.jpg" alt></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote><p>参考:学堂在线,邓俊辉,数据结构</p><h2 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h2><ul><li>持久性(一致性)结构：支持对历史版本的访问<br>T.serach(ver(版本号),key)</li></ul></blockquote><ul><li>蛮力实现:每个版本独立保存,各版本入口自成一个搜索结构.</li></ul><p><img src="Persistent_Structure_1.jpg" alt></p><blockquote><p>单次操作o(logh + logn),累计o(hn)时间和空间,累计空间复杂度是o(hn)是因为每次都要保存前一个版本的结点 // h = |history|</p></blockquote><ul><li>O(1)重构:对树形结构的拓扑而言,相邻版本之间的差异不能超过O(1)<ul><li>任何一次动态操作引发的结构变化量不超过O(1)<h2 id="红黑树概念"><a href="#红黑树概念" class="headerlink" title="红黑树概念"></a>红黑树概念</h2></li></ul></li><li>红黑树是由红、黑两类结点组成的BST(统一增设外部结点NULL,使之成为真二叉树)<blockquote><p>真二叉树:所有节点的度都要么为0，要么为2。</p><ul><li>1.树根:必为黑色</li><li>2.外部结点:均为黑色</li><li>3.其余结点:若为红、则只能有黑孩子(当前结点为红,其父亲结点和孩子结点都为黑)</li><li>4.外部结点到根:途中黑结点数据相等(黑深度)</li></ul></blockquote></li></ul><hr><ul><li>性质3.作用:红色结点经过提升变换后(将黑色结点提高到与黑父亲同一高度的位置,类似b树)之后,所有叶子结点都在同一层.<ul><li>提升后的红黑树就是4阶b树(2,4-树)</li></ul></li></ul><p><img src="RBTree_BTree.jpg" alt></p><h2 id="红黑树操作接口"><a href="#红黑树操作接口" class="headerlink" title="红黑树操作接口"></a>红黑树操作接口</h2><pre><code class="lang-cpp">template &lt;typename T&gt; calss RedBlack : public BST&lt;T&gt;{public:    //BST::Serach()的其余接口都可直接沿用    BinNodePosi(T) insert(const T&amp; e);//插入    bool remove(const T&amp; e );//删除protected:    void solveDoubleRed(BiNodePosi(T) x);//双红修正    void solveDoubleBlack(BiNodePosi(T) x);//双黑修正    int updateHeight(BinNOdePosi(T) x);//更新结点x的高度(黑高度)};</code></pre><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><pre><code class="lang-md">* 现拟插入关键码e //T中不含e* 按照BST的常规算法,插入之 // x = insert(e)必为末端结点    * 不妨设x的父亲p = x-&gt;parent存在 //否则,即平凡的首次插入* 将x染红(除非它是根)    * 此时条件1,2,4必然满足</code></pre><h3 id="情况1-插入结点为根结点"><a href="#情况1-插入结点为根结点" class="headerlink" title="情况1:插入结点为根结点"></a>情况1:插入结点为根结点</h3><ul><li>此时染为黑色</li></ul><h3 id="情况2-插入结点不为根结点"><a href="#情况2-插入结点不为根结点" class="headerlink" title="情况2:插入结点不为根结点"></a>情况2:插入结点不为根结点</h3><h4 id="情况2-1-插入结点的父亲结点p为黑色"><a href="#情况2-1-插入结点的父亲结点p为黑色" class="headerlink" title="情况2.1:插入结点的父亲结点p为黑色."></a>情况2.1:插入结点的父亲结点p为黑色.</h4><ul><li>此时满足条件3,保持为红色<h4 id="情况2-2-插入结点的父亲结点p为红色"><a href="#情况2-2-插入结点的父亲结点p为红色" class="headerlink" title="情况2.2:插入结点的父亲结点p为红色."></a>情况2.2:插入结点的父亲结点p为红色.</h4></li><li>此时不满足条件3:产生双红缺陷<ul><li>此时需要考虑该节点的叔叔结点(祖先结点的另一个孩子)</li></ul></li></ul><p><img src="双红缺陷.jpg" alt></p><h5 id="情况2-2-1-叔叔结点为黑色-包括叔叔结点为外部（也是黑色）结点"><a href="#情况2-2-1-叔叔结点为黑色-包括叔叔结点为外部（也是黑色）结点" class="headerlink" title="情况2.2.1:叔叔结点为黑色(包括叔叔结点为外部（也是黑色）结点)"></a>情况2.2.1:叔叔结点为黑色(包括叔叔结点为外部（也是黑色）结点)</h5><h6 id="情况2-2-1-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR"><a href="#情况2-2-1-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR" class="headerlink" title="情况2.2.1.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)"></a>情况2.2.1.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)</h6><ul><li>以LL为例,将红色结点都向上提升,形成(a’)的4阶b树,可以看到.按照规则,含有3个关键字的四阶b树,其关键字如果含有2个红色结点,必然为<code>RBR</code>结构.</li><li>所以只需要按照图中结构,让p变为黑,g变为红即可.</li></ul><p><img src="RRBLL.jpg" alt></p><h6 id="情况2-2-1-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL"><a href="#情况2-2-1-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL" class="headerlink" title="情况2.2.1.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)"></a>情况2.2.1.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)</h6><ul><li>以RL为例,将红色结点都向上提升,形成(B’)的4阶b树按照规则,含有3个关键字的四阶b树,其关键字如果含有2个红色结点,必然为<code>RBR</code>结构.<br><img src="RRBRL.jpg" alt></li><li>并且要求该子结构为如图c和c’的类型.</li></ul><p><img src="RRBStandard.jpg" alt></p><ul><li>一次需要先对x结点做左旋操作,然后再按照(a’)方式进行染色.（即x为黑,g为红）</li></ul><hr><ul><li>通过b树来理解双红缺陷(黑叔叔)<ul><li>在某个三叉结点中插入红关键码,使得原黑关键字不再居中.<ul><li>RRB or BRR,出现相邻的红关键码</li></ul></li></ul></li></ul><h5 id="情况2-2-2-叔叔结点为红色"><a href="#情况2-2-2-叔叔结点为红色" class="headerlink" title="情况2.2.2:叔叔结点为红色"></a>情况2.2.2:叔叔结点为红色</h5><h6 id="情况2-2-2-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR"><a href="#情况2-2-2-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR" class="headerlink" title="情况2.2.2.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)"></a>情况2.2.2.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)</h6><ul><li>以LL为例,将红色结点向上提升,形成(a’)的b书,可以看到该4阶b树发生了上溢,需要按照b树的规则对其进行分裂.所以将红黑树中的双红缺陷转换为了b树中的上溢缺陷.</li></ul><p><img src="RRRLL.jpg" alt></p><ul><li>对a对应的b树做分裂操作,如图(c’),将中间结点(即染为红色)提升,剩下的左右子孩子,将中间关键字染为红色,周围关键字染为黑色.</li></ul><p><img src="RRRLL_Btree.jpg" alt></p><ul><li>同样,将g结点提升之后需要考虑g的父亲结点是否会产生双红缺陷.重复考虑类似的插入操作.</li></ul><h6 id="情况2-2-2-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL"><a href="#情况2-2-2-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL" class="headerlink" title="情况2.2.2.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)"></a>情况2.2.2.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)</h6><ul><li>以RL为例,类似于情况2.2.2.1.</li></ul><p><img src="RRRRL.jpg" alt></p><hr><ul><li>总结<ul><li>重构,染色操作均属于常熟时间的局部操作,股只需统计总次数.</li><li>红黑树的每一次插入操作都可在o(logn)时间内完成</li><li>其中至多做: o(logn)次结点染色,一次旋转操作.</li></ul></li></ul><div class="table-container"><table><thead><tr><th>情况</th><th>旋转次数</th><th>染色次数</th><th>此后</th></tr></thead><tbody><tr><td>uncle为黑</td><td>1</td><td>2</td><td>调整随机完成</td></tr><tr><td>uncle为红</td><td>0</td><td>3</td><td>可能再次双红,但必上升两层. </td></tr></tbody></table></div><ul><li>流程图</li></ul><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><pre><code class="lang-md">* 首先按照BST常规算法,执行:    r = removeAt(x,_hot)* x由孩子r接替    // 另一个孩子记为w(即黑的NULL)* 此时条件1,2,依然满足,不3,4不一定满足    * 若x和r之一是红的,那3,4不难解决</code></pre><p><img src="RBTreeInsert.png" alt></p><h3 id="情况1-删除结点x和孩子r-两者之一为红色"><a href="#情况1-删除结点x和孩子r-两者之一为红色" class="headerlink" title="情况1: 删除结点x和孩子r,两者之一为红色"></a>情况1: 删除结点x和孩子r,两者之一为红色</h3><ul><li>这是只要将接替的r结点染为黑色即可.<br><img src="RBTRemove1.jpg" alt></li></ul><h3 id="情况2-删除结点x和孩子r均为黑色"><a href="#情况2-删除结点x和孩子r均为黑色" class="headerlink" title="情况2:删除结点x和孩子r均为黑色"></a>情况2:删除结点x和孩子r均为黑色</h3><ul><li>此时会发生双黑缺陷,摘除x并代之以r后,全树黑深度不再统一,对应b树中x所属结点产生下溢.</li><li>此时需要在新树中中考察x的父亲结点p,以及r的兄弟结点s.总共考虑4中情况</li></ul><p><img src="DoubleBlack.jpg" alt></p><h4 id="情况2-1-s为黑-且至少有一个红孩子t"><a href="#情况2-1-s为黑-且至少有一个红孩子t" class="headerlink" title="情况2.1:s为黑,且至少有一个红孩子t"></a>情况2.1:s为黑,且至少有一个红孩子t</h4><ul><li>变换方法:<ul><li>将p结点由旋转</li><li>此为,保持r为黑色,t和p染为黑色,s继承原来p的颜色.</li></ul></li><li>底层原理:<ul><li>将图(a)进行向上提升后,可以看出删除x结点后发生了下溢.</li><li>通过关键码的旋转,可以消除结点的下溢.</li></ul></li></ul><p><img src="RBTRmove_BB1.jpg" alt></p><h4 id="情况2-2-s为黑-且两个孩子均为黑-p为红"><a href="#情况2-2-s为黑-且两个孩子均为黑-p为红" class="headerlink" title="情况2.2:s为黑,且两个孩子均为黑;p为红."></a>情况2.2:s为黑,且两个孩子均为黑;p为红.</h4><ul><li>变换方法:<ul><li>r保持黑;s转红;p转黑</li></ul></li><li>底层原理:<ul><li>将(a)提升后,如图(a’)发生下溢,但是无法向相邻的结点借关键码,所以采用合并操作.</li><li>对于取出的关键码p因为不在会被向上提升所以为黑色,结点中的关键码只存在<code>RBR</code>,<code>RB</code>,<code>BR</code>三种情况,所以s为红色.</li><li>红黑树的性质因此在全局得以恢复</li><li>失去关键码p后,上层结点<code>不会</code>继续下溢.<ul><li>因为合并之前,在p之左或右侧还应有(问号)关键码,必维黑色.有且仅有一个.</li></ul></li></ul></li></ul><p><img src="RRTRomve_BB2R.jpg" alt></p><h4 id="情况2-3-s为黑-且两个孩子均为黑-p为黑"><a href="#情况2-3-s为黑-且两个孩子均为黑-p为黑" class="headerlink" title="情况2.3:s为黑,且两个孩子均为黑;p为黑."></a>情况2.3:s为黑,且两个孩子均为黑;p为黑.</h4><ul><li>变换方法:<ul><li>s转红,r和p保持黑</li><li>依次处理上层结点的下溢.</li></ul></li></ul><ul><li>底层原理:<ul><li>将(a)提升后,如图(a’)发生下溢,但是无法向相邻的结点借关键码，而此时上层结点只有一个关键码,在借出关键码之后,上层结点会再次导致下溢,需要重复操作.</li></ul></li></ul><p><img src="RBTRmove_BB2.jpg" alt></p><h4 id="情况2-4-s为红-其两个孩子必为黑"><a href="#情况2-4-s为红-其两个孩子必为黑" class="headerlink" title="情况2.4:s为红(其两个孩子必为黑)"></a>情况2.4:s为红(其两个孩子必为黑)</h4><ul><li>变换方法:<ul><li>将p点向右旋转,s边黑,p变红</li><li>转换为2.1,2.2的情况</li></ul></li><li>底层原理:<ul><li>将(a)提升后,如图(a’)会发生下溢,且s’结点为黑,所以只能合并,需要向上层借一个关键码,则需要对上层结点重新染色.s为黑,p为红.</li><li>此时r有了一个新的黑兄弟s’,且p为红,所以此时就会转换到2.1和2.2的情况.</li></ul></li></ul><p><img src="RBTRmove_BB3.jpg" alt></p><hr><ul><li>总结:<ul><li>红黑树的每一次操作的时间为O(log(n))</li></ul></li></ul><div class="table-container"><table><thead><tr><th>情况</th><th>旋转次数</th><th>染色次数</th><th>此后</th></tr></thead><tbody><tr><td>(1)兄弟为黑,有红孩子t</td><td>1</td><td>3</td><td>调整随即完成</td></tr><tr><td>(2)兄弟为黑,无红黑子,父亲结点为红</td><td>0</td><td>2</td><td>调整随即完成 </td></tr><tr><td>(3)兄弟为黑,无红黑子,父亲结点为黑</td><td>0</td><td>1</td><td>必然再次双黑,但将上升一层. </td></tr><tr><td>(4)兄弟为红</td><td>1</td><td>2</td><td>转换为(1)或2(R) </td></tr></tbody></table></div><p><img src="RBTRmove_graphy.jpg" alt></p><h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a>散列表(哈希表)</h1><ul><li>散列函数:一个把查找表中的关键字映射成该关键字对应的地址的函数,记为<ul><li>Hash(key) = Addr</li></ul></li><li>冲突:散列函数可能会把两个或两个以上的不同关键字映射到同一地址</li><li>同义词:发生碰撞的不同关键字</li><li>散列表:根据关键字而直接进行访问的数据结构散列表建立了关键字和存储地址之间的一种直接映射关系.</li></ul><h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><ul><li>散列函数的特点<ul><li>定义域包括全部需要存储的关键字,值域取决于散列表的大小或地址范围</li><li>散列函数计算出来的地址应该等概率、均匀地分布在整个地址空间内,减少冲突的发生.</li><li>散列函数应该尽量简答,能够在短时间内计算出任意关键字的散列地址.</li></ul></li></ul><hr><ul><li><p>直接定址法 : H(key) = key or H(key) = a * key + b</p><ul><li>取关键字的某个线性函数值作为散列地址</li><li>均匀也不会产生冲突</li><li>适合查找表较小且连续的情况,不连续会造成空间浪费</li></ul></li><li><p>除留余数法: H(key) = key % p</p><ul><li>p为不大于散列表长m但最接近或等于m的质数</li><li>p决定了造成冲突的可能性</li></ul></li><li><p>数字分析法:</p><ul><li>如果关键字是位数较多的数字，且这些数字部分存在相同规律则可以采用抽取剩余不同规律部分作为散列地址</li><li>例如手机:前3位接入号,中间4位HLR识别号,后4位用户号,选择后四位作为散列地址就是不错的选择</li><li>可以对这些抽出来的数字进行<strong>反转</strong>,<strong>左移</strong>,<strong>右移</strong>等操作<ul><li>目的：尽量合理地将关键字分配到散列表的各个位置</li></ul></li><li>适合处理关键字位数比较大的情况,事先知道关键字的分布且关键字的若干位分布较均匀.</li></ul></li><li><p>平方取中法:</p><ul><li>即取关键字平方的中间位数作为散列地址</li><li>例如:比如假设关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址</li><li>适合于不知道关键字的分布，而位数又不是很大的情况</li></ul></li><li><p>折叠法:</p><ul><li>折将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些,然后将这几部分叠加求和,并按散列表表长，取后几位作为散列地址</li><li>例如:比如假设关键字是 9876543210，散列表表长为三位,则我们可以将它分为四组 987|654|321|0,然后将它们叠加求和 987+654+321+0=1962,再取后 3 位得到散列地址即为 962</li><li>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况</li></ul></li><li><p>随机数法: H(key) = random(key)</p><ul><li>取关键字的随机函数值为它的散列地址</li><li>当关键字的长度不等时采用这个方法构造散列函数是比较合适的</li></ul></li></ul><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul><li>任何散列函数都不能绝对地避免冲突.需要为发生冲突的关键字寻找下一个Hash地址.</li><li>Hi表示处理冲突中第i次探测得到的散列地址.</li></ul><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><ul><li>开放定址法:可存放新关键字的空间地址既向它的同义词表项开放,又向她的非同义词表项开放.<ul><li>$H_{i} = (H(key) + d_{i})$ % m<ul><li>m为散列表长</li><li>$d_{i}$为增量序列</li></ul></li></ul></li></ul><hr><ul><li><p>线性探测法</p><ul><li>$d_{i}$ = 0,1,2,…,m-1</li><li>冲突发生时,顺序查看表中下一个单元(循环探测),直到找到一个空闲单元或查遍全表</li><li>问题:容易造成大量元素在相邻的散列地址上聚集起来,大大降低了查找效率<ul><li>使得第i个散列地址的同义词存入i+1个散列地址,本应存入第i+1个散列地址的元素只能存入第i+2个散列地址.</li></ul></li></ul></li><li><p>平方(二次)探测法</p><ul><li>$d_{i} = 0^{2},1^{2},-1^{2},2^{2},-2^{2},…,k^{2},-k^{2}$<ul><li>k &lt;= m/2</li><li>m 必须是一个可以表示成4k+3的素数</li></ul></li><li>避免堆积问题,但不能探测散列表上的所有元素,但至少能探测到一半单元</li></ul></li><li><p>再散列法</p><ul><li>$d_{i} = Hash_{2}(key)$</li><li>$H_{i} = (H(key)+i*Hash_{2}(key))%m</li><li>第一个散列函数用于得到地址,当发生冲突时使用第二个散列函数</li></ul></li><li><p>伪随机序列法</p><ul><li>$d_{i} = 伪随机序列$</li></ul></li></ul><hr><ul><li>在开放定址法中,不能物理删除已有元素,会阶段其他具有相同散列地址的元素.</li><li>只能利用删除标记做逻辑删除</li><li>需要定期维护散列表</li></ul><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><ul><li>把同义词存储在一个线性链表中,这个线性链表由其散列地址唯一识别.</li><li>拉链法适用于经常进行插入和删除的情况.</li></ul><p><img src="拉链法.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法</title>
      <link href="/2021/07/04/Algorithm/Graphy/"/>
      <url>/2021/07/04/Algorithm/Graphy/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h2><h2 id="djikstra"><a href="#djikstra" class="headerlink" title="djikstra"></a>djikstra</h2><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman_ford"></a>Bellman_ford</h2><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><h2 id="floyed"><a href="#floyed" class="headerlink" title="floyed"></a>floyed</h2><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><h2 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h2><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂</title>
      <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/AbstactFactory/"/>
      <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/AbstactFactory/</url>
      
        <content type="html"><![CDATA[<h1 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h1><ul><li>通过”对象创建”模式绕开new,来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创建的稳定.它是接口抽象之后的第一步工作.</li><li><p>典型模式</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li><li><p>为什么要绕开new?</p><ul><li>根据<code>依赖倒置原则</code>,在代码实现中不应该出现<code>细节依赖</code>（出现依赖具体类）,应该使用抽象接口,但是抽象接口无法实例化,所以需要绕开new</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常面临着”<strong>一系列相互依赖的对象</strong>“的创建工作;同时,由于需求的变化,往往存在更多系列对象的创建工作.</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>提供一个接口,让该接口负责创建一系列”相关或者相互依赖的对象”,无需指定它们具体的类<ul><li>就是让一个抽象类包含一组相互关联的抽象积累的工厂类中的创建函数(相当于工厂家族?)</li></ul></li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Abstract_Factory.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li>如果没有应对”多系列对象构建”的需求变化,则没有必要使用抽象工厂模式,这时候使用简单的工厂完全可以.</li><li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系.不同系列的对象之间不能相互依赖.</li><li>抽象工厂模式主要在于应对”新系列”的需求变动.其缺点在于难以应对”新对象”的需求变动.<ul><li>指代的是在在抽象工厂中难以添加新的创建函数(因为要求稳,你瞎改的话还用什么设计模式)</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="普通工厂"><a href="#普通工厂" class="headerlink" title="普通工厂"></a>普通工厂</h2><ul><li>代码复杂冗余,而且容易导致相互关联的对象之间不匹配.<br>```cpp<br>//数据库访问有关的基类<br>class IDBConnection{</li></ul><p>};<br>class IDBConnectionFactory{<br>public:<br>    virtual IDBConnection* CreateDBConnection()=0;<br>};</p><p>class IDBCommand{</p><p>};<br>class IDBCommandFactory{<br>public:<br>    virtual IDBCommand* CreateDBCommand()=0;<br>};</p><p>class IDataReader{</p><p>};<br>class IDataReaderFactory{<br>public:<br>    virtual IDataReader* CreateDataReader()=0;<br>};</p><p>//支持SQL Server<br>class SqlConnection: public IDBConnection{</p><p>};<br>class SqlConnectionFactory:public IDBConnectionFactory{</p><p>};</p><p>class SqlCommand: public IDBCommand{</p><p>};<br>class SqlCommandFactory:public IDBCommandFactory{</p><p>};</p><p>class SqlDataReader: public IDataReader{</p><p>};<br>class SqlDataReaderFactory:public IDataReaderFactory{</p><p>};</p><p>//支持Oracle<br>class OracleConnection: public IDBConnection{</p><p>};</p><p>class OracleCommand: public IDBCommand{</p><p>};</p><p>class OracleDataReader: public IDataReader{</p><p>};</p><p>class EmployeeDAO{<br>    IDBConnectionFactory<em> dbConnectionFactory;<br>    IDBCommandFactory</em> dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;</p><p>public:<br>    vector<employeedo> GetEmployees(){<br>        IDBConnection* connection =<br>            dbConnectionFactory-&gt;CreateDBConnection();<br>        connection-&gt;ConnectionString(“…”);</employeedo></p><pre><code>    IDBCommand* command =        dbCommandFactory-&gt;CreateDBCommand();    command-&gt;CommandText(&quot;...&quot;);    command-&gt;SetConnection(connection); //关联性    IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性    while (reader-&gt;Read()){    }}</code></pre><p>};</p><pre><code>## 抽象工厂```cpp//数据库访问有关的基类class IDBConnection{};class IDBCommand{};class IDataReader{};class IDBFactory{public:    virtual IDBConnection* CreateDBConnection()=0;    virtual IDBCommand* CreateDBCommand()=0;    virtual IDataReader* CreateDataReader()=0;};//支持SQL Serverclass SqlConnection: public IDBConnection{};class SqlCommand: public IDBCommand{};class SqlDataReader: public IDataReader{};class SqlDBFactory:public IDBFactory{public:    virtual IDBConnection* CreateDBConnection()=0;    virtual IDBCommand* CreateDBCommand()=0;    virtual IDataReader* CreateDataReader()=0;};//支持Oracleclass OracleConnection: public IDBConnection{};class OracleCommand: public IDBCommand{};class OracleDataReader: public IDataReader{};class EmployeeDAO{    IDBFactory* dbFactory;public:    vector&lt;EmployeeDO&gt; GetEmployees(){        IDBConnection* connection =            dbFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(&quot;...&quot;);        IDBCommand* command =            dbFactory-&gt;CreateDBCommand();        command-&gt;CommandText(&quot;...&quot;);        command-&gt;SetConnection(connection); //关联性        IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性        while (reader-&gt;Read()){        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么要用面向对象设计?<ul><li>变化是复用的天敌,面向对象设计最大的优势在于:抵御变化</li></ul></li></ul><h1 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h1><ul><li>隔离变化<ul><li>从宏观层面来看,面向对象的构建方式更能适应软件的变化,能将变化所带来的影响力减为最小.</li></ul></li><li>各司其职<ul><li>从微观层面来看,面向对象的方式更强调各个类的”责任”</li><li>由于需求变化导致的新增类型不应该影响原理类型的实现—是所谓各负其责</li></ul></li><li>对象是什么?<ul><li>从语言实现层面来看,对象封装了代码和数据</li><li>从规格层面讲,对象是一些列可使用的公共接口</li><li>从概念层面讲,对象是某种拥有责任的抽象</li></ul></li></ul><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h2><ul><li>高层模块(稳定)不应该依赖于底层模块(变化),二者都应该依赖于抽象(稳定)<ul><li>高层模块不应该直接依赖于某个具体类,而应该依赖某个抽象接口,而具体类由抽象接口继承得到.</li></ul></li><li>抽象(稳定)不应该依赖于实现细节(变化),实现细节应该依赖于抽象（稳定）<ul><li>抽象接口应使用虚函数来把持高层模块调用时的统一,将具体实现细节交给子类.</li></ul></li></ul><h2 id="开放封闭原侧-OCP"><a href="#开放封闭原侧-OCP" class="headerlink" title="开放封闭原侧(OCP)"></a>开放封闭原侧(OCP)</h2><ul><li>对扩展开放,对更改封闭</li><li>类模块应该是可扩展的,但是不可修改的.</li></ul><h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h2><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><h2 id="Liskov替换原则-LSP"><a href="#Liskov替换原则-LSP" class="headerlink" title="Liskov替换原则(LSP)"></a>Liskov替换原则(LSP)</h2><ul><li>子类必须能够替换它们的积累(IS-A)</li><li>继承表达类型抽象</li></ul><h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul><h1 id="优先使用对象组合-而不是类继承"><a href="#优先使用对象组合-而不是类继承" class="headerlink" title="优先使用对象组合,而不是类继承"></a>优先使用对象组合,而不是类继承</h1><ul><li>类继承通常为”白箱复用”,对象组合通常为”黑箱复用”.</li><li>继承在某种程度上破坏封装性,子类父类耦合度高.</li><li>而对象组合只要求被组合的对象具有良好的接口,耦合度低</li></ul><h1 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h1><ul><li>使用封装层来创建对象之间的分界层,让设计者可以在分界层的一测进行修改,而uhuidui另一侧产生不良的影响,从而实现层之间的松耦合.</li></ul><h1 id="针对接口编程-而不是针对实现编程"><a href="#针对接口编程-而不是针对实现编程" class="headerlink" title="针对接口编程,而不是针对实现编程"></a>针对接口编程,而不是针对实现编程</h1><ul><li>不将变量类型声明为某个特定的具体类,而是声明为某个接口.</li><li>客户程序无需获知对象的具体类型,只需要知道对象所具有的接口.</li><li>减少系统中各部分的依赖关系,从而实现”高内聚、松耦合”的类型设计方案.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统入门</title>
      <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OperationSystem/StartOS/"/>
      <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OperationSystem/StartOS/</url>
      
        <content type="html"><![CDATA[<ul><li>参考:<a href="https://leetcode-cn.com/leetbook/read/awesome-os-guide/egu5ni/" target="_blank" rel="noopener">操作系统入门</a></li></ul><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="StartOS/abstract.png" alt></p><h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><ul><li>什么是操作系统?<ul><li>操作系统用于控制和管理整个计算机系统的硬件与软件资源,合理地组织、调度计算机的工作与资源的分配,进而为用户和其他软件提供方便接口与环境的程序集合.</li><li>操作系统是计算机系统中最基本的系统软件.</li></ul></li></ul><p><img src="StartOS/os.png" alt></p><ul><li><p>操作系统的目标</p><ul><li>作为计算机系统资源的管理者<ul><li>cpu,存储器,文件,设备</li></ul></li><li>作为用户与计算机硬件系统之间的接口<ul><li>命令接口:联机(交互)命令接口,脱机(批处理)命令接口</li><li>程序接口:GUI</li></ul></li><li>作为扩充机器<ul><li>把覆盖了软件的机器称为扩充机器或虚拟机</li></ul></li></ul></li><li><p>操作系统的特征</p><ul><li>并发[最基本]<ul><li>与并行区别</li></ul></li><li>共享[最基本]<ul><li>指资源共享,系统中的资源可供内存中多个并发执行的进程共同使用.<ul><li>互斥共享,一个时间段只允许一个进程访问该资源.(如打印机,磁带机)</li><li>同时访问方式,一个时间段内由多个进程”同时”访问(微观上分时共享).（如多进程同时访问磁盘）</li></ul></li></ul></li><li>虚拟<ul><li>把一个物理实体变为若干逻辑上的对应物.</li><li>os中利用多种虚拟技术来实现<code>虚拟处理器</code>,<code>虚拟内存</code>,<code>虚拟外部设备</code></li></ul></li><li>异步<ul><li>多道程序环境允许多个程序并发执行,但由于资源有限,进程的执行不是一管到底的,而是走走停停的,它以不可预知的速度向前推进.</li></ul></li></ul></li></ul><h2 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><ul><li>用户独占全机</li><li>CPU等待手工操作<h3 id="批处理阶段-os出现"><a href="#批处理阶段-os出现" class="headerlink" title="批处理阶段(os出现)"></a>批处理阶段(os出现)</h3></li><li>目的:为了解决人机矛盾以及CPU和I/O设备之间速度不匹配的矛盾.<h4 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h4></li><li>描述:系统对作业的处理是成批进行的,但内存中始终保持一道作业</li><li>特征:<ul><li>自动性</li><li>顺序性</li><li>单道性</li></ul></li><li>缺点: 运行时需要I/O操作时,需要让告诉CPU等待低俗的I/O完成.<h4 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h4></li><li>描述:多个程序进入内存并在cpu中交替运行,共享系统中的各种软硬件资源.如果一个程序因IO而阻塞,CPU则运行另一个程序.</li><li>特征:<ul><li>多道</li><li>宏观上并行</li><li>微观上串行</li></ul></li><li>有点:<ul><li>资源利用率高</li><li>系统吞吐率高</li></ul></li><li>缺点:<ul><li>用户相应时间长</li><li>不提供人机交互能力</li></ul></li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><ul><li>描述:通过时间片轮转</li><li>特征:<ul><li>同时性:多个用户</li><li>交互性</li><li>独立性:用户独立操作</li><li>及时性:用户短时间得到响应</li></ul></li><li>缺点: 对于飞机订票系统、导弹系统等实时性要求搞的情况无法处理.<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3></li><li>硬实时操作系统</li><li>软实时操作系统</li><li>特征:<ul><li>及时性</li><li>可靠性</li></ul></li></ul><h3 id="网络操作系统和分布式操作系统"><a href="#网络操作系统和分布式操作系统" class="headerlink" title="网络操作系统和分布式操作系统"></a>网络操作系统和分布式操作系统</h3><hr><ul><li>总结</li></ul><p><img src="StartOS/os_history.jpg" alt></p><h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h3><ul><li><p>cpu状态</p><ul><li>核心态:操作系统内核程序</li><li>用户态:用户自编程序</li></ul></li><li><p>计算机内核功能</p><ul><li>时钟管理:计时,管理进程切换</li><li>中断机制</li><li>原语<ul><li>底层</li><li>原子性</li><li>运行时间短,调用频繁 </li></ul></li><li>系统控制的数据结构及处理<ul><li>进程控制卡(pcb)等</li><li>提供各类进程管理操作等</li></ul></li></ul></li></ul><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul><li>外中断(中断):cpu执行指令意外的事件<ul><li>外设请求</li><li>人的干预</li></ul></li><li>异常(内中断,例外,陷入):cpu执行指令内部的事件<ul><li>自愿中断(指令中断)</li><li>强迫中断(硬件故障,软件中断)</li></ul></li></ul><hr><ul><li>中断处理<ul><li>关中断</li><li>保存断点</li><li>中断服务程序寻址</li><li>保存现场和屏蔽字(中断优先级)</li><li>开中断</li><li>执行中断服务程序</li><li>关中断</li><li>恢复现场和屏蔽字</li><li>开中断</li><li>中断返回</li></ul></li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li>用户在程序中调用操作系统所提供的一些子功能,系统调用可视为特殊的公共子程序</li></ul><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><ul><li>大内核就是将os的主要功能模块都作为一个紧密联系的整体运行在和核心态.各管理模块之间共享信息,能有效利用相互之间的有效特性.</li><li>微内核结构有效地分离内核与服务、服务与服务，使得它们之间的接口更加清晰,维护的代价大大降低。</li></ul><h1 id="其他难点"><a href="#其他难点" class="headerlink" title="其他难点"></a>其他难点</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h2 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h2><ul><li>从用户态转换为核心态的唯一途径是中断或异常</li></ul><h2 id="访管指令与访管中断"><a href="#访管指令与访管中断" class="headerlink" title="访管指令与访管中断"></a>访管指令与访管中断</h2><ul><li>访管指令:让用户程序可以从用户态切换到核心态.非特权指令.</li><li>访管中断:访管指令引起的中断</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OperationSystem/ProcessManagement/"/>
      <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OperationSystem/ProcessManagement/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程、协程"><a href="#进程与线程、协程" class="headerlink" title="进程与线程、协程"></a>进程与线程、协程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>PCB是进程存在的唯一标志<ul><li>进程影像是静态的,进程是动态的</li></ul></li><li>定义:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位</li></ul><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><pre><code>- PCB(进程控制块)- 程序段- 数据段</code></pre><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>高级通信方式(进程通信):以较高的效率传输大量数据的通信方式<br>低级通信方式:PV操作</p><ul><li><p>共享存储</p></li><li><p>消息传递</p></li><li><p>管道通信</p></li></ul><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法</title>
      <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Factory/"/>
      <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Factory/</url>
      
        <content type="html"><![CDATA[<h1 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h1><ul><li>通过”对象创建”模式绕开new,来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创建的稳定.它是接口抽象之后的第一步工作.</li><li><p>典型模式</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Bilder</li></ul></li><li><p>为什么要绕开new?</p><ul><li>根据<code>依赖倒置原则</code>,在代码实现中不应该出现<code>细节依赖</code>（出现依赖具体类）,应该使用抽象接口,但是抽象接口无法实例化,所以需要绕开new</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常面临着创建对象的工作;由于需求的变化,需要创建的对象的具体类型经常变化</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>定义一个用于创建对象的接口(工厂基类),让子类决定实例化哪一个类.Factory Method使得一个类的实例化延迟(目的:结构,手段:虚函数)到子类.</li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Factory_Method.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系.面对一个经常变化的具体类型,紧耦合关系(new)会导致软件的脆弱.</p></li><li><p>Factory Method模式通过<strong>面向对象(多态)</strong>的手法,将所要创建的具体对象的工作延迟到子类,从而实现一种扩展(而非更改)的策略,较好地解决了这种紧耦合关系</p></li><li><p>Factory Method模式解决”当个对象”的需求变化.缺点在于要要求创建方法/参数相同</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="不适用工厂导致紧耦合关系-new"><a href="#不适用工厂导致紧耦合关系-new" class="headerlink" title="不适用工厂导致紧耦合关系(new)"></a>不适用工厂导致紧耦合关系(new)</h2><ul><li>这种紧耦合关系会导致在需求变化的情况下不断地修改源代码.</li></ul><pre><code class="lang-cpp">// 设计糟糕,只能支持具体类void Button1_Click(){    ISplitter * splitter= new BinarySplitter();//依赖具体类    splitter-&gt;split();}// 理想但是虚函数无法实例化void Button1_Click(){    ISplitter * splitter= new ISplitter();//依赖具体类    splitter-&gt;split();}</code></pre><h2 id="工厂基类"><a href="#工厂基类" class="headerlink" title="工厂基类"></a>工厂基类</h2><ul><li>工厂基类用于扩展不同的具体工厂.</li><li>而每一个具体工厂提供一种具体的对象生成函数,其返回父类接口的指针,这样在对象生成的时候可以保持代码一致.</li></ul><pre><code class="lang-cpp">//工厂基类class SplitterFactory{public:    virtual ISplitter* CreateSplitter()=0;    virtual ~SplitterFactory(){}};//具体工厂class BinarySplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new BinarySplitter();    }};class TxtSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new TxtSplitter();    }};class PictureSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new PictureSplitter();    }};class VideoSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new VideoSplitter();    }};</code></pre><hr><pre><code class="lang-cpp">//抽象类class ISplitter{public:    virtual void split()=0;    virtual ~ISplitter(){}};//具体类class BinarySplitter : public ISplitter{};class TxtSplitter: public ISplitter{};class PictureSplitter: public ISplitter{};class VideoSplitter: public ISplitter{};</code></pre><hr><pre><code class="lang-cpp">* 使用是时候通过构造函数从外面传进一个工厂实例,这样在这个文件中的代码非常稳定,不需要进行更改.//使用方法class MainForm : public Form{    SplitterFactory*  factory;//工厂public:    MainForm(SplitterFactory*  factory){        this-&gt;factory=factory;    }    void Button1_Click(){           ISplitter * splitter=            factory-&gt;CreateSplitter(); //多态new               splitter-&gt;split();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥模式</title>
      <link href="/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Bridge/"/>
      <url>/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Bridge/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul><li><p>在软件组件的设计中,如果责任划分的不清晰,使用继承得到的结果往往是随着需求的变化,子类急剧膨胀,同时充斥着重复代码,这时候的关键是划清责任.</p></li><li><p>典型模式</p><ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>由于某些类型的固有的实现逻辑,使得它们具有两个变化的维度,乃至多个维度的变化.</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>将抽象部分(业务功能)与实现平台(平台实现)分离,使他们都可以独立地变化.</li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Bridge.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>Bridge模式使用”对象间的组合关系”解耦了抽象和实现之间固有的绑定关系,使得抽象和实现可以沿着各自的维度来变化.所谓抽象和实现沿着各自维度的变化,即”子类化”它们.</p></li><li><p>Bridge模式有时候类似于多继承方案,但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因),复用性比较差.Brige模式是比多继承方案更好的解决方法.</p></li><li><p>Bridge模式的应用一般在”两个非常强的变化维度”,有时一个类也有多于两个的变化维度,这时可以使用Bridge的扩展模式</p><ul><li>在Abstractor中含有多个Implemtor的指针.</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="lang-cpp">class Messager{ // 这个相当于UML图中的Abstraction,用于放置一部分的抽象,这里是消息机制中的各种业务抽象protected:     MessagerImp* messagerImp;//通过组合(has-a)的方式在两个维度的变化组合在一起,如果有多个强变化的维度,可以在这里加多个指针public:    virtual void Login(string username, string password)=0;    virtual void SendMessage(string message)=0;    virtual void SendPicture(Image image)=0;    virtual ~Messager(){}};class MessagerImp{ //这个相当于UML图中的Implmentor,用于放置另一部分变化维度比较明显的的抽象,比如这里放置的是与平台相关的功能实现public:    virtual void PlaySound()=0;    virtual void DrawShape()=0;    virtual void WriteText()=0;    virtual void Connect()=0;    virtual MessagerImp(){}};//平台实现 nclass PCMessagerImp : public MessagerImp{public:    virtual void PlaySound(){        //**********    }    virtual void DrawShape(){        //**********    }    virtual void WriteText(){        //**********    }    virtual void Connect(){        //**********    }};class MobileMessagerImp : public MessagerImp{public:    virtual void PlaySound(){        //==========    }    virtual void DrawShape(){        //==========    }    virtual void WriteText(){        //==========    }    virtual void Connect(){        //==========    }};//业务抽象 m//类的数目：1+n+mclass MessagerLite :public Messager {public:    virtual void Login(string username, string password){        messagerImp-&gt;Connect();        //........    }    virtual void SendMessage(string message){        messagerImp-&gt;WriteText();        //........    }    virtual void SendPicture(Image image){        messagerImp-&gt;DrawShape();        //........    }};class MessagerPerfect  :public Messager {public:    virtual void Login(string username, string password){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;Connect();        //........    }    virtual void SendMessage(string message){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;WriteText();        //........    }    virtual void SendPicture(Image image){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;DrawShape();        //........    }};void Process(){    //运行时装配    //  首先通过多态声明使用的是哪个平台的抽象    //  然后再通过构造函数传递Implmentor来实现运行时多态,达到组合各个维度代码的功能.    MessagerImp* mImp=new PCMessagerImp();    Messager *m =new MessagerLite(mImp);}</code></pre><h1 id="桥接模式与装饰器模式的区别"><a href="#桥接模式与装饰器模式的区别" class="headerlink" title="桥接模式与装饰器模式的区别"></a>桥接模式与装饰器模式的区别</h1><ul><li>主要区别需要通过UML图来说明.<ul><li>可以看到对于桥接模式来说,它是将抽象类(接口)的功能划分为两个(多个)维度,分为absraction和implmentor,absraction通过组合的方式拥有implmentor.两个分别进行继承,生成具体的类.通过运行时多态和参数传递(构造函数)的方法来实现多个功能的组合.</li><li>装饰模式中的装饰器类是一个单独的类,他即包含Component(即抽象接口)的指针(has-a)又继承自Component(is-a),其中is-a的部分是让具体的实现继承自装饰器并且保证抽象接口函数的结构统一.而has-a的部分是Compoent的变化维度,用于实现多个功能的组合.可以看出装饰器模式是不进行抽象维度划分的.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Decorator/"/>
      <url>/2021/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul><li><p>在软件组件的设计中,如果责任划分的不清晰,使用继承得到的结果往往是随着需求的变化,子类急剧膨胀,同时充斥着重复代码,这时候的关键是划清责任.</p></li><li><p>典型模式</p><ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li><p>过渡地使用继承来扩展对象的功能,由于继承为类型引入的静态特质(各种子类定死的调用方式,组合中的多态就是非静态特质),使得这种扩展方式缺乏灵活性,并且随着子类的增多(扩展功能的增多),各种子类的组合(扩展功能的组合)会导致更多子类的膨胀</p></li><li><p>需要使”对象功能的扩展”能够根据需要来动态地实现.同时避免”扩展功能的增多”带来的子类膨胀问题.从而使得任何”功能扩展变化”所导致的影响降为最低。</p></li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>动态(组合)地给一个对象增加一些额外的职责.就增加功能而言,Decorator模式比生成子类(继承)更为灵活(消除重复代码 &amp; 减少子类个数)</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="Decroator_Structure.jpg" alt></p><ul><li>Component和Decorator是不变的类<ul><li>Decorator拥有Component并继承自Component,实际表现功能的是组合,继承是为了完善纯虚类的接口.</li></ul></li><li>其他是变化的类<ul><li>在调用不同的ConcreteDecorator的时候通过传入不同的ConcreteComponent,然后利用多态在运行时处理不同的额外功能.</li></ul></li></ul><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>通过采用组合而非继承的手法,Decorator模式实现了在<strong>运行时</strong>动态扩展对象功能的能力,而且可以根据需要扩展多个功能.避免了使用继承带来的”灵活性差”和”多子类衍生问题”</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系,即Decorator类继承了Component类所具有的接口.但在实现上又表现为has-a Component的组合关系,即Decorator类又使用了另外一个Component类.</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题,Decorator模式应用的要点在于解决”主体类在多个方向上的扩展功能”——是为装饰器的含义.</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="编译时装配"><a href="#编译时装配" class="headerlink" title="编译时装配"></a>编译时装配</h2><ul><li>对于类似的类需要每次继承基类并添加上类似的功能,使得代码变得冗余.(对继承的不良使用)</li></ul><p><img src="Decroator_1.jpg" alt></p><pre><code class="lang-cpp">//业务操作class Stream{public：    virtual char Read(int number)=0;    virtual void Seek(int position)=0;    virtual void Write(char data)=0;    virtual ~Stream(){}};//主体类class FileStream: public Stream{public:    virtual char Read(int number){        //读文件流    }    virtual void Seek(int position){        //定位文件流    }    virtual void Write(char data){        //写文件流    }};class NetworkStream :public Stream{public:    virtual char Read(int number){        //读网络流    }    virtual void Seek(int position){        //定位网络流    }    virtual void Write(char data){        //写网络流    }};class MemoryStream :public Stream{public:    virtual char Read(int number){        //读内存流    }    virtual void Seek(int position){        //定位内存流    }    virtual void Write(char data){        //写内存流    }};//扩展操作class CryptoFileStream :public FileStream{public:    virtual char Read(int number){        //额外的加密操作...        FileStream::Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        FileStream::Seek(position);//定位文件流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        FileStream::Write(data);//写文件流        //额外的加密操作...    }};class CryptoNetworkStream : :public NetworkStream{public:    virtual char Read(int number){        //额外的加密操作...        NetworkStream::Read(number);//读网络流    }    virtual void Seek(int position){        //额外的加密操作...        NetworkStream::Seek(position);//定位网络流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        NetworkStream::Write(data);//写网络流        //额外的加密操作...    }};class CryptoMemoryStream : public MemoryStream{public:    virtual char Read(int number){        //额外的加密操作...        MemoryStream::Read(number);//读内存流    }    virtual void Seek(int position){        //额外的加密操作...        MemoryStream::Seek(position);//定位内存流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        MemoryStream::Write(data);//写内存流        //额外的加密操作...    }};class BufferedFileStream : public FileStream{    //...};class BufferedNetworkStream : public NetworkStream{    //...};class BufferedMemoryStream : public MemoryStream{    //...}class CryptoBufferedFileStream :public FileStream{public:    virtual char Read(int number){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Seek(position);//定位文件流        //额外的加密操作...        //额外的缓冲操作...    }    virtual void Write(byte data){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Write(data);//写文件流        //额外的加密操作...        //额外的缓冲操作...    }};void Process(){        //编译时装配    CryptoFileStream *fs1 = new CryptoFileStream();    BufferedFileStream *fs2 = new BufferedFileStream();    CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream();}</code></pre><h2 id="运行时装配"><a href="#运行时装配" class="headerlink" title="运行时装配"></a>运行时装配</h2><ul><li>合理利用多态以及类的组合(将继承改为组合),消除大量的重复代码</li></ul><p><img src="Decroator_2.jpg" alt></p><pre><code class="lang-cpp">/业务操作class Stream{public：    virtual char Read(int number)=0;    virtual void Seek(int position)=0;    virtual void Write(char data)=0;    virtual ~Stream(){}};//主体类class FileStream: public Stream{public:    virtual char Read(int number){        //读文件流    }    virtual void Seek(int position){        //定位文件流    }    virtual void Write(char data){        //写文件流    }};class NetworkStream :public Stream{public:    virtual char Read(int number){        //读网络流    }    virtual void Seek(int position){        //定位网络流    }    virtual void Write(char data){        //写网络流    }};class MemoryStream :public Stream{public:    virtual char Read(int number){        //读内存流    }    virtual void Seek(int position){        //定位内存流    }    virtual void Write(char data){        //写内存流    }};//扩展操作DecoratorStream: public Stream{ // 这里这个继承是为了CryptoStream等类继承这个装饰器类时,能保证Read等接口是virtual的保证统一.protected:    Stream* stream;//...    DecoratorStream(Stream * stm):stream(stm){    }};class CryptoStream: public DecoratorStream {public:    CryptoStream(Stream* stm):DecoratorStream(stm){    }    virtual char Read(int number){         //额外的加密操作...        stream-&gt;Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        stream::Seek(position);//定位文件流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        stream::Write(data);//写文件流        //额外的加密操作...    }};class BufferedStream : public DecoratorStream{    Stream* stream;//...public:    BufferedStream(Stream* stm):DecoratorStream(stm){     }    //...};void Process(){    //运行时装配    FileStream* s1=new FileStream();    CryptoStream* s2=new CryptoStream(s1); //将文件流传入,CryptoStream实现加密操作    BufferedStream* s3=new BufferedStream(s1);//将文件流传入,BufferedStream实现缓存操作    BufferedStream* s4=new BufferedStream(s2);//将加密文件流传入,会先缓存再加密再执行流操作.}</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/06/24/Algorithm/UnionFind/"/>
      <url>/2021/06/24/Algorithm/UnionFind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章:<a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">算法学习笔记(1) : 并查集</a><br>参考文章:<a href="https://leetcode-cn.com/circle/discuss/3dPiT7/" target="_blank" rel="noopener">分享｜（建议收藏）LeetCoder 并查集模板</a></p></blockquote><h1 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h1><ul><li>并查集有两个操作,合并和查询,用一个元素代表与其关联的一类元素,可以有效解决集合或者图中的连通性问题.</li></ul><h1 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h1><ul><li>初始化操作让每个元素的自己单独为一个集合,但实际应用的时候应根据题意初始化并查集.</li></ul><pre><code class="lang-cpp">//最基础的并查集初始化int fa[MAXN];inline void init(int n){    for (int i = 1; i &lt;= n; ++i)        fa[i] = i;}</code></pre><h1 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h1><ul><li>查询操作用于查询某一个元素属于哪一个集合,这个集合由一个元素代表,返回这个代表元素<pre><code class="lang-cpp">inline int find(x){  if(fa[x] != x)      return find(fa[x]);  else      return x;}</code></pre></li></ul><h1 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h1><ul><li>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。<pre><code class="lang-cpp">inline void merge(int x,int y){  int findx = find(x);  int findy = find(y);  fx[findy] = findy;}</code></pre></li></ul><h1 id="优化1-路径压缩"><a href="#优化1-路径压缩" class="headerlink" title="优化1:路径压缩"></a>优化1:路径压缩</h1><ul><li>路径压缩用于解决并查集合并过程中可能导致深度过高,造成查询效率下降的问题.</li><li>路径压缩就说:要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</li></ul><pre><code class="lang-cpp">inline int find(int x){    if(find(x) == x)        return x;    else    {        fa[x] = find(fa[x]);        return fa[x];    }}//极简写法inline int find(int x){    return x == fa[x] ? x : (fa[x] = find(fa[x]));}</code></pre><h1 id="优化2-按秩合并"><a href="#优化2-按秩合并" class="headerlink" title="优化2:按秩合并"></a>优化2:按秩合并</h1><ul><li>路径压缩优化后，并查集并非都是一个菊花图（只有两层的树的俗称）<ul><li>只有在路径压缩时才会优化某一条路径,所以某一时刻的并查集可能比较复杂</li></ul></li><li>对于复杂的两个并查集合并,更好的做法是将深度低的并查集合并到深度深的并查集上,这样不会造成合并后并查集深度增加.<ul><li>因此对每一个并查集用rank表示其深度,在合并是根据rank值进行合并</li><li>注意如果深度相同并且不是同一个并查集,进行合并后rank会+1</li></ul></li></ul><pre><code class="lang-cpp">inline void merge(int x,int y){    int findx = find(x);    int findy = find(y);    if(rank[x] &gt; rank[y])        fa[findy] = findx;    else        fa[findx] = findy;    if(rank[findx] == rank[findy] &amp;&amp; findx != findy)        rank[findy]++; }</code></pre><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre><code class="lang-cpp">//模板//https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/class UnionFind{private:    vector&lt;int&gt; fa;    vector&lt;int&gt; rank;    int count;public:    UnionFind(){}    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid)//Init    {        count = 0;        int m = grid.size();        int n = grid[0].size();        fa.resize(n*m,0);        rank.resize(n*m,0);        for(int i = 0; i &lt; grid.size();++i)        {            for(int j = 0; j &lt; grid[0].size();++j)            {                if(grid[i][j] == &#39;1&#39;)                {                    fa[i*n+j] = i*n+j;                    ++count;                }                else                    fa[i*n+j] = -1;                rank[i*n+j] = 1;            }        }    }    inline int find(int x)    {        return x == fa[x]? x : (fa[x] = find(fa[x]));    }    inline void merge(int x,int y)    {        int fx = find(x);        int fy = find(y);        if(rank[fx] &gt; rank[fy])            fa[fy] = fx;        else            fa[fx] = fy;        if(rank[fx] == rank[fy] &amp;&amp; fx != fy)            rank[fy]++;        if(fx != fy)            --count;    }    inline int getCount()    {        return count;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/Linking/"/>
      <url>/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/Linking/</url>
      
        <content type="html"><![CDATA[<h1 id="链接简介"><a href="#链接简介" class="headerlink" title="链接简介"></a>链接简介</h1><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><ul><li><strong>链接</strong>是将各种代码和数据片段收集并组合称为一个单一文件的过程,这个文件可被加载(复制)到内存并执行.</li></ul><h2 id="链接的时期"><a href="#链接的时期" class="headerlink" title="链接的时期"></a>链接的时期</h2><ul><li>链接可以执行于<strong>编译时</strong>(源代码被翻译成机器代码时),<strong>加载时</strong>(程序被加载器加载到内存并执行时),<strong>运行时</strong>(程序运行的时候)</li></ul><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><ul><li>现代操作系统中,链接由连接器自动执行.</li><li>连接器使得程序可以<strong>分离编译</strong><ul><li>将大型程序分成一个个模块,单独编译,并进行链接.当需要修改某一模块时,只需重新编译某一模板并重新链接即可</li></ul></li></ul><h1 id="编译器驱动程序-程序编译过程"><a href="#编译器驱动程序-程序编译过程" class="headerlink" title="编译器驱动程序(程序编译过程)"></a>编译器驱动程序(程序编译过程)</h1><ul><li>示例程序<br>```cpp<br>/<em>code/link/main.c</em>/<br>int sum(int *a,int n);</li></ul><p>int array[2] = {1,2};</p><p>int main()<br>{<br>    int val = sum(array,2);<br>    return val;<br>}</p><pre><code>```cpp/* code/link/sum.c */int sum(int *a,int n){    int i,s=0;    for(i = 0; i &lt; n; ++i)    {        s+=a[i];    }    return s;}</code></pre><hr><ul><li>编译器驱动程序:用于调用语言预处理器、编译器、汇编器和链接器.</li><li>下图概括驱动程序将实例程序从ASCII码源文件翻译成可执行目标文件时的行为(静态链接).</li></ul><p><img src="Complie_Procedural.jpg" alt></p><ul><li>上图的编译过程如下<ul><li>main.c通过C预处理器(cpp)将C的源程序翻译成ACII码的中间文件main.i</li><li>main.i通过c编译器(cc1)将ACII码的中间文件翻译成ASCII汇编语言文件main.s</li><li>main.s通过汇编器(as)将ASCII汇编语言文件翻译成可重定位目标文件main.o</li><li>所有.o文件和一些必要的系统目标文件通过连接器程序(ld)组合起来创建一个可执行目标文件</li></ul></li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><ul><li>什么是静态链接？<ul><li>静态链接是静态链接器以一组<code>可重定位目标文件</code>和<code>命令行参数</code>作为输入,生成一个<code>完全链接的</code>、<code>可以加载</code>和<code>运行</code>的可执行目标木剑作为输出.<ul><li>可重定位文件由不同的代码和数据节组成，每一节都是一个连续的字节序列.<ul><li>指令,初始化的全局变量,未初始化的变量在不同的节中.</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p>连接器的主要任务</p><ul><li>符号解析<ul><li>任务:目标文件定义和引用符号<ul><li>每个符号对应一个函数、一个全局变量或一个静态变量</li></ul></li></ul></li><li><p>目的:将每个符号引用正好和一个符号定义关联起来.</p></li><li><p>重定位:</p><ul><li>任务:编译器和汇编器生成从地址0开始的代码和数据节.</li><li>目的: <ul><li>连接器将符号定义与内存位置进行关联.然后修改这些符号的引用,使它们指向相应的内存位置.</li><li>链接器使用汇编器产生的重定位条目的详细指令,不加甄别地执行这样的重定位.</li></ul></li></ul></li></ul></li></ul><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><ul><li>可重定位目标文件:包含二进制代码和数据,可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件.</li><li>可执行目标文件:包含二进制代码和数据,可以直接复制到内存并执行.</li><li>共享目标文件:特殊的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接</li></ul><hr><ul><li>其中编译器和汇编器生成<strong>可重定位目标文件</strong>和<strong>共享目标文件</strong>,连接器生成<strong>可执行目标文件</strong></li><li>目标模块:一个字节序列<ul><li>目标文件:一个以特定的文件形式存放在磁盘中的目标模块</li></ul></li></ul><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p><img src="ELF_HEADER_FILE.jpg" alt></p><h3 id="elf可重定位目标文件字段说明"><a href="#elf可重定位目标文件字段说明" class="headerlink" title="elf可重定位目标文件字段说明"></a>elf可重定位目标文件字段说明</h3><ul><li>ELF头:<ul><li>生成该文件袋系统的字的大小和字节顺序(小端、大端)(16B)</li><li>帮助连接器语法分析和解释目标文件的信息.<ul><li>ELF头的大小,目标文件类型,机器类型(e.g. x86-64),节头部表的文件偏移,节头部表中条目的大小和数量.</li></ul></li></ul></li><li>节头部表:描述不同节的位置和大小.</li><li>.text:已经编译的程序代码.</li><li>.rodata:只读数据<ul><li>字符常量或者switch的转跳表</li></ul></li><li>.data:已经初始化的全局和静态变量,局部变量保存在栈中.</li><li>.bss:未初始化的全局和静态变量,以及被初始化为0的全局或静态变量.<ul><li>在目标文件中改节不占实际的空间,仅仅是一个占位符.</li><li>目的:提高空间效率,在磁盘中不占空间,在内存中初始化为0</li></ul></li><li>.symtab:符号表,存放程序中定义和引用的函数和全局变量(包括静态变量)的信息.<ul><li>-g编译命令可以得到符号表,还包含局部变量</li><li>.symtab中的符号表不包含局部变量的条目</li></ul></li><li>.rel.text:.text节相关的可重定位信息.<ul><li>当连接器将某个目标文件和其他目标文件组合式,.text节中的代码会被合并,相应的一些指令中引用的操作数地址信息或跳转目标指令信息等可能要被修改.</li><li>一般调用外部函数或者引用全局变量的指令中的地址字段需要修改.</li></ul></li><li>.rel.data:.data节相关的可重定位.<ul><li>当连接器将某个目标文件和其他目标文件组合式,.data节中的代码会被合并,一些全局变量的地址可能被修改.</li></ul></li><li>.debug:调试符号表</li><li>.line:原始c源程序的行号和.text节中机器指令之间的映射.(需要-g选项)</li><li>.strtab:字符串表</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Observer/"/>
      <url>/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Observer/</url>
      
        <content type="html"><![CDATA[<h1 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h1><ul><li>组件协作模式:通过晚期绑定,来实现框架与应用程序之间的松耦合,是两者之间协作时常用的模式<ul><li>Templated Method</li><li>Strategy</li><li>Observer / Event</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件构建过程中,我们需要为某些对象建立一种”通知依赖关系”(类似回调)<ul><li>一个对象(目标对象)的状态发生改变,所有的依赖对象(观察者对象)都将得到通知.</li><li>如果这样的依赖关系过于紧密，软件将不能很好的抵御变化<ul><li>通过面向对象,弱化依赖关系,达到软件的松耦合</li></ul></li></ul></li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>定义对象间一种一对多(变化)的依赖关系,以便当一个对象(Subject)的状态发生改变时,所有依赖于它的对象都得到通知并自动更新.</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="观察者模式UML图.jpg" alt></p><ul><li>其中Subject和Observer是系统中不变的部分</li><li>ConcreteSubject和ConcreteObserver是系统是变化的部分</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li>用进度调更新来举例<br>```cpp<br>//IProgress是一个接口(纯虚类)相当于类图里的Observer<br>class IProgress{<br>public:<br>  virtual void DoProgress(float value)=0;<br>  virtual ~IProgress(){}<br>};</li></ul><p>// ConsoleNotifier是一个观察者,里面有实现的适用于自己的DoProgress.其一定要继承IProgress<br>class ConsoleNotifier : public IProgress {<br>public:<br>    virtual void DoProgress(float value){<br>        cout &lt;&lt; “.”;<br>    }<br>};</p><p>// MainForm是另一个观察者,里面有实现的适用于自己的DoProgress,也是创建Subjct的地方.<br>class MainForm : public Form, public IProgress<br>{<br>    ProgressBar* progressBar;</p><p>public:<br>    void Button1_Click(){<br>        string filePath = txtFilePath-&gt;getText();<br>        int number = atoi(txtFileNumber-&gt;getText().c_str());</p><pre><code>    //ConsoleNotifier观察者的对象    ConsoleNotifier cn;    //构建Subject并把观察者加入进去    FileSplitter splitter(filePath, number);    splitter.addIProgress(this);     splitter.addIProgress(&amp;cn);    //切分文本的功能,里面会调用进度条更新    splitter.split();    //移除观察者    splitter.removeIProgress(this);}virtual void DoProgress(float value){    progressBar-&gt;setValue(value);}</code></pre><p>};</p><p>// 对应类图里的Subject,用于实现对象中不变的部分<br>class Subject<br>{<br>private:<br>    List<iprogress*>  m_iprogressList; // 抽象通知机制，支持多个观察者<br>public:<br>    void addIProgress(IProgress* iprogress){<br>        m_iprogressList.push_back(iprogress);<br>    }</iprogress*></p><pre><code>void removeIProgress(IProgress* iprogress){    m_iprogressList.remove(iprogress);}</code></pre><p>protected:<br>    virtual void onProgress(float value){<br>        List<iprogress*>::iterator itor=m_iprogressList.begin();<br>        while (itor != m_iprogressList.end() )<br>            (*itor)-&gt;DoProgress(value); //更新进度条<br>            itor++;<br>        }<br>    }<br>};</iprogress*></p><p>class FileSplitter : public Subject<br>{<br>private:<br>    string m_filePath;<br>    int m_fileNumber;<br>public:<br>    FileSplitter(const string&amp; filePath, int fileNumber) :<br>        m_filePath(filePath),<br>        m_fileNumber(fileNumber)<br>        {}<br>    }</p><pre><code>void split(){    //1.读取大文件    //2.分批次向小文件中写入    for (int i = 0; i &lt; m_fileNumber; i++){        //...        float progressValue = m_fileNumber;        progressValue = (i + 1) / progressValue;        onProgress(progressValue);//发送通知    }}</code></pre><p>};</p><p>```</p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li>使用面向对象的抽象,Observer模式使得我们可以独立地改变目标与观察者,从而使两者之间的依赖关系达到松耦合</li><li>目标发送通知时,无需指定观察者,通知(可以携带通知信息作为参数)会自动传播.</li><li>观察这自己决定是否订阅通知,目标对象对此一无所知</li><li>Observer模式是基于时间的UI框架中非常常用的设计模式,也是MVC模式的一个重要组成部分.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Singleton/"/>
      <url>/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/DesignPatterns/Singleton/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://www.cnblogs.com/sunchaothu/p/10389842.html" target="_blank" rel="noopener">C++ 单例模式总结与剖析</a></p></blockquote><ul><li>对象性能模式<ul><li>面向对象很好地解决了”抽象”的问题,但会造成一定的代价.(虚函数,继承等)</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常有这样一些特殊的类,必须保证他们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率</li><li>具体运用场景如：<ul><li>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;</li><li>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;</li></ul></li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;</li></ul><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）</li><li>线程安全</li><li>禁止赋值和拷贝</li><li>用户通过接口获取实例：使用 static 类成员函数</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="非线程安全的懒汉模式"><a href="#非线程安全的懒汉模式" class="headerlink" title="非线程安全的懒汉模式"></a>非线程安全的懒汉模式</h2><ul><li><code>懒汉式(Lazy-Initialization)</code>的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。</li></ul><pre><code class="lang-cpp">#include &lt;iostream&gt;// version1:// with problems below:// 1. thread is not safe// 2. memory leakclass Singleton{private:    Singleton();    ~Singleton(){}    Singleton(Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;    static Singleton* m_instance_ptr;public:    static Singleton* get_instance(){        if(m_instance_ptr==nullptr){              m_instance_ptr = new Singleton;        }        return m_instance_ptr;    }};Singleton* Singleton::m_instance_ptr = nullptr;</code></pre><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>线程安全的问题<ul><li>当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来</li><li>解决办法:加锁</li></ul></li><li>内存泄漏<ul><li>注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏</li><li>解决办法：使用共享指针</li></ul></li></ul><h2 id="线程安全、内存安全的懒汉模式-双检查锁"><a href="#线程安全、内存安全的懒汉模式-双检查锁" class="headerlink" title="线程安全、内存安全的懒汉模式(双检查锁)"></a>线程安全、内存安全的懒汉模式(双检查锁)</h2><pre><code class="lang-cpp">#include &lt;memory&gt; // shared_ptr#include &lt;mutex&gt;  // mutex// version 2:// with problems below fixed:// 1. thread is safe now// 2. memory doesn&#39;t leakclass Singleton{public:    typedef std::shared_ptr&lt;Singleton&gt; Ptr;    static Ptr get_instance(){        // &quot;double checked lock&quot;        if(m_instance_ptr==nullptr){            std::lock_guard&lt;std::mutex&gt; lk(m_mutex);            if(m_instance_ptr == nullptr){              m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(new Singleton);            }        }        return m_instance_ptr;    }private:    ~Singleton(){}    Singleton(Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;    static Ptr m_instance_ptr;    static std::mutex m_mutex;};// initialization static variables out of classSingleton::Ptr Singleton::m_instance_ptr = nullptr;std::mutex Singleton::m_mutex;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。</li><li>加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为双检锁(双检查锁)；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。<ul><li><strong>单检查锁</strong>的代价过高,单锁的话线程每次访问都会加锁,但是在创建出来单例以后线程都是读操作,并不需要加锁了.这样导致每次只能一个线程读,造成效率下降.<pre><code class="lang-cpp">Singleton* Singleton::getInstance() {  Lock lock;  if (m_instance == nullptr) {      m_instance = new Singleton();  }  return m_instance;}</code></pre></li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>该方法会由于内存读写reorder导致不安全<ul><li>前提:线程时间片轮转,执行的是汇编指令</li><li>所以对于c++代码在编译器进行优化以后,代码的执行顺序不一定是C++代码的逻辑顺序</li></ul></li><li>可能发生的错误情况<ul><li>在单列赋值的过程中,一般顺序是<code>分配内存空间-&gt;调用构造器-&gt;范围内存地址</code>,但可能编译器优化成<code>分配内存空间-&gt;范围内存地址-&gt;调用构造器</code>,这将可能导致threadB访问的时候直接范围未初始化好的单列,导致错误.</li></ul></li><li>解决方法: atomic</li></ul><hr><ul><li>使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; </li></ul><h2 id="atomic的可跨平台的双检查线程安全的单列模式"><a href="#atomic的可跨平台的双检查线程安全的单列模式" class="headerlink" title="atomic的可跨平台的双检查线程安全的单列模式"></a>atomic的可跨平台的双检查线程安全的单列模式</h2><ul><li>要注意c/c++的标准中volatile无法解决多线程问题,只有msvc这个垃圾方言实现了防止reorder的产生.<ul><li><a href="https://www.cnblogs.com/zhao-zongsheng/p/9092520.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhao-zongsheng/p/9092520.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33074506</a></li></ul></li></ul><pre><code class="lang-cpp">std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() {    Singleton* tmp = m_instance.load(std::memory_order_relaxed);    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence    if (tmp == nullptr) {        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);        tmp = m_instance.load(std::memory_order_relaxed);        if (tmp == nullptr) {            tmp = new Singleton;            std::atomic_thread_fence(std::memory_order_release);//释放内存fence            m_instance.store(tmp, std::memory_order_relaxed);        }    }    return tmp;}</code></pre><h2 id="基于C-11-magic-static的懒汉单例模式"><a href="#基于C-11-magic-static的懒汉单例模式" class="headerlink" title="基于C++11 magic static的懒汉单例模式"></a>基于C++11 magic static的懒汉单例模式</h2><ul><li><p>C++11标准中的Magic Static</p><ul><li>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</li><li>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</li><li>这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</li></ul></li><li><p>static的声明周期(为什么可以这么写?)</p><ul><li>参考:<a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function" target="_blank" rel="noopener">What is the lifetime of a static variable in a C++ function?</a></li><li>The lifetime of function <code>static</code> variables begins the first time the program flow encounters the declaration and it ends at program termination. —- Motti<ul><li>Since C++98 has no reference to multiple threads how this will be behave in a multi-threaded environment is unspecified</li><li>In C++11 statics are initialized in a thread safe way, this is also known as Magic Statics.</li></ul></li><li>Compilers typically use a hidden flag variable to indicate if the local statics have already been initialized, and this flag is checked on every entry to the function. —-Roddy</li></ul></li></ul><pre><code class="lang-cpp">#include &lt;iostream&gt;class Singleton{public:    static Singleton&amp; get_instance(){        static Singleton instance;        return instance;    }private:    Singleton();    ~Singleton();    Singleton(const Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;};</code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。<ul><li>这样做并不好，理由主要是无法避免用户使用delete instance导致对象被提前销毁。还是建议大家使用返回引用的方式。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2021/06/15/Algorithm/Sort/"/>
      <url>/2021/06/15/Algorithm/Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li><p>基本原理:每次将一个待排序的元素按其关键字大小插入到前面已经排好序的子序列中,直到全部记录插入完成.</p></li><li><p>插入排序在待排序列为<strong>正序</strong>时最优,时间复杂度为$O(N)$,在<strong>逆序</strong>时最差,时间复杂度为$O(N^{2})$</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3></li><li>伪代码:</li></ul><pre><code class="lang-md">1.查找出L(i)在L[1...i-1]中的插入位置k.2.将L[k..i-1]中所有元素一次后移一个位置3.将L[i]复制到L(k).</code></pre><ul><li>C++代码</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; InsertSort(vector&lt;int&gt;&amp; nums) {    for(int i = 1; i &lt; nums.size();++i)    {        int t = nums[i];        int j = 0;        for(j = i-1; j &gt;= 0 &amp;&amp; t &lt; nums[j]; --j)            nums[j+1] = nums[j];        nums[j+1] = t;    }    return nums;}</code></pre><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ul><li>直接插入排序中,对于查找插入的位置通过$O(N)$的方法按顺序遍历</li><li>因为前面待插入部分已经排好序,所以利用二分法可以减少元素的比较次数<ul><li>比较次数从$O(N^{2})$降为$O(log_{2}N)$</li></ul></li><li>但是插入的时候仍要在数组平移仍需O(N)的复杂度</li><li>所以,折半插入排序的复杂度仍为$O(N^{2})$</li></ul><hr><ul><li>C++代码</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; HalfInsertSort(vector&lt;int&gt;&amp; nums) {    for(int i = 1; i &lt; nums.size();++i)    {        int t = nums[i];        int lo = 0, hi =i-1;        while(lo &lt;= hi)        {            int mid = lo + (hi-lo)/2;            if(nums[i] &gt; nums[mid]) lo = mid+1;            else if(nums[i] &lt;= nums[mid])   hi = mid-1;        }        for(int j = i-1;j &gt;= lo;--j)            nums[j+1] = nums[j];        nums[lo] = t;    }    return nums;}</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>又名<strong>缩小增量排序</strong>:</li><li>排序过程:<ul><li>先取一个小于N的步长d1,把表中的全部记录分成d1组,所有距离为d1的倍数的记录放在同一组,在各组内进行直接插入排序.</li><li>然后取第二个步长d2 &lt; d1,重复上述过程</li><li>直到所取到的dt=1,即所有记录已放在同一组,再进行直接插入排序,由于此时已经具有较好的局部有序性,故可以很快得到最终结果.</li></ul></li><li>平均时间复杂度:$O(N^{1.3})$</li><li>最坏时间复杂度”$O(N^{2}$</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; ShellSort(vector&lt;int&gt;&amp; nums) {    for(int s = nums.size()/2; s &gt; 0; s/=2)    {        for(int i = s; i &lt; nums.size();++i)        {            int t = nums[i];            int j;            for(j = i-s; j &gt;=0 &amp;&amp; t &lt; nums[j] ; j-=s)            {                nums[j+s] = nums[j];            }            nums[j+s] = t;        }    }    return nums;}</code></pre><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul><li>算法原理:根据序列中两个元素关键字的比较结果来对换这个记录在序列中的位置,以此来达到序列的有序.<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3></li><li><p>基本思想:每次两两比较相邻的元素的值,若为逆序则交换它们,知道序列比较完.以此冒泡排序可以确定一个元素的位置.最多n-1趟冒泡就能把所有元素排好序.</p></li><li><p>朴素冒泡排序</p></li></ul><pre><code class="lang-cpp">vector&lt;int&gt; BubbleSort(vector&lt;int&gt;&amp; nums) {    int n = nums.size();    bool  flag = false;    for(int i = 0; i &lt; n; ++i)    {         for(int j = 1; j &lt; n-i; ++j)        {            if(nums[j] &lt; nums[j-1])            {                swap(nums[j-1],nums[j]);                flag = false;            }        }        if(flag) break;    }    return nums;}</code></pre><ul><li>优化<ul><li>每次冒泡时判断是否发生了交换,如果未发生交换说明已经拍好序,直接退出</li></ul></li></ul><pre><code class="lang-cpp">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for(int i = 0; i &lt; n; ++i)        {             bool flag = false; //记录本次冒泡是否已经排好序(即是否发生交换)            for(int j = 1; j &lt; n-i; ++j)            {                if(nums[j] &lt; nums[j-1])                {                    swap(nums[j-1],nums[j]);                    flag = true;                }            }            if(!flag) break;        }        return nums;    }</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="朴素快速排序"><a href="#朴素快速排序" class="headerlink" title="朴素快速排序"></a>朴素快速排序</h4><pre><code class="lang-cpp">int Partition(vector&lt;int&gt;&amp; nums,int i,int j){    int pviot = nums[i];    while(i &lt; j)    {        for(;i &lt; j &amp;&amp; nums[j] &gt;= pviot; --j);        nums[i] = nums[j];        for(;i &lt; j &amp;&amp; nums[i] &lt; pviot; ++i);        nums[j] = nums[i];    }    nums[i] = pviot;    return i;}void quickSort(vector&lt;int&gt;&amp; nums,int i ,int j){    if(i &lt; j)    {        int pviotPos = Partition(nums,i,j);        quickSort(nums,i,pviotPos-1);        quickSort(nums,pviotPos+1,j);    }}</code></pre><h4 id="非递归朴素快排-用栈"><a href="#非递归朴素快排-用栈" class="headerlink" title="非递归朴素快排(用栈)"></a>非递归朴素快排(用栈)</h4><ul><li><p>利用栈模拟快排</p><pre><code class="lang-cpp">void nrQuickSort(vector&lt;int&gt;&amp; nums,int i,int j){  stack&lt;int&gt; s;  s.push(i);  s.push(j);  while(!s.empty())  {      //框定范围      int right = s.top();      s.pop();      int left = s.top();      s.pop();      //切分      int pviot = nums[left];      int lo = left;      int hi = right;      while(lo &lt; hi)      {          for(;lo &lt; hi &amp;&amp; nums[hi] &gt;= pviot; --hi);          nums[lo] = nums[hi];          for(;lo &lt; hi &amp;&amp; nums[lo] &lt; pviot; ++lo);          nums[hi] = nums[lo];      }      nums[lo] = pviot;      int pviotPos = lo;      //模拟递归      if( pviotPos - left &gt; 1)      {          s.push(left);          s.push(pviotPos-1);      }      if(right - pviotPos &gt; 1)      {          s.push(pviotPos+1);          s.push(right);      }  }}</code></pre></li></ul><h4 id="非递归原地快排"><a href="#非递归原地快排" class="headerlink" title="非递归原地快排"></a>非递归原地快排</h4><ul><li>待补<blockquote><p>可参考<br><a href="https://www.zhihu.com/question/48406747" target="_blank" rel="noopener">如何用非递归、不用栈的方法，实现原位（in-place）的快速排序？</a><br><a href="https://stackoverflow.com/questions/29987995/creating-quicksort-without-recursion-and-stack" target="_blank" rel="noopener">Creating quicksort without recursion and stack</a><br><a href="https://stackoverflow.com/questions/55008384/can-quicksort-be-implemented-in-c-without-stack-and-recursion/55010206" target="_blank" rel="noopener">Can quicksort be implemented in C without stack and recursion?</a></p></blockquote></li></ul><h4 id="快排优化-优化哨兵选择-元素聚集-熵最优排序-优化小数组-gt-三数取中-三向切分-插排-gt-快速三向切分"><a href="#快排优化-优化哨兵选择-元素聚集-熵最优排序-优化小数组-gt-三数取中-三向切分-插排-gt-快速三向切分" class="headerlink" title="快排优化:优化哨兵选择+元素聚集(熵最优排序)+优化小数组-&gt; 三数取中+三向切分+插排 -&gt; 快速三向切分"></a>快排优化:优化哨兵选择+元素聚集(熵最优排序)+优化小数组-&gt; 三数取中+三向切分+插排 -&gt; 快速三向切分</h4><blockquote><p>参考:算法第四版<br>参考:<a href="https://blog.staynoob.cn/post/2016/05/insertion-shell-merge-quick-sort-algorithm-3/" target="_blank" rel="noopener">聊聊4种主流排序算法(番外篇):快速排序的优化历程</a><br>参考:<a href="https://www.jianshu.com/p/671981540727" target="_blank" rel="noopener">快速排序及其优化</a></p><ul><li>优化小数组<ul><li>对于小数组,快速排序比插入排序慢<ul><li>原因:因为递归存在开销</li></ul></li><li><strong>一般在元素在5~15之间的数组大小适合用插入排序</strong></li></ul></li></ul></blockquote><ul><li><p>优化哨兵选择</p><ul><li>使用子数组的一小部分元素的中位数来切分数组<ul><li>这样可以避免所选取的哨兵处于极端情况,当哨兵是数组中位数的时候最优.</li><li>但是计算一部分元素的中位数会存在开销</li><li><strong>一般三数取中效果最好</strong></li></ul></li></ul></li><li><p>元素聚集</p><ul><li>通常实际应用中数组中会存在大量相同的元素,可以利用<code>荷兰旗问题</code>中的思想,将数组划分为小于等于和大于哨兵的三部分</li><li>这种方法是三向切分</li></ul></li><li><p>算法第四版中的方法</p><ul><li>当子数组大小 &lt;= 8 时，切换到插入排序</li><li>当子数组大小 &lt;= 40 时，使用三取样切分（median-of-3）选择切分元素</li><li>当子数组大小 &gt; 40 时，使用 Tukey’s ninther 方法选择切分元素(在)</li><li>使用Bentley-McIlroy的三向切分</li></ul></li></ul><h5 id="朴素快速三向切分"><a href="#朴素快速三向切分" class="headerlink" title="朴素快速三向切分"></a>朴素快速三向切分</h5><p><img src="Quick3Way.jpg" alt></p><pre><code class="lang-cpp">// 三数取中+朴素三向切分+插排void InsertSort(vector&lt;int&gt;&amp; nums,int i,int j){    for(int lo = i+1; lo &lt;= j; ++lo)    {        int t = nums[lo],hi;        for(hi = lo-1; hi &gt;=i ; --hi)        {            if(nums[hi] &gt; t)                nums[hi+1] = nums[hi];            else                break;        }        nums[hi+1] = t;    }}int median3(vector&lt;int&gt;&amp; nums,int i,int j,int k){    return  nums[i] &lt; nums[j] ?            (nums[j] &lt; nums[k] ?  j : (nums[i] &lt; nums[k] ?  k :  i)) :            (nums[j] &gt; nums[k] ?  j : (nums[i] &lt; nums[k] ?  i :  k)) ;    }void quick3way(vector&lt;int&gt;&amp; nums,int i ,int j){    if(i &lt; j)    {        if( j-i+1 &lt;= 8)        {            HalfInsertSort(nums,i,j);            return;        }        int pviotPos = median3(nums,i,i+(j-i)/2,j);        swap(nums[i],nums[pviotPos]);        int pviot = nums[i];        int lo = i, hi = j, p = i+1;//[i...lo)  &lt;pviot                                    //[lo...hi]  =pviot                                    //(hi...j]  &gt;pviot         while(p &lt;= hi)        {            if(nums[p] &gt; pviot)            {                swap(nums[hi--],nums[p]);            }            else if(nums[p] &lt; pviot)            {                swap(nums[lo++],nums[p++]);            }            else            {                ++p;            }        }        quick3way(nums,i,lo-1);        quick3way(nums,hi+1,j);    }}</code></pre><h5 id="Bentley-McIlroy快速三向切分"><a href="#Bentley-McIlroy快速三向切分" class="headerlink" title="Bentley-McIlroy快速三向切分"></a>Bentley-McIlroy快速三向切分</h5><ul><li>在朴素三向切分中含有大量的元素对换<ul><li>只有在元素等于pviot时才不会发生对换</li></ul></li><li>Bentley-McIlroy将元素划分为4个部分，只交换相等的元素,具体思路如下:</li></ul><p><img src="BM_Qucik3Way.jpg" alt></p><pre><code class="lang-cpp">// Bentley-McIlroy快速三向切分 伪代码1. 将数组序列划分为四部分，如图所示    nums[lo...p] == pviot    nums[q...hi] == pviot    nums[p+1...i-1] &lt; pviot    nums[j+1...q-1] &gt; pviot2. 所以,初始化下列参数    i = lo,    p = lo+1,    j = hi+1,    q = hi;    pviot = nums[lo];3. 循环处理    3.1 从左向右寻找 &gt;= pviot的元素    3.2 从右向左寻找 &lt;= pviot的元素    3.3 处理循环结束条件以及边界情况        3.3.1 当 i == j 时 判断该元素是否 == pviot,做特殊处理        3.3.2 当 i &gt;=j 时 退出循环    3.4 将左边&gt;=pviot的nums[i]与右边&lt;=pviot的nums[j]交换,维护&gt;pviot和&lt;pviot的区间    3.5 判断左边和右边是否 == pviot ,实则与相应的nums[p]和nums[q]交换维护==pviot的区间4. 将 == | &lt; | &gt; | == 的区间转换为&lt; | == | &gt; 的区间5. 递归处理</code></pre><pre><code class="lang-cpp">// 最终版:三数取中 or Tukey&#39;s ninter + Bentley-McIlroy三向切分 + 折半插排void HalfInsertSort(vector&lt;int&gt;&amp; nums,int lo,int hi){    for(int i = lo+1;i &lt;= hi; ++i)    {        int t = nums[i];        int j = 0, k = i-1;        while(j &lt;= k)        {            int mid = j + (k-j)/2;            if(nums[mid] &gt;= t)                k = mid-1;            else if(nums[mid] &lt; t)                j= mid+1;        }        for(int m = i-1;m &gt;= j; --m)            nums[m+1] = nums[m];        nums[j] = t;    }}int Mid3(vector&lt;int&gt;&amp; nums,int i ,int j ,int k){    return nums[i] &gt; nums[j] ? // i &lt; j &gt; k            nums[j] &gt; nums[k] ? j : (nums[i] &gt; nums[k] ? k : i):            nums[j] &lt; nums[k] ? j : nums[i] &gt; nums[k] ? i : k;}void BMQuick3Way(vector&lt;int&gt;&amp; nums,int i,int j){    int n = j-i+1;    if(n &lt;= 8)    {        HalfInsertSort(nums,i,j);        return;    }    int pviotpos;    int mid = i + (j-i)/2;    if(n &lt;= 40)        pviotpos = Mid3(nums,i,mid,j);    else    {        int epos = n/8;         int mid1 =  Mid3(nums,i,i+epos,i+epos+epos);        int mid2 =  Mid3(nums,mid-epos,mid,mid+epos);        int mid3 =  Mid3(nums,j-epos-epos,j-epos,j);        pviotpos =  Mid3(nums,mid1,mid2,mid3);    }    swap(nums[pviotpos],nums[i]);    int p = i,q = j+1;    int lo = i+1,hi = j;    int pviot = nums[i];    while(true)    {        for(;nums[lo] &lt; pviot; ++lo);        for(;nums[hi] &gt; pviot; --hi);        if(lo == hi &amp;&amp; nums[lo] == pviot)            swap(nums[++p],nums[lo]);        if( lo &gt;= hi)            break;        swap(nums[lo],nums[hi]);        if(nums[lo] == pviot)            swap(nums[++p],nums[lo++]);        if(nums[hi] == pviot)            swap(nums[--q],nums[hi--]);    }    lo = hi+1;//这步操作的原因是,当边界条件是nums[lo] == nums[hi] == pviot的时,lo和hi指向同一个位置 | ---- lo == hi | ------ |                //其他情况则  | ---- hi |lo --- |                //所以这一步用于保证lo和hi的相对位置,统一操作                    for(int k = i ; k &lt;= p; ++k)        swap(nums[k],nums[hi--]);    for(int k = j ; k &gt;= q; --k)        swap(nums[k],nums[lo++]);    BMQuick3Way(nums,i,hi);    BMQuick3Way(nums,lo,j);}</code></pre><h4 id="非递归三向切分"><a href="#非递归三向切分" class="headerlink" title="非递归三向切分"></a>非递归三向切分</h4><ul><li>待补</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>基本思想:每一趟(如第<code>i</code>趟)在后面<code>n-i+1</code>个待排元素中选取关键字最小的元素,作为有序子序列的第<code>i</code>个元素,知道<code>n-1</code>趟做完,待排元素只剩下1个,就不用选了.</li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ul><li>算法:</li></ul><p><img src="Sort/简单选择排序.jpg" alt></p><pre><code class="lang-cpp">vector&lt;int&gt; SelectSort(vector&lt;int&gt;&amp; nums) {    for(int i = 0; i &lt; nums.size();++i)    {        int pos = i;        for(int j = i +1 ; j &lt; nums.size();++j)        {            if(nums[j] &lt; nums[pos])                pos = j;        }        swap(nums[i],nums[pos]);    }    return nums;}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>二叉堆的定义:<blockquote><p>n个关键字序列L[1…n]称为堆 &lt;==&gt;</p></blockquote></li></ul><blockquote><p>1) L(i) &gt;= L(2i) &amp;&amp; L(i) &gt;= L(2i+1)  或者 //大顶堆<br>2) L(i) &lt;= L(2i) &amp;&amp; L(i) &lt;= L(2i+1)       //小顶堆</p></blockquote><h4 id="堆的建立-堆的元素插入"><a href="#堆的建立-堆的元素插入" class="headerlink" title="堆的建立(堆的元素插入)"></a>堆的建立(堆的元素插入)</h4><ul><li>将新元素加入到数组末尾,增加堆的大小并让这个新元素上浮(Swim)到合适的位置<h4 id="删除最大元素-堆的排序"><a href="#删除最大元素-堆的排序" class="headerlink" title="删除最大元素(堆的排序)"></a>删除最大元素(堆的排序)</h4></li><li>删除堆顶的元素(大根堆的最大元素)并将数组的最后一个元素放到堆顶,建小堆的大小并让这个元素下沉到合适的位置</li></ul><h4 id="堆排实现"><a href="#堆排实现" class="headerlink" title="堆排实现"></a>堆排实现</h4><pre><code class="lang-cpp">void swim();//向上调整,用于堆的插入和构建void sink(vector&lt;int&gt;&amp; nums,int len,int k)//向下调整,用于堆的删除和堆排序,无序数组构建二叉堆{    //从1开始的二叉树, 左孩子2 *k ,右孩子 2*k +1    ///从0开始的二叉树, 左孩子2 *k+1 ,右孩子 2*k +2    for(int i = 2 *k+1 ; i &lt; len; i = 2*i+1)    {        if(i+1 &lt; len &amp;&amp; nums[i] &lt; nums[i+1])            ++i;        if(nums[i] &gt; nums[k])        {            swap(nums[i],nums[k]);            k = i;        }        else            break;    }}void buildHeap();void heapInsert();void heapDelete();void heapSort(vector&lt;int&gt;&amp; nums,int n){    //从1开始的二叉树, n/2为最后一个分支结点    //从0开始的二叉树, (n-1)/2为最后一个分支结点    for(int i = (n-1)/2; i &gt;= 0; --i)        sink(nums,n,i);    for(int i = n-1; i &gt; 0; --i)    {        swap(nums[0],nums[i]);        sink(nums,i,0);    }}</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="递归归并排序"><a href="#递归归并排序" class="headerlink" title="递归归并排序"></a>递归归并排序</h3><pre><code class="lang-cpp">void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v(j-i+1,0);    int cnt = 0;    int lo = i,hi = mid+1;    while(lo &lt;= mid &amp;&amp; hi &lt;= j)    {        if(nums[lo] &lt; nums[hi])            v[cnt++] = nums[lo++];        else            v[cnt++] = nums[hi++];    }    while(lo &lt;= mid)        v[cnt++] = nums[lo++];    while(hi &lt;= j)        v[cnt++] = nums[hi++];    for(int k = 0 ; k &lt; cnt; ++k)    {        nums[i+k] = v[k];    }}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    if(i &lt; j)    {        int mid = i + (j-i)/2;        MergeSort(nums,i,mid);        MergeSort(nums,mid+1,j);        Merge(nums,i,mid,j);    }}</code></pre><h3 id="非递归归并排序"><a href="#非递归归并排序" class="headerlink" title="非递归归并排序"></a>非递归归并排序</h3><pre><code class="lang-cpp">void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v(j-i+1,0);    int cnt = 0;    int lo = i,hi = mid+1;    while(lo &lt;= mid &amp;&amp; hi &lt;= j)    {        if(nums[lo] &lt; nums[hi])            v[cnt++] = nums[lo++];        else            v[cnt++] = nums[hi++];    }    while(lo &lt;= mid)        v[cnt++] = nums[lo++];    while(hi &lt;= j)        v[cnt++] = nums[hi++];    for(int k = 0 ; k &lt; cnt; ++k)    {        nums[i+k] = v[k];    }}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    int  n = nums.size();    for(int sz = 1; sz &lt; n; sz += sz)//步长    {        for(int i = 0; i + sz &lt; n; i += 2*sz)        {            Merge(nums,i,i+sz-1,min(i+sz+sz-1,n-1));        }    }}</code></pre><h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><blockquote><p>参考:<a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/" target="_blank" rel="noopener">复习基础排序算法（Java）</a></p></blockquote><ul><li>特点:<ul><li>一个数该放在哪里，是由这个数本身的大小决定的，它不需要经过比较。也可以认为是哈希的思想：由数值映射地址。</li><li>因此这三种算法一定需要额外的空间才能完成排序任务，时间复杂度可以提升到O(N)，但适用场景不多，主要是因为使用这三种排序一定要保证输入数组的每个元素都在一个合理的范围内<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html" target="_blank" rel="noopener">一文弄懂计数排序算法！</a></p></blockquote></li></ul></li></ul><h4 id="基础版-时间复杂度与元素值有关-不稳定排序"><a href="#基础版-时间复杂度与元素值有关-不稳定排序" class="headerlink" title="基础版(时间复杂度与元素值有关,不稳定排序)"></a>基础版(时间复杂度与元素值有关,不稳定排序)</h4><ul><li>找出原数组中元素值最大的，记为max,最小值为min</li><li>创建一个新数组count，其长度是max-min+1，其元素默认值都为0</li><li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li><li>遍历count数组，找出其中元素值大于0的元素,并输出</li></ul><pre><code class="lang-cpp">// 参考代码public int[] countSort2(int[] A) {    // 找出数组A中的最大值、最小值    int max = Integer.MIN_VALUE;    int min = Integer.MAX_VALUE;    for (int num : A) {        max = Math.max(max, num);        min = Math.min(min, num);    }    // 初始化计数数组count    // 长度为最大值减最小值加1    int[] count = new int[max-min+1];    // 对计数数组各元素赋值    for (int num : A) {        // A中的元素要减去最小值，再作为新索引        count[num-min]++;    }    // 创建结果数组    int[] result = new int[A.length];    // 创建结果数组的起始索引    int index = 0;    // 遍历计数数组，将计数数组的索引填充到结果数组中    for (int i=0; i&lt;count.length; i++) {        while (count[i]&gt;0) {            // 再将减去的最小值补上            result[index++] = i+min;            count[i]--;        }    }    // 返回结果数组    return result;}</code></pre><h4 id="前缀和版（时间复杂度为N-稳定排序）"><a href="#前缀和版（时间复杂度为N-稳定排序）" class="headerlink" title="前缀和版（时间复杂度为N,稳定排序）"></a>前缀和版（时间复杂度为N,稳定排序）</h4><ul><li>找出数组中的最大值<code>max</code>、最小值<code>min</code>。</li><li>创建一个新数组<code>count</code>，其长度是<code>max-min</code>加<code>1</code>，其元素默认值都为<code>0</code>。</li><li>遍历原数组中的元素，以原数组中的元素作为<code>count</code>数组的索引，以原数组中的元素出现次数作为<code>count</code>数组的元素值。</li><li>对<code>count</code>数组变形，新元素的值是前面元素累加之和的值，即<code>count[i+1] = count[i+1] + count[i]</code>;</li><li>创建结果数组<code>result</code>，长度和原始数组一样。</li><li>遍历<code>数组元素</code>，<code>count[A[j]-min]-1为A[j]</code>在结果数组result中的位置,然后对<code>count[A[j]-min]</code>自减<code>1</code></li></ul><hr><ul><li>要想保证稳定排序,则最后一步时逆序遍历或者在求前缀和nums[i]的对应为为count[1…i-1]的前缀和</li></ul><pre><code class="lang-cpp">//逆序遍历public int[] countSort4(int[] A) {    // 找出数组A中的最大值、最小值    int max = Integer.MIN_VALUE;    int min = Integer.MAX_VALUE;    for (int num : A) {        max = Math.max(max, num);        min = Math.min(min, num);    }    // 初始化计数数组count    // 长度为最大值减最小值加1    int[] count = new int[max-min+1];    // 对计数数组各元素赋值    for (int num : A) {        // A中的元素要减去最小值，再作为新索引        count[num-min]++;    }    // 计数数组变形，新元素的值是前面元素累加之和的值    for (int i=1; i&lt;count.length; i++) {        count[i] += count[i-1];    }    // 创建结果数组    int[] result = new int[A.length];    // 遍历A中的元素，填充到结果数组中去，从后往前遍历    for (int j=A.length-1; j&gt;=0; j--) {        result[count[A[j]-min]-1] = A[j];        count[A[j]-min]--;    }    return result;}</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul><li>计数排序是基于关键字<code>各位(比如个十百千)</code>的大小进行排序,是一种借助多关键字排序的思想对但逻辑关键字排序的方法.</li><li>MSD(最高位优先法):按关键字位权重<code>递减</code>依次逐层划分为若干更小的子序列,最后将所有子序列依次链接成一个有序序列.</li><li>LSD(最低位优先法):按关键字位权重<code>递增</code>依次逐层划分为若干更小的子序列,最后将所有子序列依次链接成一个有序序列.</li></ul><hr><ul><li>分配操作<ul><li>创建n个空队列,每个队列枚举某个关键字的所有可能并排好序,然后依次遍历元素中当前考察关键字的大小,放入对应的队列中.</li></ul></li><li>收集操作<ul><li>将各个队列中的结点依次首尾链接,得到新的序列.</li></ul></li><li>在对每个关键字进行了分配和收集操作后将得到最终有序的数组.</li></ul><pre><code class="lang-cpp">//年前时瞎写的代码,没验证准确性#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#define SIZE 10void RadixSort(int a[]);void Traverse(int a[],int m);int temp[10][100];//临时数组（桶数组）int count[100] = {0};//桶中长度int main(void){    int a[SIZE];    srand(time(0));    int i;    for(i=0;i&lt;SIZE;i++)    {        a[i] = rand()%1000+1;    }    Traverse(a,10);    RadixSort(a);    Traverse(a,10);}int GetDigit(int a,int d)//数a，获取d位上的数{    int m[]={1,1,10,100};    return ((a/m[d])%10);}void Traverse(int a[],int m){    int i;    for(i=0;i&lt;m;i++)    {        printf(&quot;%d &quot;,a[i]);    }    printf(&quot;\n&quot;);}void RadixSort(int a[]){    int d;    int t;    int j=0;    int k=0;    int i;    int l;    for(d=1;d&lt;=3;d++)    {            for(i=0;i&lt;10;i++)        {        count[i] = -1;        }        k=0;        for( i = 0; i&lt;SIZE; i++)        {                t = GetDigit(a[i],d);            temp[t][++count[t]] = a[i];        }        for(i=0;i&lt;SIZE;i++)        {            for(l=0;l&lt;= count[i];l++)            {                a[k++] = temp[i][l];            }        }        Traverse(a,SIZE);    }}</code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li>原理：将数组按照步长放在不同的桶里，桶的数量根据数组长度和步长确定，数组全部入桶之后，每个桶内进行排序，按顺序将所有桶的数据合并。</li></ul><pre><code class="lang-java">public class Solution {    // 桶排序    // 1 &lt;= A.length &lt;= 10000    // -50000 &lt;= A[i] &lt;= 50000    // 10_0000    private static final int OFFSET = 50000;    public int[] sortArray(int[] nums) {        int len = nums.length;        // 第 1 步：将数据转换为 [0, 10_0000] 区间里的数        for (int i = 0; i &lt; len; i++) {            nums[i] += OFFSET;        }        // 第 2 步：观察数据，设置桶的个数        // 步长：步长如果设置成 10 会超出内存限制        int step = 1000;        // 桶的个数        int bucketLen = 10_0000 / step;        int[][] temp = new int[bucketLen + 1][len];        int[] next = new int[bucketLen + 1];        // 第 3 步：分桶        for (int num : nums) {            int bucketIndex = num / step;            temp[bucketIndex][next[bucketIndex]] = num;            next[bucketIndex]++;        }        // 第 4 步：对于每个桶执行插入排序        for (int i = 0; i &lt; bucketLen + 1; i++) {            insertionSort(temp[i], next[i] - 1);        }        // 第 5 步：从桶里依次取出来        int[] res = new int[len];        int index = 0;        for (int i = 0; i &lt; bucketLen + 1; i++) {            int curLen = next[i];            for (int j = 0; j &lt; curLen; j++) {                res[index] = temp[i][j] - OFFSET;                index++;            }        }        return res;    }    private void insertionSort(int[] arr, int endIndex) {        for (int i = 1; i &lt;= endIndex; i++) {            int temp = arr[i];            int j = i;            while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) {                arr[j] = arr[j - 1];                j--;            }            arr[j] = temp;        }    }}</code></pre><h1 id="内部排序性能分析"><a href="#内部排序性能分析" class="headerlink" title="内部排序性能分析"></a>内部排序性能分析</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><blockquote><ul><li>来自：<a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">wikipedia . 排序算法</a></li></ul></blockquote><ul><li>稳定性:排序过程中,相同大小的元素值在排序过后是扔保持相对位置.</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Best</th><th>Average</th><th>Worst</th><th>Memory</th><th>Stable</th><th>Method</th><th>Array</th><th>LinkList </th></tr></thead><tbody><tr><td>插入排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Insertion</td><td>$\surd$</td><td>$\surd$ </td></tr><tr><td>折半插入排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Insertion</td><td>$\surd$</td><td>$\surd$ </td></tr><tr><td>希尔排序</td><td>$nlog_{2}{n}$</td><td>$n^{1.3}$</td><td>$n^{2[1]}$</td><td>1</td><td>No</td><td>Insertion</td><td>$\surd$</td><td>$X$ </td></tr><tr><td>冒泡排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Exchanging</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td>快速排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$n^{2}$</td><td>$log_{2}{n}^{[2]}$</td><td>NO</td><td>Exchanging</td><td>$\surd$</td><td>$X^{[3]}$ </td></tr><tr><td>(简单)选择排序</td><td>$n^{2}$</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>$NO^{[4]}$</td><td>Selection</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td></td><td>堆排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>1</td><td>NO</td><td>Selection</td><td>$\surd$</td><td>$X$ </td></tr><tr><td></td><td>归并排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$n^{[5]}$</td><td>YES</td><td>Merging</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td></td><td>计数排序</td><td></td><td>$n + r^{[7]}$</td><td>$n + r$</td><td>$n + r$</td><td>YES</td><td>Non-comparison</td><td>$\surd$</td><td>$?^{[6]}$</td><td></td></tr><tr><td></td><td>基数排序</td><td></td><td>$d(n+r)^{[8]}$</td><td>$d(n+r)$</td><td>$r$</td><td>YES</td><td>Non-comparison</td><td>$\surd$</td><td>$?^{[6]}$</td></tr><tr><td></td><td>桶排序</td><td></td></tr></tbody></table></div><ul><li>[1]希尔排序的最差情况由增量序列决定,使用{n/2,n/4,…,1}的最差情况为$O(n^{2}$)</li><li>[2]快速排序的一般版本为递归实现,也可以实现非递归版本,此时空间复杂度为$O(1)$</li><li>[3]快速排序一般不用于链表排序,但是强行写也不是不行</li><li>[4]普通选择排序是不稳定的,但是如果使用新数组存储排序结果或者对链表进行排序则是稳定的<ul><li>使用新数组会导致时间复杂度为O(n)</li><li>对链表使用选择排序,每次选择最小的结点,并用头插法重新加入链表中.</li></ul></li><li>[5]对于归并排序递归和非递归都需要O(n)的空间复杂度,但是对于递归来说还需要$log_{2}{n}$的递归栈<ul><li>在提一点默认采用2路归并,对于k路归并时间复杂度为$log_{k}{n}$</li></ul></li><li>[6]实现肯定能实现但是推不推荐就不知道了</li><li>[7]这里的r是数组中的元素范围，因为计数排序需要2遍,第一遍遍历数组加入当每个桶(每个桶代表1个元素值)中,第二遍这个元素范围.</li><li>[8]r表示关键字的范围,用于元素的分配,d为需要收集分配的次数.</li></ul><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><div class="table-container"><table><thead><tr><th>Name</th><th>最好情况</th><th>最差情况</th><th>其他说明 </th></tr></thead><tbody><tr><td>插入排序</td><td>数组已经有序</td><td>数组逆序</td><td>比较次数$O(n^{2})$ </td></tr><tr><td>折半插入排序</td><td>数组已经有序</td><td>数组逆序</td><td>比较次数$O(nlog_{2}{n})$ </td></tr><tr><td>希尔排序</td><td>数组已经有序</td><td>每个步长下都是逆序</td><td></td></tr><tr><td>冒泡排序</td><td>数组已经有序</td><td>数组逆序</td><td></td></tr><tr><td>$快速排序^{[1]}$</td><td>每次划分的区域左右元素数量相等</td><td>每次快排后哨兵在最左或最右导致划分区间最大程度不对称 -&gt; 数组有序</td><td></td></tr><tr><td>(简答)选择排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>堆排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>归并排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>计数排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>基数排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>桶排序</td><td></td><td></td><td>与数组元素排列无关</td></tr></tbody></table></div><ul><li>[1] 假设快速排序每次选取最左边的元素为哨兵</li></ul><h2 id="总体小结"><a href="#总体小结" class="headerlink" title="总体小结"></a>总体小结</h2><ul><li>何时选择何种排序方法：<ul><li>待排序的记录数目n较小时，可采用插入排序和简单选择排序</li><li>若待排序记录基本有序，则采用直接插入排序或冒泡排序</li><li>n很大且关键字的位数少，采用链式基数排序较好</li><li>若n较大，则采用时间复杂度为nlogn的算法，快速排序，堆排序，归并排序</li><li>内部排序方法最好：快速排序</li><li>外部排序方法最好：归并排序</li></ul></li></ul><h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="归并排序-最合适"><a href="#归并排序-最合适" class="headerlink" title="归并排序(最合适)"></a>归并排序(最合适)</h2><h3 id="自顶向下的链表归并排序"><a href="#自顶向下的链表归并排序" class="headerlink" title="自顶向下的链表归并排序"></a>自顶向下的链表归并排序</h3><ul><li>时间复杂度:O($nlog_{2}{n}$)</li><li>空间复杂度:O($log_{2}{n}$) 递归栈</li></ul><pre><code class="lang-cpp">//伪代码1.将链表从中间断开,设断开的两个链表的头结点为left和right2.递归拆分left链表和right链表.直到无法继续拆分3.将两个链表merge.</code></pre><pre><code class="lang-cpp">ListNode* sortList(ListNode* head) {    if(!head || !head-&gt;next)  return head;    ListNode* middle = findMiddle(head);    ListNode* left = sortList(head);    ListNode* right = sortList(middle);    return merge(left,right);}ListNode* findMiddle(ListNode* head){    ListNode* root = new ListNode(-1);    root-&gt;next = head;    ListNode* slow = root;    ListNode* fast = root;    while(fast &amp;&amp; fast-&gt;next)    {        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    }    ListNode* middle = slow-&gt;next;    slow-&gt;next = nullptr;    root-&gt;next = nullptr;    delete root;    return middle;}ListNode* merge(ListNode* l ,ListNode* r){    ListNode* root = new ListNode(-1);    ListNode* p = root;    while(l &amp;&amp; r)    {        if(l-&gt;val &gt; r-&gt;val)        {            p-&gt;next = r;            r = r-&gt;next;        }        else        {            p-&gt;next = l;            l = l-&gt;next;        }        p = p-&gt;next;    }    if(l)        p-&gt;next = l;    if(r)        p-&gt;next = r;    p = root-&gt;next;    root-&gt;next = nullptr;    delete root;    return p;}</code></pre><h3 id="自底向上的链表归并排序"><a href="#自底向上的链表归并排序" class="headerlink" title="自底向上的链表归并排序"></a>自底向上的链表归并排序</h3><pre><code class="lang-cpp">ListNode* sortList(ListNode* head) {    //计算链表长度    int len = 0;    ListNode* p = head;    while(p)    {        ++len;        p = p-&gt;next;    }    ListNode* root = new ListNode(0,head);//哑结点    for(int s = 1; s &lt; len; s &lt;&lt;= 1)//步长[1,2,4,...]    {        ListNode* prev = root,*curr = prev-&gt;next;//用于切分和定位结点        while(curr)        {            ListNode* left = nullptr;            left = curr;            for(int i = 1; i &lt; s &amp;&amp; curr != nullptr; ++i)                curr = curr-&gt;next;            ListNode* right = nullptr;            if(curr)            {                right = curr-&gt;next;                curr-&gt;next = nullptr;                curr = right;            }            for(int i = 1; i &lt; s &amp;&amp; curr != nullptr; ++i)                curr = curr-&gt;next;            if(curr)            {                ListNode* next = curr-&gt;next;                curr-&gt;next = nullptr;                curr = next;            }            prev-&gt;next = merge(left,right);            while(prev-&gt;next)                prev = prev-&gt;next;        }    }    return root-&gt;next;}ListNode* merge(ListNode* l ,ListNode* r){    ListNode* root = new ListNode(-1);    ListNode* p = root;    while(l &amp;&amp; r)    {        if(l-&gt;val &gt; r-&gt;val)        {            p-&gt;next = r;            r = r-&gt;next;        }        else        {            p-&gt;next = l;            l = l-&gt;next;        }        p = p-&gt;next;    }    if(l)        p-&gt;next = l;    if(r)        p-&gt;next = r;    p = root-&gt;next;    root-&gt;next = nullptr;    delete root;    return p;}</code></pre><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="非交换值-原地"><a href="#非交换值-原地" class="headerlink" title="非交换值 + 原地"></a>非交换值 + 原地</h3><pre><code class="lang-cpp">ListNode* quickSort(ListNode* head,ListNode* tail)//排序[head,tail){    if(head == tail ||  head-&gt;next == tail) return head;    ListNode* dummy = new ListNode(-1,head);    ListNode* p = head-&gt;next;    ListNode* pviot = head;    ListNode* Rtail = pviot;    Rtail-&gt;next = nullptr;    while(p != tail)    {        ListNode* t = p-&gt;next;        if(p-&gt;val &lt; pviot-&gt;val)        {            p-&gt;next = dummy-&gt;next;            dummy-&gt;next = p;        }        else        {            Rtail-&gt;next = p;            Rtail = p;        }        p = t;    }    Rtail-&gt;next = p;    ListNode* node = quickSort(dummy-&gt;next,pviot);    pviot-&gt;next = quickSort(pviot-&gt;next,tail);    return node;   }ListNode* sortList(ListNode* head) {    return quickSort(head,nullptr);}};</code></pre><h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>待补</li></ul><h2 id="简单排序-插入-冒泡-选择"><a href="#简单排序-插入-冒泡-选择" class="headerlink" title="简单排序(插入/冒泡/选择)"></a>简单排序(插入/冒泡/选择)</h2><ul><li>待补</li></ul><h2 id="非比较排序-1"><a href="#非比较排序-1" class="headerlink" title="非比较排序"></a>非比较排序</h2><ul><li>待补</li></ul><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>外部排序指代排序文件较大,内存一次放不下,需存放在外村的文件的排序.</li><li>带排序的记录储存在外村,排序时在把数据一部分一部分地调入内存进行排序,排序过程中需要多次进行内存与外存之间的交换.<h2 id="外部归并排序"><a href="#外部归并排序" class="headerlink" title="外部归并排序"></a>外部归并排序</h2></li><li>外排的时间复杂度主要考虑访问此判断次数(I/O次数)<ul><li><code>外部排序的总时间 = 内部排序所需的时间 + 外存信息读写的时间 + 内部归并所需的时间</code></li></ul></li><li>归并排序分为两个阶段<ul><li><ol><li>根据内存缓冲区大小,将外存上的文件分为若干长度为<code>l</code>的子文件,依次读入内存并利用内部排序方法对他们进行排序,并将排序后的有序子文件重新写回,称这些有序子文件为<code>归并段</code>或<code>顺串</code></li></ol></li><li><ol><li>对这些归并段进行逐趟归并,使归并段(有序子文件)逐渐由小到大,直至得到整个有序子文件为止.</li></ol></li></ul></li><li>增大归并路数,可减少归并趟数,从而减少总的磁盘I/O次数<ul><li>归并趟数S = 归并树的高度 = $\lceil log_{k}{r} \rceil$</li><li><code>r</code>为初试归并段个数</li></ul></li></ul><h2 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h2><ul><li>目的:利用败者树增大归并路数</li></ul><hr><ul><li>普通增加归并串的问题:增加归并路数k时,内部归并的时间将增加,这将抵消由于增大k而减少外存访问次数所得的收益.</li><li>S躺归并总共需要的是比较次数:$S(n-1)(k-1) = \lceil log_{k}{r} \rceil (n-1)(k-1) = \lceil log_{2}{r} \rceil (n-1)(k-1) / \lceil log_{2}{k} \rceil$<ul><li>n为一趟归并待归并的元素个数,n个元素需要n-1次</li><li>k-1为从k个关键字中选择最小的一个需要的比较次数</li><li>r为初试归并段个数</li></ul></li><li>可以看出$(k-1) / \lceil log_{2}{k} \rceil$随着k增大而增大,所以内部归并的时间也随着k的增大而增大</li></ul><hr><ul><li>解决方法啊:败者树<ul><li>败者树是一种树形选择结构<ul><li>它是一种完全二叉树</li><li>有序归并段放在叶子结点上,每次把用各个归并段的第一个结点进行比较</li><li>分支结点用于记录左右孩子中的失败者</li><li>最后根结点结果为胜利者(最小数)</li></ul></li></ul></li></ul><p><img src="败者树.jpg" alt></p><ul><li>对于k陆归并的败者树深度为$\lceil log_{2}{k} \rceil$,因此k个记录中选择最小关键字,最多需要$\lceil log_{2}{k} \rceil$次比较.</li><li>所以使用败者树后的总的比较次数为<ul><li>$S(n-1) \lceil log_{2}{k} \rceil = \lceil log_{k}{r}(n-1)\lceil log_{2}{k} \rceil = (n-1)\lceil log_{2}{r} \rceil$</li></ul></li><li>所以利用败者树进行比较的话,内部归并与归并路数k无关.只要内存空间允许,增大归并路数k将有效地减少归并树的高度,从而减少I/O次数,提高外部排序的速度.</li><li>在内存空间一定的时候,增加归并的路数会导致平均每个归并缓存区变小,所以导致I/O交换的次数会变多,导致性能下降.</li></ul><h2 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h2><ul><li>目的: 生成初始归并段,用于增大归并段长度来减少归并段个数</li><li>减少归并段的原因: 由$S(n-1)(k-1) = (n-1)\lceil log_{2}{r} \rceil$可知减少初试归并段的个数也能减少归并趟数S</li><li>使用置换选择排序的原因:生成归并串依赖可用内存区的大小下,生成尽可量长的初试归并段</li></ul><hr><ul><li><p>方法伪代码:<br><img src="置换选择排序.jpg" alt></p></li><li><p>例子</p><ul><li>设待排文件FI = {17,21,05,44,10,12,56,32,29},WA的容量为3.排序过程如下表</li></ul></li></ul><p><img src="置换选择排序例子.jpg" alt></p><h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><ul><li>WPL(带权路径长度):树中所有叶结点的带权路径长度之和称为该树的带权路径长度.</li><li>目的:由长度不相等的归并段,进行多路平衡归并,不同归并的选择会导致I/O次数的不同.<ul><li>如下图左边的I/O次数为484次,右边的I/O次数为466次</li></ul></li></ul><p><img src="不同归并树对IO次数的影响.jpg" alt></p><hr><ul><li>最佳归并树的构成方法(哈夫曼树扩展)<ul><li>若初试归并段不足以构成一棵阉割k叉树时,需要添加长度为0的虚段(放置最远)</li></ul></li></ul><p><img src="Sort/计算最佳归并树的虚段数目.jpg" alt></p><ul><li>关于完全k叉树性质: $n_{0} = (k-1)n_{k} + 1$的证明<script type="math/tex; mode=display">n_{0} := 度为0的结点(叶子结点)</script><script type="math/tex; mode=display">n_{k} := 度为k的结点(分支结点)</script><script type="math/tex; mode=display">n := 树中的总结点个数</script><script type="math/tex; mode=display">B := 分支个数</script></li></ul><script type="math/tex; mode=display">n = n_{0} + n_{k}</script><script type="math/tex; mode=display">n = B+1(结点个数等于分支个数+1)</script><script type="math/tex; mode=display">B = k * n_{k}(分支个数等于非叶子结点的总度数)</script><script type="math/tex; mode=display">n_{0} + n_{k} = k * n_{k} + 1</script><script type="math/tex; mode=display">n_{0} = (k-1)n_{k} + 1</script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List深入探索</title>
      <link href="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/List/"/>
      <url>/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CPP/STL/List/</url>
      
        <content type="html"><![CDATA[<h1 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h1><ul><li>List是一个双端队列<h2 id="gcc2-9中list的类图"><a href="#gcc2-9中list的类图" class="headerlink" title="gcc2.9中list的类图"></a>gcc2.9中list的类图</h2><img src="UML_List.jpg" alt></li></ul><h2 id="gcc2-9中list的成员变量"><a href="#gcc2-9中list的成员变量" class="headerlink" title="gcc2.9中list的成员变量"></a>gcc2.9中list的成员变量</h2><pre><code class="lang-cpp">template&lt;class T, class Alloc = alloc&gt;class list {protected:    typedef __list_node&lt;T&gt; list_node;public:    typedef list_node *link_type;    typedef __list_iterator&lt;T, T &amp;, T *&gt; iterator;protected:    link_type node;};</code></pre><pre><code class="lang-cpp">template&lt;class T&gt;struct __list_node {    typedef void *void_pointer;    void_pointer prev;    void_pointer next;    T data;};</code></pre><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li>为实现前闭后开的特性,在环形链表末尾加入一个用以占位的空节点,并将迭代器list::end()指向该节点.</li></ul><p><img src="List_Graphy" alt></p><hr><ul><li>对于链表的迭代器的<code>++</code>,<code>--</code>,<code>-&gt;</code>,<code>*</code>等操作都是运算符重载.<ul><li>还定义了iterator_category、value_type、difference_type、pointer和pointer5个关联类型(associated types),这些特征将被STL算法使用.</li></ul></li></ul><p><img src="List_Operator.jpg" alt></p><pre><code class="lang-cpp">template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator {    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;    typedef bidirectional_iterator_tag     iterator_category;     // 关联类型1    typedef T                             value_type;            // 关联类型2    typedef ptrdiff_t                     difference_type;    // 关联类型3    typedef Ptr                         pointer;            // 关联类型4    typedef Ref                         reference;            // 关联类型5    typedef __list_node &lt;T&gt;*            link_type;    link_type node;        // 指向的链表节点    reference operator*() const { return (*node).data; }    //*ite -&gt; 调用 -&gt; (*ite).dta;    pointer operator-&gt;() const { return &amp;(operator*()); }    //ite-&gt;method() -&gt; 调用 -&gt; (&amp;(*ite))-&gt;method();    //注意对于 -&gt; 运算符,他们一直向后传递一直到可以停止为止    self&amp; operator++() {        node = (link_type) ((*node).next);        return *this;    }    //这里是前置++    self operator++(int) {        self tmp = *this;        ++*this;        return tmp;    }    //注意这里后置++中第79行先调用 __list_iterator(const iterator&amp; x) : node(x.node) 的拷贝构造函数,而*this为传入的参数};</code></pre><hr><ul><li>注意在这里前置++运算符返回左值,而后置++返回右值,这与基础类型的++和—运算一致.<ul><li>需要强调的是(i++)++的后置++返回的是右值(临时),不能再对其后置++.<br>```cpp<br>int i(6);<br>i++++;        // 被解析为 ++(++i), 能通过编译<br>++++i;        // 被解析为 (i++)++, 不能通过编译</li></ul></li></ul><p>list<int> c;<br>auto ite = c.begin();<br>++++ite;    // 被解析为 ++(++ite), 能通过编译<br>ite++++;    // 被解析为 (ite++)++, 不能通过编译<br>```</int></p><h2 id="gcc4-9版本list"><a href="#gcc4-9版本list" class="headerlink" title="gcc4.9版本list"></a>gcc4.9版本list</h2><p><img src="List2.9VS4.9.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画线算法</title>
      <link href="/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/20213658" target="_blank" rel="noopener">绘制直线的光栅化算法</a></li><li>计算机图形学(第四版) Computer Graphics with OpenGL Fourth Edition</li></ul></li><li><p>我们需要根据一条直线(屏幕上代指线段)的两个端点$(x_{0},y_{0}),(x_{1},y_{1}),x_{0} &lt; x_{1}$,绘制中间的像素点.</p><h1 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h1></li><li>斜截式<ul><li>$y = kx + b$<ul><li>根据两个端点可以计算k和b<ul><li>$k = \frac{y_{0} -y_{1}}{x_{0} - x_{1}}$</li><li>$b = y_{0} - kx_{0}$</li></ul></li></ul></li></ul></li><li>按照直觉的方法,就是通过遍历所有的x的值,计算y的值来得到直线上每一个像素的位置.但是由于其涉及乘法,对性能损耗大.需要尽可能的不适用乘法.</li></ul><h1 id="DDA-Digital-Differential-Analyzer-数值微分分析器"><a href="#DDA-Digital-Differential-Analyzer-数值微分分析器" class="headerlink" title="DDA(Digital Differential Analyzer 数值微分分析器)"></a>DDA(Digital Differential Analyzer 数值微分分析器)</h1><ul><li>采用增量的思想,$\delta_{x}$为x方向的增量,$\delta_{y}$为y方向的增量<ul><li>$y_{i+1} = kx_{i+1} + b= k(x_{i} + \delta_{x}) + b= kx_{i} + b +  k\delta_{x} = y_{i} + k\delta_{x}$  </li></ul></li><li>这样，每个纵坐标的值都是在前一个纵坐标的基础上加上斜率k.</li></ul><hr><ul><li><p>问题1:当斜率过大时,直线过于稀疏</p><ul><li>当0 &lt; |k| &lt;= 1时, x方向遍历,$y_{i+1} = y_{i} + k$</li><li>当|k| &gt; 1时,y方向遍历,$x_{i+1} = y_{i} + 1/k$</li></ul></li><li><p>问题2:效率仍然比较低</p><ul><li>此方法用到了浮点数,浮点数加减法效率仍无法满意</li></ul></li></ul><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>输入线段的端点值,计算水平和垂直方向差值dx,dy,绝对值大的值用于确定step值(确定哪个方向增量为1)</li><li>从$(x_{0},y_{0})$开始,每次在x和y方向上增加相应的增加,并绘制像素</li></ul><pre><code class="lang-cpp">#include &lt;stdlib.h&gt;#include &lt;math.h&gt;inline int round (const float a) {return int(a+0.5)}void lineDDA(int x0,int y0,int x1,int y1){    int dx = x1 - x0,dy = y1 - y0,steps,k;    float xIncrement,yIncrement,x=x0,y=y0;    if(fabs(dx) &gt; fabs(dy))        step = fabs(dx);    else        step = fabs(dy);    xIncrement = float (dx)/ float (steps);    yIncrement = float (dy)/ float (steps);    setPixel(round(x),round(y));    for(k = 0; k &lt; steps; ++k)    {        x += xIncrement;        y += yIncrement;        setPixel(round(x),round(y));    }}</code></pre><h2 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h2><ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/345284076" target="_blank" rel="noopener">【十天自制软渲染器】DAY 02：画一条直线（DDA 算法 &amp; Bresenham’s 算法</a></li></ul><hr><ul><li>对于任意斜率在[0,1)的直线,其端点为(x1,y1),(x2,y2),其斜率为k(0&lt;=k&lt;1)<ul><li>第一个点是$(x_{1},y_{1})$.</li><li>对于第二个点可能是$(x_{1}+1,y_{1}+1)$,也有可能是$(x_{1}+1,y_{1})$;<ul><li>我们通过计算$y_{1}+k$可以得到第二个点的实际位置,此时我们只需比较$y_{1}+k$和$y_{1}+0.5$的大小即可.<ul><li>$y_{1}+k &gt;= y_{1}+0.5$,直线在这个像素中心的上方,取$y_{1}+1$.</li><li>$y_{1}+k &lt; y_{1}+0.5$,直线在这个像素中心的下方,取$y_{1}$.</li></ul></li><li>我们将把$y_{1}+k 和 y_{1}+0.5$考虑成误差形式<ul><li>假设初始误差$\epsilon=0$(假设两端点的值都为整数)</li><li>则我们只需比较$\epsilon + k 和 0.5$的大小</li></ul></li></ul></li><li>然后我们必须更新新的误差值$\epsilon$让参与第三个点的计算<ul><li>若第二点为$(x_{1}+1,y_{1}+1)$,那么$\epsilon \leftarrow  y + \epsilon + k - (y+1) = \epsilon + k -1$</li><li>若第二点为$(x_{1}+1,y_{1})$,那么$\epsilon \leftarrow  y + \epsilon + k - (y) = \epsilon + k$</li></ul></li><li>之后一直按上述规则更新.</li></ul></li></ul><pre><code class="lang-cpp">//伪代码EPS = 0y = y1for x from x1 to x2 do    draw point at (x,y)    if((EPS + k) &lt; 0.5)        EPS = EPS+k    else        EPS = EPS+k-1        y = y +1    end ifend for</code></pre><hr><ul><li>上述方法涉及浮点运算,对效率有影响,我们对误差判断的不等式做如下变换<script type="math/tex; mode=display">\epsilon + k < 0.5</script><script type="math/tex; mode=display">\epsilon + \Delta y / \Delta x < 0.5</script><script type="math/tex; mode=display">2\epsilon\Delta x + 2\Delta y < \Delta x</script><script type="math/tex; mode=display">2(\epsilon'+ \Delta y) < \Delta x,\epsilon' = \epsilon\Delta x</script></li><li>因此,我们构建初始误差值$\epsilon’$,每次加上$\Delta y$.然后每次用<code>2</code>$(\epsilon’+\Delta y)$和$\Delta x$进行判断即可.</li><li>对于误差值的更新,我们做如下变换<ul><li>$\epsilon = \epsilon + k \leftrightarrow \epsilon\Delta x = \epsilon\Delta x + \Delta y \leftrightarrow \epsilon’ = \epsilon’ + \Delta y$ </li><li>$\epsilon = \epsilon + k - 1 \leftrightarrow \epsilon\Delta x  = \epsilon\Delta x + \Delta y - \Delta x \leftrightarrow \epsilon’ = \epsilon’ + \Delta y - \Delta x$</li></ul></li></ul><pre><code class="lang-cpp">//伪代码EPS_PRIM = 0y = y1for x from x1 to x2 do    draw point at (x,y)    if(2(EPS_PRIM + dy) &lt; dx)        EPS_PRIM = EPS_PRIM + dy    else        EPS_PRIM = EPS_PRIM + dy - dx        y = y +1    end ifend for</code></pre><hr><ul><li>c++实现</li></ul><pre><code class="lang-cpp">void line(Screen &amp;s,  int x1, int y1,  int x2, int y2,  TGAImage &amp;image, TGAColor color) {  int y = y1;  int eps = 0;  int dx = fabs(x2 - x1);  int dy = fabs(y2 - y1);  for (int x = x1; x &lt;= x2; x++) {    image.set(x, y, color);    eps += dy;    // 这里用位运算 &lt;&lt;1 代替 *2    if((eps &lt;&lt; 1) &gt;= dx)  {      y++;      eps -= dx;    }  }}</code></pre><ul><li>上述算法在使用于斜率的<code>绝对值</code>在[0,1)的直线,并且x1 &lt; x2的直线,对于其他情况,可以通过交换xy的遍历方式解决.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 const</title>
      <link href="/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/"/>
      <url>/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/</url>
      
        <content type="html"><![CDATA[<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><ul><li>定义：const用于定义一个变量，它的值不能被改变</li></ul><h2 id="const对象必须初始化"><a href="#const对象必须初始化" class="headerlink" title="const对象必须初始化"></a>const对象必须初始化</h2><ul><li><p>然而并不是所有的const对象都必须初始化</p></li><li><p>顶层const必须初始化，因为本身不能改变，不初始化根本没法用。而底层const(常量指针)可以不初始化</p><blockquote><p>参考:<a href="https://blog.csdn.net/qq_21034239/article/details/70492318" target="_blank" rel="noopener">https://blog.csdn.net/qq_21034239/article/details/70492318</a></p></blockquote></li><li><p>其实没有那么简单,const对象必须初始化值对bulit-in类型和POD类行有效</p><ul><li>built-in类型是内置类型包括算术类型和空类型(void)</li><li>注意的是指针和引用是复合类型</li></ul></li></ul><blockquote><p>参考:<a href="https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away" target="_blank" rel="noopener">https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away</a><br>(翻译:<a href="https://www.it1352.com/465052.html" target="_blank" rel="noopener">https://www.it1352.com/465052.html</a>)</p></blockquote><h3 id="什么是POD类型"><a href="#什么是POD类型" class="headerlink" title="什么是POD类型"></a>什么是POD类型</h3><blockquote><p>参考: <a href="https://zhuanlan.zhihu.com/p/45545035" target="_blank" rel="noopener">什么是 POD 数据类型？</a></p></blockquote><ul><li>POD类型是 Plain Old Data 的缩写,定义它的作用是为了跟c语言进行兼容,即可以使用 memcpy() 这种最原始的函数进行操作<ul><li>也就是说，能用 C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据。</li></ul></li></ul><h4 id="如何判断POD类型"><a href="#如何判断POD类型" class="headerlink" title="如何判断POD类型"></a>如何判断POD类型</h4><ul><li>首先可以使用is_pod<t>::value函数进行判断</t></li><li>对于built-in类型肯定是POD类型,而对于类和结构体需要它是trival（平凡）的和布局有序的.</li></ul><hr><ul><li>trival（平凡）的.<ul><li>不显式写构造/析构函数、拷贝/移动构造函数、拷贝/移动运算符等</li><li>使用delete删除默认的三大函数</li><li>使用default声明默认的三大函数</li><li>不能有虚函数和虚基类</li></ul></li></ul><p><img src="POD_1.jpg" alt></p><ul><li>布局有序<ul><li>需要有相同的访问级别(private,public)</li><li>类中的第一个非静态成员的类型不能与其基类相同</li><li>只要有父类，非静态数据只能在其中一个类中，不可分散</li></ul></li></ul><h2 id="const对象仅对当前文件有效"><a href="#const对象仅对当前文件有效" class="headerlink" title="const对象仅对当前文件有效"></a>const对象仅对当前文件有效</h2><ul><li><p>在编译时会进行预处理，将代码中所有带const限定符的变量用初始化的常亮替代。</p></li><li><p>const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同在不同文件中分别定义了独立的变量。</p></li><li><p>如果要在多个文件中共享const对象，在需要声明变量的时候前面加extern</p></li></ul><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ul><li>用于声明<ul><li>变量只能被定义一次，但可以被多次声明。</li></ul></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>C/C++程序编译链接过程(还没写)</li></ul><h2 id="对const的引用"><a href="#对const的引用" class="headerlink" title="对const的引用"></a>对const的引用</h2><ul><li><p>别称: 常量引用</p></li><li><p>常量引用可以引用常量和非常量</p></li><li>非常量引用不能引用常量</li></ul><pre><code class="lang-cpp">const int a = 1;int d = 1;const int &amp;b = a;//trueconst int &amp;c = 1;//trueconst int &amp;d = d;//trueint &amp;e = a;//false;</code></pre><ul><li>初始化常量引用的时候可以使用任意类型和任意表达式，只要可以转换成相应的引用类型。<blockquote><p>原因：<strong>当绑定的常量类型与引用类型不同时</strong>,会生成了一个临时变量用于绑定。其事实上绑定的是临时变量。</p></blockquote></li></ul><blockquote><p>这样保证了const int&amp;绑定的是int型的表达式</p><p>还有值得注意的是一般情况下引用的类型必须与其所引用的对象的类型一致</p></blockquote><pre><code class="lang-cpp">double dval = 3.14;const int &amp;ri = dval;</code></pre><p>等价于</p><pre><code class="lang-cpp">double dval = 3.14;const int temp = dval;const int &amp;ri = temp;</code></pre><ul><li>根据上述也可以解释为什么非常量引用不能引用常量，因为这样初始化绑定的是临时量。<blockquote><p>非const变量引用const量，其实绑定了中间变量temp，因为是非const量所以可以改变这非const量，按引用来const量也应该改变，但其实改变的是中间量temp，const量不变，产生矛盾，c++把这种行为定义为非法。</p></blockquote></li></ul><h3 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h3><ul><li>const只约束当前绑定的对象的相关操作，而不管对象本身是不是常量。</li></ul><pre><code class="lang-cpp">int a  = 1;int &amp;b = a;const int &amp;c = a;const double &amp;d = a;//注意这里的d绑定的是临时变量tempb = 2;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;//2 2 2 1a = 3;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;//3 3 3 1c = 4;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;// error: assignment of read-only reference ‘c’</code></pre><h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><blockquote><p>对于指针常量和常量指针的定义C++ primer里定义的跟大多数教材不一样</p><h3 id="指针常量-pointer-to-const"><a href="#指针常量-pointer-to-const" class="headerlink" title="指针常量(pointer to const)"></a>指针常量(pointer to const)</h3><ul><li>从右往左读，它是一个指针，是一个指向常量类型的指针。说明不能改变他所指向对象的内容。但是可以改变它指向的对象。</li></ul></blockquote><pre><code class="lang-cpp">const int a = 1;const int b = 2;const int *c = &amp;a;*c = 1;//faslec = &amp;b;//true</code></pre><h3 id="常量指针-const-pointer"><a href="#常量指针-const-pointer" class="headerlink" title="常量指针(const pointer)"></a>常量指针(const pointer)</h3><ul><li>从右往左读，它是一个常量，说明指针的地址不能改变。但是可以改变它指向对象的内容。</li></ul><pre><code class="lang-cpp">int a = 1;int b = 2;int *const c = &amp;a; c= &amp;b;//falsec= 2;//true</code></pre><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><ul><li>顶层const说明指针本身是个常量-常量指针(const pointer)</li><li>底层const说明指针指向的对象是个常量-指针常量(pointer to const)</li></ul><h3 id="const对拷贝的影响"><a href="#const对拷贝的影响" class="headerlink" title="const对拷贝的影响"></a>const对拷贝的影响</h3><ul><li>顶层const对拷贝无影响</li><li>底层const对拷贝有影像<blockquote><p>拷贝两者有相同的底层const的，或者被拷贝数据可以从非常量转变为常量,才无影响</p></blockquote></li></ul><pre><code class="lang-cpp">int main(){   // 顶层const对拷贝无影响    {        // const int -&gt; int  yes        const int b = 1;        int a = b;        // int -&gt; const int yes        int c = 1;        const int d = c;    }     // &amp;int(int*) -&gt; int *const/const int*/const int *const    int a = 1;    int *const b = &amp;a; //ok    const int *c = &amp;a; //ok    const int *const d = &amp;a; //ok    // &amp;(const int) -&gt; int *const/const int*/const int *const    const int e = 1;    int *const f = &amp;e; //error 没有相同的底层const    const int *g = &amp;e; //ok    const int *const h = &amp;e; //ok  &amp;e可以转换成const int *const    //(int cont*) -&gt; int *const/const int*/const int *const    int i = 1;    int *const  j= &amp;i;    int *const  k = j; //ok    const int*  l = j; //ok    const int *const m = j; //ok    return 0;}</code></pre><ul><li>总结(我自己有点绕晕了,总结一下)<blockquote><p>1) 对于非指针类型之间的拷贝,没有限制 const int &lt;-&gt; int</p></blockquote></li></ul><blockquote><p>2) 对于指针之间的拷贝。右值没有底层const,总合法;右值有底层const,则看左值有没有底层const,有则合法,没有则不合法。   </p><ul><li>常量对象不能赋值给非常量引用,常量对象不能赋值给非常量指针</li></ul><p>3) 对于指针和非指针之间，类型不同不合法;</p></blockquote><h2 id="constexpr和常量表达式-c-11"><a href="#constexpr和常量表达式-c-11" class="headerlink" title="constexpr和常量表达式[c++11]"></a>constexpr和常量表达式[c++11]</h2><ul><li>常量表达式(const expression)是指不会改变并且在编译过程就能得到计算结果的表达式<blockquote><p>数据类型是常量并且初始值是常量或字面值或两者混合的是常量表达式。</p></blockquote></li></ul><pre><code class="lang-cpp">const int a = 1; //trueconst int b = a+1; //trueint c = 1; //falseconst int d = get_d(); //false，该值在编译时才能获得，所以不是常量表达式</code></pre><h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><ul><li>constexpr定义的变量必须要用常量表达式初始化</li><li>constexpr是顶层const，即其本身为常量</li><li>对于字面量<blockquote><p>算术类型，引用和指针，字面值常量类（包括枚举类型），枚举都是字面值<br>自定义类，IO库，string类等不算字面值</p></blockquote></li></ul><h3 id="constexpr-指针"><a href="#constexpr-指针" class="headerlink" title="constexpr 指针"></a>constexpr 指针</h3><ul><li>constexpr指针只能指向地址固定的变量，比如全局变量，staitc变量</li></ul><pre><code class="lang-cpp">constexpr int *p1; //顶层constconst int *p2;  //底层constint *const p3;  //顶层constconstexpr const int *p4;//&lt;=&gt;const int *const p5;</code></pre><h2 id="const补充"><a href="#const补充" class="headerlink" title="const补充"></a>const补充</h2><p><a href="https://interview.huihut.com/#/?id=cc" target="_blank" rel="noopener">const 使用</a></p><ul><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量<ul><li>注意常量类型只能调用<code>常量</code>成员函数</li><li>非常量类型能调用<code>常量</code>成员函数和<code>非常量</code>成员函数</li></ul></li></ul><pre><code class="lang-cpp">// 类class A{private:    const int a;                // 常对象成员，只能在初始化列表赋值public:    // 构造函数    A() : a(0) { };    A(int x) : a(x) { };        // 初始化列表    // const可用于对重载函数的区分    int getValue();             // 普通成员函数    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值};void function(){    // 对象    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量    const A a;                  // 常对象，只能调用常成员函数    const A *p = &amp;a;            // 指针变量，指向常对象    const A &amp;q = a;             // 指向常对象的引用    // 指针    char greeting[] = &quot;Hello&quot;;    char* p1 = greeting;                // 指针变量，指向字符数组变量    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量}// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char* Var);         // 参数指针所指内容为常量void function3(char* const Var);         // 参数指针为常量void function4(const int&amp; Var);          // 引用参数在函数内为常量// 函数返回值const int function5();      // 返回一个常数const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lesson 1 Bresenham’s Line Drawing Algorithm</title>
      <link href="/2021/06/05/Project/TinyRenderer/Line_Drawing_Algorithm/"/>
      <url>/2021/06/05/Project/TinyRenderer/Line_Drawing_Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="插值画线算法"><a href="#插值画线算法" class="headerlink" title="插值画线算法"></a>插值画线算法</h1><pre><code class="lang-cpp">void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) {     for (float t=0.; t&lt;1.; t+=.01) {         int x = x0 + (x1-x0)*t;         int y = y0 + (y1-y0)*t;         image.set(x, y, color);     } }</code></pre><ul><li>存在问题<ul><li>效率低下,不好确定插值精度k<ul><li>算法控制精度的方式无关屏幕像素点，无法做到真正的逐点绘制，x和y是一个近似的int值，可能存在重复绘制和缺省绘制的情况，我们需要逐x像素或逐y像素绘制线段。</li></ul></li></ul></li></ul><h1 id="逐像素直线算法"><a href="#逐像素直线算法" class="headerlink" title="逐像素直线算法"></a>逐像素直线算法</h1><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){    for(int x = x1; x &lt;= x2; ++x)    {        float t = (x - x1) / (float)(x2 - x1);        int y = y1 * (1.f - t) + y2 * t;        image.set(x,y,color);    }}line(13, 20, 80, 40, image, white); line(20, 13, 40, 80, image, red); line(80, 40, 13, 20, image, red);</code></pre><p><img src="Second_attempt.png" alt></p><ul><li>存在问题:<ul><li>第一条直线比较好</li><li>第二条直线有很多洞,不太行</li><li>未出现第三条线,第一第三条线是一样的只是颜色和方向不一样<ul><li>因为我们的算法从默认是x1 &lt; x2的,如果按照直线3的画法将导致进入不了循环</li></ul></li></ul></li></ul><h1 id="改进逐像素直线算法"><a href="#改进逐像素直线算法" class="headerlink" title="改进逐像素直线算法"></a>改进逐像素直线算法</h1><ul><li>如果斜率的绝对值大于1,以y=x做对称</li><li><p>保证从直线中坐标小的位置绘制到坐标大的位置</p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  for(int x = x1; x &lt;= x2; ++x)  {      float t = (x - x1) /(float)(x2-x1);      int y = y1*(1.f - t) + y2*t;      if(yDir)          image.set(y,x,color);      else          image.set(x,y,color);  }}</code></pre></li><li><p>存在问题</p><ul><li>效率低下</li></ul></li></ul><h1 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h1><ul><li><p>方法见之前的笔记:<a href="https://sanctorum003.github.io/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">画线算法</a></p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  int dx = x2-x1;  int dy = y2-y1;  float derror = abs(dy/(float)dx);  float error = 0.f;  int y = y1;  for(int x = x1; x &lt;= x2; ++x)  {      if(yDir)          image.set(y,x,color);      else              image.set(x,y,color);      error += derror;      if(error &gt; 0.5)      {          y += (y1 &gt; y2) ? -1.f : 1.f ;          error--;      }  }}</code></pre></li><li><p>存在问题</p><ul><li>涉及到浮点数运算,效率有所下降.</li></ul></li></ul><h1 id="优化的Bresenham算法"><a href="#优化的Bresenham算法" class="headerlink" title="优化的Bresenham算法"></a>优化的Bresenham算法</h1><ul><li>方法见之前的笔记:<a href="https://sanctorum003.github.io/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">画线算法</a></li><li><p>公式推导如下:<br><img src="non_float_bresenham.jpg" alt></p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  int dx = x2-x1;  int dy = y2-y1;  int error = 0;  int y = y1;  for(int x = x1; x &lt;= x2; ++x)  {      if(yDir)          image.set(y,x,color);      else              image.set(x,y,color);      error += 2 * dy;      if(error &gt; dx)      {          y += (y1 &gt; y2) ? -1.f : 1.f;          error -= 2*dx;      }  }}</code></pre><h1 id="Wireframe-rendering-线框渲染"><a href="#Wireframe-rendering-线框渲染" class="headerlink" title="Wireframe rendering(线框渲染)"></a>Wireframe rendering(线框渲染)</h1></li><li>obj文件特点:<ul><li>v代表定点</li><li>f代表面</li></ul></li></ul><pre><code class="lang-cpp">// 实例化模型model = new Model(&quot;obj/african_head.obj&quot;);// 循环模型里的所有三角形for (int i = 0; i &lt; model-&gt;nfaces(); i++) {  std::vector&lt;int&gt; face = model-&gt;face(i);  // 循环三角形三个顶点，每两个顶点连一条线  for (int j = 0; j &lt; 3; j++) {    Vec3f v0 = model-&gt;vert(face[j]);    Vec3f v1 = model-&gt;vert(face[(j + 1) % 3]);    // 因为模型空间取值范围是 [-1, 1]^3，我们要把模型坐标平移到屏幕坐标中    // 下面 (point + 1) * width(height) / 2 的操作学名为视口变换（Viewport Transformation）    int x0 = (v0.x + 1.) * width / 2.;    int y0 = (v0.y + 1.) * height / 2.;    int x1 = (v1.x + 1.) * width / 2.;    int y1 = (v1.y + 1.) * height / 2.;    // 画线    line(x0, y0, x1, y1, image, white);  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tinyrenderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习总览</title>
      <link href="/2021/06/05/Menu/C++%E5%A4%8D%E4%B9%A0%E6%80%BB%E8%A7%88/"/>
      <url>/2021/06/05/Menu/C++%E5%A4%8D%E4%B9%A0%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="huihut-interview再总结"><a href="#huihut-interview再总结" class="headerlink" title="huihut/interview再总结"></a>huihut/interview再总结</h1><ul><li>参考:<a href="https://interview.huihut.com/#/" target="_blank" rel="noopener">https://interview.huihut.com/#/</a></li></ul><div class="table-container"><table><thead><tr><th>关键字</th></tr></thead><tbody><tr><td><a href="https://sanctorum003.github.io/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/" target="_blank" rel="noopener">const</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*</title>
      <link href="/2021/06/03/Algorithm/A_Star/"/>
      <url>/2021/06/03/Algorithm/A_Star/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是对<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Introduction to the A* Algorithm</a>的学习笔记<br>参考<a href="https://zhuanlan.zhihu.com/p/54510444" target="_blank" rel="noopener">路径规划之 A* 算法</a></p></blockquote><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><ul><li>输入:图结构</li><li>输出:图的结点序列(The path found by A* is made of graph nodes and edges)</li><li><p>Tradeoffs:结点越少,A*速度越快</p></li><li><p>拓展:<a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html" target="_blank" rel="noopener">Map representations</a></p></li></ul><h1 id="寻路算法概括"><a href="#寻路算法概括" class="headerlink" title="寻路算法概括"></a>寻路算法概括</h1><h2 id="Breadth-First-Search-BFS"><a href="#Breadth-First-Search-BFS" class="headerlink" title="Breadth First Search(BFS)"></a>Breadth First Search(BFS)</h2><ul><li>特点:搜寻每个方向的权值相等</li><li>使用场景:<ul><li>regular path finding</li><li>procedural map generation</li><li>flow field pathfinding</li><li>distance maps</li><li>other types of map analysis</li></ul></li></ul><h2 id="Dijkstra-ˈdeɪkstra-’s-Algorithm-Uniform-Cost-Search"><a href="#Dijkstra-ˈdeɪkstra-’s-Algorithm-Uniform-Cost-Search" class="headerlink" title="Dijkstra[/ˈdɛɪkstra/]’s Algorithm(Uniform Cost Search)"></a>Dijkstra[/ˈdɛɪkstra/]’s Algorithm(Uniform Cost Search)</h2><ul><li>特点:优先选择低代价的路径进行搜索</li><li>使用场景:适合在存在不同代价路径的图中进行搜索</li></ul><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><ul><li>是Dijkstra’s Algorithm的改进,针对单个目的地进行了优化<ul><li>Dijkstra 算法可以找到所有位置的路径</li><li>A* 查找到一个位置或几个位置中最近的位置的路径。</li><li>它优先考虑更接近目标的路径</li></ul></li></ul><h1 id="从BFS到A"><a href="#从BFS到A" class="headerlink" title="从BFS到A*"></a>从BFS到A*</h1><h2 id="朴素BFS"><a href="#朴素BFS" class="headerlink" title="朴素BFS"></a>朴素BFS</h2><pre><code class="lang-python"># 计算从start开始到任意点的路径frontier = Queue()frontier.put(start)came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   for next in graph.neighbors(current):      if next not in came_from:         frontier.put(next)         came_from[next] = current</code></pre><ul><li>通过上述代码可以将从start开始到任意点的路径保存在一个字典结构中,可视化效果如下<br><img src="BFS_PATH.jpg" alt></li></ul><pre><code class="lang-python"># 获得某一个goal到start的路径current = goal path = []while current != start:    path.append(current)   current = came_from[current]path.append(start) # optionalpath.reverse() # optional</code></pre><ul><li>扩展:<a href="https://www.redblobgames.com/pathfinding/tower-defense/" target="_blank" rel="noopener">Flow Field Pathfinding for Tower Defense</a></li></ul><h2 id="提前停止-early-exit"><a href="#提前停止-early-exit" class="headerlink" title="提前停止(early exit)"></a>提前停止(early exit)</h2><ul><li>对于计算某一点<code>start</code>到<code>goal</code>的路径,我们不必计算所有的点,只需在找到<code>goal</code>时停止bfs即可.</li><li>通过<code>提前停止</code>可以减少计算量,可视化如下图</li></ul><p><img src="BFS_EarlyExit.jpg" alt></p><pre><code class="lang-python"># early exitfrontier = Queue()frontier.put(start )came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   if current == goal:       break              for next in graph.neighbors(current):      if next not in came_from:         frontier.put(next)         came_from[next] = current</code></pre><ul><li>扩展<a href="https://www.redblobgames.com/pathfinding/early-exit/" target="_blank" rel="noopener">Early exits</a></li></ul><h2 id="移动代价-Movement-costs"><a href="#移动代价-Movement-costs" class="headerlink" title="移动代价(Movement costs)"></a>移动代价(Movement costs)</h2><ul><li>引入Dijkstra’s Algorithm.需要记录移动时的代价.</li></ul><pre><code class="lang-py">frontier = PriorityQueue()frontier.put(start, 0)came_from = dict()cost_so_far = dict()came_from[start] = Nonecost_so_far[start] = 0while not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      new_cost = cost_so_far[current] + graph.cost(current, next)      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:         cost_so_far[next] = new_cost         priority = new_cost         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul><li><p>详细理解Dijkstra:<a href="https://zhuanlan.zhihu.com/p/129373740" target="_blank" rel="noopener">[最短路径问题]—Dijkstra 算法最详解</a></p></li><li><p>Dijkstra是一种基于贪心的算法，它也是BFS的变种,是计算一个非负权图中，某个起始点到其它所有节点最短路径值的算法，即求单源最短路径，也能求最短路径节点顺序。</p></li></ul><p><img src="Dijkstra.svg" alt></p><ul><li>方法参考伪代码<ul><li>相关参数:设<code>S</code>为已经求得的最短路径的结点,<code>V</code>为图中所有结点的集合,<code>dist[a,b]</code>为a点到b点的相对最短路径(相对最短路劲指的是从a点到b点并且只经过<code>S</code>中的结点的最短路径)<ul><li>Step 1(Line1-2): 将起始点<code>s</code>加入到S中,并将<code>dist[s,s]</code>设为0</li><li>Step 2(Line3-4): 计算从<code>s</code>点开始到其他所有点$v_{i}$的直接路径并写入$dist[s,v_{i}]$(对于无法直接到达的点赋值为 $\infin$)</li><li>(Line5):接下去是循环计算每一个点的最短路径,判断条件是 $V-S$是否为空.</li><li>Step 3(Line6-7):在循环中,每次挑选一个路径最短的结点$v_{j}$,并将他加入到<code>S</code>中</li><li>Step 4(Linr8-10)[<code>松弛</code>]:对于挑选出的结点$v_{j}$,跟新剩下<code>V-S</code>中的结点,判断是否经过$v_{j}$到b的权值是否更小,并进行更新.</li><li>重复进行循环直到<code>V-S</code>为空.</li></ul></li></ul></li></ul><h4 id="为什么每次加入集合S的点就是该点到源点的最小距离？"><a href="#为什么每次加入集合S的点就是该点到源点的最小距离？" class="headerlink" title="为什么每次加入集合S的点就是该点到源点的最小距离？"></a>为什么每次加入集合S的点就是该点到源点的最小距离？</h4><blockquote><p>参考:<a href="https://www.zhihu.com/question/20972566/answer/1106454505" target="_blank" rel="noopener">Dijkstra算法到底是讲什么的，谁可以通俗的讲解一下？通俗的程度：零基础也能听得懂？</a></p></blockquote><ul><li>这个问题与Dijkstra算法正确性挂钩，现在就来证明一下：  <ul><li>（1）因为每次都是找的<code>V-S</code>中的最小节点值的点加入<code>S</code>，那么加入<code>S</code>的顺序一定是节点到源点最小距离的顺序。  </li><li>（2）每次加入<code>S</code>的节点<code>v</code>一定与<code>S</code>中的节点直接相连，若不然，则存在中间节点连接集合S和点v，那么  一定有比v更小的节点值，与<code>dist[v]</code>最小矛盾。  </li><li>（3）对于一个已求得部分节点最短距离的<code>S</code>集合，下一个加入集合<code>S</code>中的节点必然是<code>S</code>集合中节点的下一邻接点，而根据算法特性，<code>S</code>集合中节点的下一邻接点都被进行松弛更新过，所以<code>V-S</code>中的最小节点值一定是该节点的最短距离。（注意，这里找最小值是为了便于计算，有可能有多个节点的最短距离已经产生，今后也不会再更新，只是他们距离更大一些，所以暂时不被选择）。      </li></ul></li></ul><ul><li>简单地说，因为下一个最短距离的节点必然是<code>S</code>集合的下一邻接点，而选择<code>V-S</code>中最小节点值的节点恰能满足该节点是<code>S</code>的下一邻接点，所以该节点值一定是最短距离。</li></ul><h3 id="Dijkstra-for-pathfinding-代码实现"><a href="#Dijkstra-for-pathfinding-代码实现" class="headerlink" title="Dijkstra for pathfinding 代码实现"></a>Dijkstra for pathfinding 代码实现</h3><ul><li>参考<a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm" target="_blank" rel="noopener">Implementation of A*</a></li></ul><pre><code class="lang-cpp">// Graph with weightsstruct GridWithWeights: SquareGrid {  std::unordered_set&lt;GridLocation&gt; forests;  GridWithWeights(int w, int h): SquareGrid(w, h) {}  double cost(GridLocation from_node, GridLocation to_node) const {    return forests.find(to_node) != forests.end()? 5 : 1;  }};</code></pre><pre><code class="lang-cpp">// Queue with prioritiestemplate&lt;typename T, typename priority_t&gt;struct PriorityQueue {  typedef std::pair&lt;priority_t, T&gt; PQElement;  std::priority_queue&lt;PQElement, std::vector&lt;PQElement&gt;,                 std::greater&lt;PQElement&gt;&gt; elements;  inline bool empty() const {     return elements.empty();  }  inline void put(T item, priority_t priority) {    elements.emplace(priority, item);  }  T get() {    T best_item = elements.top().second;    elements.pop();    return best_item;  }};</code></pre><pre><code class="lang-cpp">// dijkstra Search(build path map)template&lt;typename Location, typename Graph&gt;void dijkstra_search  (Graph graph,   Location start,   Location goal,   std::unordered_map&lt;Location, Location&gt;&amp; came_from,   std::unordered_map&lt;Location, double&gt;&amp; cost_so_far){  PriorityQueue&lt;Location, double&gt; frontier;  frontier.put(start, 0);  came_from[start] = start;  cost_so_far[start] = 0;  while (!frontier.empty()) {    Location current = frontier.get();    if (current == goal) {      break;    }    for (Location next : graph.neighbors(current)) {      double new_cost = cost_so_far[current] + graph.cost(current, next);      if (cost_so_far.find(next) == cost_so_far.end()          || new_cost &lt; cost_so_far[next]) {        cost_so_far[next] = new_cost;        came_from[next] = current;        frontier.put(next, new_cost);      }    }  }}```cpp//build the pathtemplate&lt;typename Location&gt;std::vector&lt;Location&gt; reconstruct_path(   Location start, Location goal,   std::unordered_map&lt;Location, Location&gt; came_from) {  std::vector&lt;Location&gt; path;  Location current = goal;  while (current != start) {    path.push_back(current);    current = came_from[current];  }  path.push_back(start); // optional  std::reverse(path.begin(), path.end());  return path;}</code></pre><h2 id="Heuristic-search-启发式搜索"><a href="#Heuristic-search-启发式搜索" class="headerlink" title="Heuristic search(启发式搜索)"></a>Heuristic search(启发式搜索)</h2><h3 id="什么是启发式算法"><a href="#什么是启发式算法" class="headerlink" title="什么是启发式算法"></a>什么是启发式算法</h3><ul><li>参考:<a href="https://www.cnblogs.com/sddai/p/5644011.html" target="_blank" rel="noopener">启发式算法（Heuristic Algorithm）</a></li></ul><hr><ul><li>启发式算法（Heuristic Algorithm）有不同的定义：一种定义为，一个基于直观或经验的构造的算法，对优化问题的实例能给出可接受的计算成本（计算时间、占用空间等）内，给出一个近似最优解，该近似解于真实最优解的偏离程度不一定可以事先预计；另一种是，启发式算法是一种技术，这种技术使得在可接受的计算成本内去搜寻最好的解，但不一定能保证所得的可行解和最优解，甚至在多数情况下，无法阐述所得解同最优解的近似程度。我比较赞同第二种定义，因为启发式算法现在还没有完备的理论体系，只能视作一种技术。</li></ul><hr><ul><li>互动百科解释:人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的 步骤去寻求答案。启发式解决问题的方法是与算法相对立的。算法是把各种可能性都一一进行尝试，最终能找到问题的答案，但它是在很大的问题空间内，花费大量 的时间和精力才能求得答案。启发式方法则是在有限的搜索空间内，大大减少尝试的数量，能迅速地达到问题的解决。但由于这种方法具有尝试错误的特点，所以也 有失败的可能性。科学家的许多重大发现，常常是利用极为简单的启发式规则。</li></ul><h3 id="Greedy-Best-First-Search-最佳优先搜索"><a href="#Greedy-Best-First-Search-最佳优先搜索" class="headerlink" title="Greedy Best First Search(最佳优先搜索)"></a>Greedy Best First Search(最佳优先搜索)</h3><ul><li>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</li></ul><pre><code class="lang-py"># 定义曼哈顿距离def heuristic(a, b):   # Manhattan distance on a square grid   return abs(a.x - b.x) + abs(a.y - b.y)</code></pre><ul><li>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</li></ul><pre><code class="lang-py"># Greedy Best First Searchfrontier = PriorityQueue()frontier.put(start, 0)came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      if next not in came_from:         priority = heuristic(goal, next)         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="Greedy-Best-First-Search的问题"><a href="#Greedy-Best-First-Search的问题" class="headerlink" title="Greedy Best First Search的问题"></a>Greedy Best First Search的问题</h3><ul><li>如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</li></ul><p><img src="GB-FS.jpg" alt></p><h2 id="The-A-algorithm"><a href="#The-A-algorithm" class="headerlink" title="The A* algorithm"></a>The A* algorithm</h2><ul><li>A<em>算法结合了Djikstra和Greedy Best First的特点. A </em>通过以下函数来计算每个结点的优先级:<script type="math/tex; mode=display">f(n) = g(n) + h(n)</script><ul><li>其中,<code>f(n)</code>是节点<code>n</code>的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li><li>其中,<code>g(n)</code>就是在Djikstra算法中计算的离起始点的距离,我们在Djikstra中取<code>g(n)</code>值最小的作为最高优先级</li><li>其中,<code>h(n)</code>为A*算法的启发函数,计算节点n距离终点的预计代价(距离).取<code>h(n)</code>值最小的作为最高优先级</li></ul></li><li>A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</li></ul><hr><ul><li>A* 伪代码<ul><li>open_set 为待遍历的结点</li><li>close_set 为已经遍历的结点<br>```cpp</li></ul></li><li>初始化open_set和close_set；</li><li>将起点加入open_set中，并设置优先级为0（优先级最高）；</li><li>如果open_set不为空，则从open_set中选取优先级最高的节点n：<ul><li>如果节点n为终点，则：<ul><li>从终点开始逐步追踪parent节点，一直达到起点；</li><li>返回找到的结果路径，算法结束；</li></ul></li><li>如果节点n不是终点，则：<ul><li>将节点n从open_set中删除，并加入close_set中；</li><li>遍历节点n所有的邻近节点：<ul><li>如果邻近节点m在close_set中，则：<ul><li>跳过，选取下一个邻近节点</li></ul></li><li>如果邻近节点m也不在open_set中，则：<ul><li>设置节点m的parent为节点n</li><li>计算节点m的优先级</li><li>将节点m加入open_set中<br>```</li></ul></li></ul></li></ul></li></ul></li></ul><hr><ul><li>A* python伪代码</li></ul><pre><code class="lang-py">frontier = PriorityQueue()frontier.put(start, 0)came_from = dict()cost_so_far = dict()came_from[start] = Nonecost_so_far[start] = 0while not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      new_cost = cost_so_far[current] + graph.cost(current, next)      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:         cost_so_far[next] = new_cost         priority = new_cost + heuristic(goal, next)         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="深入启发函数"><a href="#深入启发函数" class="headerlink" title="深入启发函数"></a>深入启发函数</h3><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li><p>在极端情况下，当启发函数<code>h(n)</code>始终为0，则将由<code>g(n)</code>决定节点的优先级，此时算法就退化成了Dijkstra算法。</p></li><li><p><del>如果<code>h(n)</code>始终小于等于节点<code>n</code>到终点的代价，则A*算法保证一定能够找到最短路径。但是当<code>h(n)</code>的值越小，算法将遍历越多的节点，也就导致算法越慢.</del></p></li><li><p>如果<code>h(n)</code>完全等于节点<code>n</code>到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远.</p></li><li><p><del>如果<code>h(n)</code>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快</del></p></li><li><p>在另外一个极端情况下，如果<code>h(n)</code>相较于<code>g(n)</code>大很多，则此时只有<code>h(n)</code>产生效果，这也就变成了最佳优先搜索。</p></li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><ul><li><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li><p>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。</p><pre><code class="lang-py">function heuristic(node) =  # D是指两个相邻节点之间的移动代价,通常是一个固定的常数  dx = abs(node.x - goal.x)  dy = abs(node.y - goal.y)  return D * (dx + dy)</code></pre></li><li><p>如果图形中允许朝八个方向移动，则可以使用对角距离。</p><pre><code class="lang-py">  # 这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是sqrt(2)*D  function heuristic(node) =    dx = abs(node.x - goal.x)    dy = abs(node.y - goal.y)    return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)</code></pre></li><li><p>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</p><pre><code class="lang-py">  # 欧几里得距离是指两个节点之间的直线距离  function heuristic(node) =    dx = abs(node.x - goal.x)    dy = abs(node.y - goal.y)    return D * sqrt(dx * dx + dy * dy)</code></pre></li></ul></li></ul><h3 id="A-代码实现"><a href="#A-代码实现" class="headerlink" title="A*代码实现"></a>A*代码实现</h3><ul><li>参考<a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm" target="_blank" rel="noopener">Implementation of A*</a></li></ul><pre><code class="lang-cpp">//A* algorithminline double heuristic(GridLocation a, GridLocation b) {  return std::abs(a.x - b.x) + std::abs(a.y - b.y);}template&lt;typename Location, typename Graph&gt;void a_star_search  (Graph graph,   Location start,   Location goal,   std::unordered_map&lt;Location, Location&gt;&amp; came_from,   std::unordered_map&lt;Location, double&gt;&amp; cost_so_far){  PriorityQueue&lt;Location, double&gt; frontier;  frontier.put(start, 0);  came_from[start] = start;  cost_so_far[start] = 0;  while (!frontier.empty()) {    Location current = frontier.get();    if (current == goal) {      break;    }    for (Location next : graph.neighbors(current)) {      double new_cost = cost_so_far[current] + graph.cost(current, next);      if (cost_so_far.find(next) == cost_so_far.end()          || new_cost &lt; cost_so_far[next]) {        cost_so_far[next] = new_cost;        double priority = new_cost + heuristic(next, goal);        frontier.put(next, priority);        came_from[next] = current;      }    }  }}</code></pre><h2 id="JPS算法"><a href="#JPS算法" class="headerlink" title="JPS算法"></a>JPS算法</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络整理</title>
      <link href="/2021/04/29/Recruitment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/29/Recruitment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计网体系结构"><a href="#计网体系结构" class="headerlink" title="计网体系结构"></a>计网体系结构</h1><h2 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h2><p>物理层，数据链路层，网络层，运输层，会话层，表示层，应用层</p><h2 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h2><p>网络接口层，网际层（IP），运输层（TCP,UDP），应用层</p><h2 id="五层"><a href="#五层" class="headerlink" title="五层"></a>五层</h2><p>物理层，数据链接层，网络层，运输层，应用层</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><ul><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道<br>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ul><h2 id="字节流和报文的区别"><a href="#字节流和报文的区别" class="headerlink" title="字节流和报文的区别"></a>字节流和报文的区别</h2><ul><li>TCP将应用层传过来的报文进行分段，放在发送缓冲区里，TCP发送的时候不管发送的是什么东西，直接按连续字节进行发送。</li><li>UDP将应用层传过来的报文直接加上头部进行发送，udp也没有缓冲区</li></ul><h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><ul><li><p>原因</p><blockquote><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p></blockquote></li><li><p>解决</p><blockquote><p>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。<br>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。<br>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。<br>使用更加复杂的应用层协议。</p></blockquote></li></ul><h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><ul><li><p>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</p></li><li><p>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</p></li><li><p>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</p></li><li><p>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p></li></ul><h1 id="实现udp可靠化"><a href="#实现udp可靠化" class="headerlink" title="实现udp可靠化"></a>实现udp可靠化</h1><ul><li>发送队列和接收队列</li><li>ACK、RTO计算、ARQ <blockquote><p>ACK确认比特   (ack确认号)<br>连接的往返时间成为 RTT<br>重传的超时时间 RTO<br>ARQ自动重传请求</p></blockquote></li><li>流量控制、拥塞控制</li></ul><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p><a href="https://zhuanlan.zhihu.com/p/84316213" target="_blank" rel="noopener">计算机网络太难？了解这一篇就够了</a></p><ul><li>A为客户端，B为服务器</li><li>一开始B创建传输控制块TCB,等待接受。然后A也创建TCB，向A发送请求，tcp报文段中SYN=1,seq=x.这次传输不传输数据</li><li>然后B接收到后，如果同意链接，发送报文段，SYN=1,ACK=1,seq=y,ack=x+1.</li><li>然后a接收到后，向B再发送确实报文,SYN=1,ACK=1,seq = x+1,ack = y+1。这里可以带数据也可以不带，不带的话不消耗序号，下次传输再seq=x+1</li></ul><h2 id="为什么不二次"><a href="#为什么不二次" class="headerlink" title="为什么不二次"></a>为什么不二次</h2><ul><li>防止信道内存在堵塞的报文，在结束链接后再次发给B，然后B就同意链接，一直等待a发送数据，导致资源消耗。如果三次链接的话，就要b再次收到a的确认报文才会建立链接</li></ul><h2 id="为什么不四次"><a href="#为什么不四次" class="headerlink" title="为什么不四次"></a>为什么不四次</h2><ul><li>完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ul><li>A-&gt;B FIN=1,seq=u(消耗一个序号),A进入终止等待1</li><li>B-&gt;A ACK=1,ack=u+1,seq=y(B进入关闭等待，a到b已经无数据传送，b到a还要继续传输剩下的数据)，然后a接收到后进入终止等待2，等待b发送终止信号</li><li>B-&gt;A FIN=1,seq=w,ACK=1,ack=u+1(重新发送ACK=1和ack=u+1)，此时B处于最后确认</li><li>A-&gt;B ACK=1,seq=u+1,ack=w+1（seq因为消耗了一个序号所以为u+1），b接收到后关闭，a进入等待。TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。</li></ul><h2 id="二三次合并？"><a href="#二三次合并？" class="headerlink" title="二三次合并？"></a>二三次合并？</h2><ul><li>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</li></ul><h2 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL?"></a>2MSL?</h2><ul><li><p>保证第四次挥手时，tcp报文不会丢失，导致a关闭了，b没关，所以在2msl内要是有b发送的重传报文则需要重新发送，并重新计时</p></li><li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p></li></ul><h2 id="保活计时器？"><a href="#保活计时器？" class="headerlink" title="保活计时器？"></a>保活计时器？</h2><ul><li>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</li></ul><h1 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h1><ul><li>数据包校验</li><li>对失序数据包重排序</li><li>丢弃重复数据</li><li>应答机制（ack确认）</li><li>超时重发</li><li>流量控制，拥塞控制</li></ul><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><ul><li><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p></li><li><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p></li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><ul><li><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p></li><li><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></li><li><p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p></li></ul><h2 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h2><ul><li>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li></ul><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><ul><li><p>到达慢开始阈值的时候，拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p></li><li><p>如果出现了超时，则令 ssthresh（慢开始阈值） = cwnd / 2，然后重新执行慢开始。</p></li></ul><h2 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h2><ul><li><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p></li><li><p>在发送方，如果收到三个重复确认（3-ACK），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p></li></ul><h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><ul><li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li></ul><h1 id="http-post-get"><a href="#http-post-get" class="headerlink" title="http(post get)"></a>http(post get)</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p></li><li><p>从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</p></li><li><p>从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</p></li><li><p>从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</p></li><li><p>就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</p></li><li><p>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法整理</title>
      <link href="/2021/04/27/Recruitment/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/27/Recruitment/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="topk"><a href="#topk" class="headerlink" title="topk"></a>topk</h1><ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></li></ul><pre><code class="lang-cpp">class Solution {public:    int partition(vector&lt;int&gt;&amp; nums,int i,int j)    {        int pviot = nums[i];        while(i &lt; j)        {            for(;i&lt;j &amp;&amp; nums[j] &lt;= pviot ;--j);                nums[i] = nums[j];            for(;i&lt;j &amp;&amp; nums[i] &gt;= pviot;++i);                nums[j] = nums[i];        }        nums[i] = pviot;        return i;    }    int quickSort(vector&lt;int&gt;&amp; nums,int i,int j ,int k)    {        int pos = partition(nums,i,j);        if(k &gt; pos)            return quickSort(nums,pos+1,j,k);        else if( k &lt; pos)            return quickSort(nums,i,pos-1,k);        else             return nums[pos];    }    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        return quickSort(nums,0,nums.size()-1,k-1);    }};</code></pre><h1 id="手撕堆排"><a href="#手撕堆排" class="headerlink" title="手撕堆排"></a>手撕堆排</h1><pre><code class="lang-cpp">class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     * 将给定数组排序     * @param arr int整型vector 待排序的数组     * @return int整型vector     */    void HeapShiftDown(vector&lt;int&gt;&amp; arr,int k,int n)    {        for(int m = k*2+1; m &lt; n; m=m*2+1)        {            if(m+1 &lt; n &amp;&amp; arr[m+1] &gt; arr[m])                 m++;            if(arr[m]&gt; arr[k])            {               swap(arr[k],arr[m]);                k = m;            }            else                break;        }    }    void HeapAdjust(vector&lt;int&gt;&amp; arr)    {        int k = (arr.size()-1)/2;        for(int i = k; i &gt;=0;--i)            HeapShiftDown(arr,i,arr.size());    }    vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) {        // write code here        int n = arr.size();        HeapAdjust(arr);        for(int i = n-1;i&gt;0;--i)        {            swap(arr[0],arr[i]);            HeapShiftDown(arr,0,i);        }        return arr;    }};</code></pre><h1 id="手撕快速"><a href="#手撕快速" class="headerlink" title="手撕快速"></a>手撕快速</h1><ul><li><p><a href="https://www.zhihu.com/question/22393997" target="_blank" rel="noopener">复杂度证明</a></p><pre><code class="lang-cpp">class Solution {public:  /**   * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可   * 将给定数组排序   * @param arr int整型vector 待排序的数组   * @return int整型vector   */  int Partition(vector&lt;int&gt;&amp; nums,int i,int j)  {      int pivot = nums[i];      while(i&lt;j)      {            while(i&lt;j &amp;&amp; nums[j] &gt;= pivot)                --j;              nums[i] = nums[j];          while(i&lt;j &amp;&amp; nums[i] &lt;= pivot)                ++i;              nums[j] = nums[i];      }      nums[i] = pivot;      return i;  }  void QuickSort(vector&lt;int&gt;&amp; nums,int i,int j)  {      if(i &lt; j)      {          int index = Partition(nums,i,j);          QuickSort(nums, i, index-1);          QuickSort(nums, index+1, j);       }  }  vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) {      // write code here      QuickSort(arr, 0, arr.size()-1);      return arr;  }};</code></pre></li></ul><h1 id="手撕归并"><a href="#手撕归并" class="headerlink" title="手撕归并"></a>手撕归并</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v;    int a=i,b=mid+1;    while(a &lt;= mid &amp;&amp; b &lt;=j)    {        if(nums[a] &lt; nums[b])        {            v.push_back(nums[a]);            ++a;        }        else        {            v.push_back(nums[b]);            ++b;           }    }    while(a &lt;= mid)    {        v.push_back(nums[a]);        ++a;    }    while(b &lt;= j)    {        v.push_back(nums[b]);        ++b;       }    for(int k= 0; k&lt; v.size();++k)        nums[i+k] = v[k];}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    if(i &lt; j)    {        int mid = i + (j-i)/2;        MergeSort(nums,i,mid);        MergeSort(nums,mid+1,j);        Merge(nums,i,mid,j);    }}int main(){    int n;    cin&gt;&gt;n;    vector&lt;int&gt; v(n,0);    for(int i = 0; i&lt; n; ++i)    {        cin&gt;&gt;v[i];    }    MergeSort(v,0,n-1);    for(int i =0; i &lt; v.size();++i)    {        cout&lt;&lt;v[i];        if(i != v.size()-1)            cout&lt;&lt;&quot; &quot;;    }    return 0;}</code></pre><h1 id="最长回文字串"><a href="#最长回文字串" class="headerlink" title="最长回文字串"></a>最长回文字串</h1><ul><li>dp</li></ul><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        string res;        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(),vector&lt;bool&gt;(s.size(),false));        for(int i = s.size()-1; i&gt;=0 ;--i)        {            for(int j = i; j &lt; s.size();++j)            {                if( (j-i &gt; 1 &amp;&amp; s[i] == s[j] &amp;&amp; dp[i+1][j-1]) || (j-i &lt;= 1 &amp;&amp; s[i] == s[j] ))                {                    dp[i][j] = true;                    if(j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);                }            }        }        return res;    }};</code></pre><ul><li><p>中心扩展</p><pre><code class="lang-cpp">class Solution {public:  pair&lt;int,int&gt; expandAroundCenter(string s,int i,int j)  {      while(i&gt;=0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j])      {          --i;          ++j;      }      return {i+1,j-1};  }  string longestPalindrome(string s) {      int start=0,end = 0;      for(int i = 0; i &lt; s.size();++i)      {          auto [left1,right1] = expandAroundCenter(s,i,i);          auto [left2,right2] = expandAroundCenter(s,i,i+1);          if(right1 -left1 &gt; end -start)          {              end = right1;              start = left1;          }          if(right2 - left2 &gt; end - start)          {              end = right2;              start = left2;          }      }      return s.substr(start,end-start+1);  }};</code></pre></li></ul><h1 id="最大连续子数组的和"><a href="#最大连续子数组的和" class="headerlink" title="最大连续子数组的和"></a>最大连续子数组的和</h1><ul><li>dp</li></ul><pre><code class="lang-cpp">class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int res = nums[0];        vector&lt;int&gt; dp(n,nums.size());        dp[0] = nums[0];        for(int i = 1; i &lt; nums.size();++i)        {            if(dp[i-1] + nums[i] &lt; nums[i])                dp[i] = nums[i];            else                dp[i] = dp[i-1] + nums[i];            res = max(res,dp[i]);        }        return res;    }};</code></pre><h1 id="如果删除vector中间元素-怎么实现（不能用erease，无序）"><a href="#如果删除vector中间元素-怎么实现（不能用erease，无序）" class="headerlink" title="如果删除vector中间元素 怎么实现（不能用erease，无序）"></a>如果删除vector中间元素 怎么实现（不能用erease，无序）</h1><ul><li>将中间之后的元素往前移动一个位置并vector大小减一</li></ul><h1 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h1><pre><code class="lang-cpp">#include &lt;QCoreApplication&gt;#include &lt;assert.h&gt;#include &lt;QDebug&gt;//普通版本的strcpy，实现没有检查dst和src内存重叠问题,会崩溃char* myStrcpy(char* dst, const char* src){ //const约束,内容不可变    assert(src != Q_NULLPTR &amp;&amp; dst != Q_NULLPTR); //参数非0检验    char* pstr = dst;    while ((*dst++ = *src++) != &#39;\0&#39;){}    return pstr;}//检查内存重叠char* my1Strcpy(char* dst, const char* src){    assert(src != Q_NULLPTR &amp;&amp; dst != NULL);    char * nsrc = const_cast&lt;char*&gt;(src);    char * adest = dst;    size_t size = strlen(src);    if (src &lt; dst &amp;&amp; (src + size) &gt; dst) {        //内存重叠,从后向前复制        char* bsrcp = nsrc + size - 1;        char* bdestp = dst + size - 1;        while ((*bdestp-- = *bsrcp--) &amp;&amp; size-- != 0){}    } else {        while ((*dst++ = *nsrc++) != &#39;\0&#39;){}    }    return dst;}int main(int argc, char *argv[]){    QCoreApplication a(argc, argv);    char dest[10] = &quot;hello&quot;;    qDebug() &lt;&lt; my1Strcpy(&amp;dest[3], dest) &lt;&lt; endl;    return a.exec();}</code></pre><h1 id="输入1-n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）"><a href="#输入1-n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）" class="headerlink" title="输入1~n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）"></a>输入1~n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）</h1><p>对于删除一个数，大概有四种方法：</p><p>（1）用1+2+…+n减去当前输入数据的总和。时间复杂度：O(n) 空间复杂度：O(1) 【容易溢出】</p><p>（2）用1<em>2…</em>n除以当前输入数据的总积。时间复杂度：O(n) 空间复杂度：O(1) 【容易溢出】</p><p>（3）用1^2^…^n的结果在逐个异或当前输入数据。时间复杂度：O(n) 空间复杂度：O(1)</p><p>（4）对输入数据进行Hash，然后从头到尾遍历一次。时间复杂度O(n) 空间复杂度O(n)</p><h1 id="输入1-n共n个数，打乱后随机删除一个，再复制一个，找出这两个数"><a href="#输入1-n共n个数，打乱后随机删除一个，再复制一个，找出这两个数" class="headerlink" title="输入1~n共n个数，打乱后随机删除一个，再复制一个，找出这两个数"></a>输入1~n共n个数，打乱后随机删除一个，再复制一个，找出这两个数</h1><ul><li><p>类似 剑指 Offer 56 - I. 数组中数字出现的次数</p><ul><li>第一轮整体遍历，求出a^b（因为相同的数字异或为0，0异或任何数字为数字自身）</li><li>然后结合a^b以及原来数组求出这两个数字</li><li>原理：用一个只有一位为1的数字来遍历异或整个数组，把这个数组分成两个子数组（异或结果相同的数字在同一个子数组），如果是两个相同的数字，它们一定在同一个子数组里（保证子数组异或时为0），现在只需要把两个只出现一次的数字分到不同的子数组，那么子数组分别遍历异或得到的两个数字就是这两个数字。</li><li>怎么把两个只出现一次的数字分到不同地子数组？<ul><li>找到a^b第一个为1的位置，异或结果为1说明a和b在这一位上不同，那用只有这一位为1的数字m去分别异或a和b，得到的结果一定不同，也就把a和b分到了不同的子数组。结合上一点得出结果。</li></ul></li></ul></li><li><p>实在写不出来hash</p></li></ul><h1 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h1><pre><code class="lang-cpp">/** * struct TreeNode { *    int val; *    struct TreeNode *left; *    struct TreeNode *right; * }; */class Solution {public:    /**     *      * @param root TreeNode类 the root of binary tree     * @return int整型vector&lt;vector&lt;&gt;&gt;     */    vector&lt;int&gt; preorder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur;        s.push(root);        while(!s.empty())        {            cur = s.top();            s.pop();            res.push_back(cur-&gt;val);            if(cur-&gt;right)                s.push(cur-&gt;right);            if(cur-&gt;left)                s.push(cur-&gt;left);        }        return res;    }    vector&lt;int&gt; inorder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur = root;        while(!s.empty() || cur != nullptr)        {            if(cur != nullptr)            {                s.push(cur);                cur = cur-&gt;left;            }            else            {                cur = s.top();                s.pop();                res.push_back(cur-&gt;val);                cur = cur-&gt;right;            }        }        return res;    }    vector&lt;int&gt; postoreder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur = root;        TreeNode* pre = nullptr;        while(!s.empty() || cur != nullptr)        {            if(cur!=nullptr) {                s.push(cur);                cur = cur-&gt;left;            }            else {                cur = s.top();                s.pop();                if(cur-&gt;right==nullptr || pre==cur-&gt;right) { // 访问节点的条件                    res.push_back(cur-&gt;val); // 访问                    pre = cur; // 这一步是记录上一次访问的节点                    cur = nullptr; // 此处为了跳过下一次循环的访问左子节点的过程，直接进入栈的弹出阶段，因为但凡在栈中的节点，它们的左子节点都肯定被经过且已放入栈中。                }                else                 { // 不访问节点的条件                    s.push(cur); // 将已弹出的根节点放回栈中                    cur = cur-&gt;right; // 经过右子节点                }        }    }         return res;}    vector&lt;vector&lt;int&gt; &gt; threeOrders(TreeNode* root) {        // write code here        vector&lt;vector&lt;int&gt; &gt; res;        res.push_back(preorder(root));        res.push_back(inorder(root));        res.push_back(postoreder(root));        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学整理</title>
      <link href="/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html" target="_blank" rel="noopener">细说图形学渲染管线</a></p><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><h2 id="Broad-Phase"><a href="#Broad-Phase" class="headerlink" title="Broad-Phase"></a>Broad-Phase</h2><p><a href="https://zhuanlan.zhihu.com/p/113415779" target="_blank" rel="noopener">游戏物理引擎(二) 碰撞检测之Broad-Phase</a></p><ul><li><p>Broad-Phase使用某种Bounding Volume来表示刚体的碰撞信息,然后用空间划分的方式来保存这些Bounding Volume,就可以再较短的时间内筛选出可能互相碰撞的刚体对.</p></li><li><p>AABB包围盒</p></li></ul><h3 id="Uniform-Grid"><a href="#Uniform-Grid" class="headerlink" title="Uniform Grid"></a>Uniform Grid</h3><ul><li>将空间划分成等大方块</li></ul><h3 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h3><ul><li>每次只沿某一个轴划分 二叉树like</li></ul><h3 id="Oct-Tree"><a href="#Oct-Tree" class="headerlink" title="Oct-Tree"></a>Oct-Tree</h3><ul><li>三维均匀切分,设置每一块的终止条件</li></ul><h3 id="BSP-Tree"><a href="#BSP-Tree" class="headerlink" title="BSP-Tree"></a>BSP-Tree</h3><ul><li>每次取一个方向（非横平竖直）将空间分为两部分 （会很麻烦）</li></ul><h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><ul><li><p>以object为单位划分空间</p></li><li><p>二叉树，两个子节点分别存两部分物体的AABB</p></li><li><p>一个物体只可能出现在一个包围盒中</p></li><li><p>如何划分很有讲究，不好的划分会使包围盒重合，降低效率</p><blockquote><p>可以用topk算法快速找中位物体划分</p></blockquote></li></ul><h2 id="Narrow-Phase"><a href="#Narrow-Phase" class="headerlink" title="Narrow-Phase"></a>Narrow-Phase</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/127844705" target="_blank" rel="noopener">游戏物理引擎(三) 碰撞检测之Narrow-Phase</a></li></ul><h3 id="Separating-Axis-Theorem-SAT-算法"><a href="#Separating-Axis-Theorem-SAT-算法" class="headerlink" title="Separating Axis Theorem(SAT)算法"></a>Separating Axis Theorem(SAT)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/176667175" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（一） - SAT</a></li></ul><h3 id="Gilbert-Johnson-Keerthi-GJK-算法"><a href="#Gilbert-Johnson-Keerthi-GJK-算法" class="headerlink" title="Gilbert-Johnson-Keerthi (GJK)算法"></a>Gilbert-Johnson-Keerthi (GJK)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（上）</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（下）</a></li></ul><h1 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a>DrawCall</h1><p><a href="https://zhuanlan.zhihu.com/p/358687016" target="_blank" rel="noopener">Unity:浅谈对Drawcall的理解</a></p><ul><li>渲染分为三个阶段:应用阶段、几何阶段、光栅化阶段</li><li>Drawllcall就是应用阶段收集完模型的顶点材质以及其他数据后,CPU去通知GPU去对所传递的图元进行渲染。</li></ul><h2 id="为啥要减少drawcall呢？"><a href="#为啥要减少drawcall呢？" class="headerlink" title="为啥要减少drawcall呢？"></a>为啥要减少drawcall呢？</h2><ul><li>传输数据消耗较大，GPU的计算能力又非常优秀，那么存在一种情况:Cpu传递的drawcall指令只渲染一小部分，GPU飞快的渲染完了，而下一条drawcall的指令还没有完成传输过程。此类的指令过多就造成了卡顿。所以提高drawcall传输效率就非常有必要了</li></ul><h2 id="减少drawcall的方法"><a href="#减少drawcall的方法" class="headerlink" title="减少drawcall的方法"></a>减少drawcall的方法</h2><ul><li>主要的方法就是合批（Batch），合批又分为静态合批，动态合批两个不同的操作</li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>mipmap（多级渐远纹理）<blockquote><p>它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一,每提升一个Level，对相邻的四个元素进行插值。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p></blockquote></li></ul><h1 id="前向渲染和延迟渲染"><a href="#前向渲染和延迟渲染" class="headerlink" title="前向渲染和延迟渲染"></a>前向渲染和延迟渲染</h1><h1 id="齐次坐标和透视除法"><a href="#齐次坐标和透视除法" class="headerlink" title="齐次坐标和透视除法"></a>齐次坐标和透视除法</h1><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul><li><p>目的：为了解决欧式几何空间中两条支线是不能相交的，但透视空间两条支线是可以相交的。</p></li><li><p>齐次坐标就是用N+1维来代表N维坐标，通过添加一个额外的分量w，</p></li></ul><blockquote><p>如果(x,y,z)是个点，则变为(x,y,z,1);<br>如果(x,y,z)是个向量，则变为(x,y,z,0);</p></blockquote><h2 id="透视除法"><a href="#透视除法" class="headerlink" title="透视除法"></a>透视除法</h2><ul><li>透视除法不在vs中进行，vs转换得到的是裁剪空间，透视除法在光栅化之前进行</li><li>透视除法将齐次坐标的每一个分量除以w，得到NDC</li><li>透视除法可以将齐次坐标转换成欧式坐标</li></ul><h1 id="欧拉角和万向结死锁"><a href="#欧拉角和万向结死锁" class="headerlink" title="欧拉角和万向结死锁"></a>欧拉角和万向结死锁</h1><p><a href="https://zhuanlan.zhihu.com/p/42519819" target="_blank" rel="noopener">3D游戏世界里的万向节锁</a></p><ul><li>万向结死锁就是一个物体在一个3D世界里面随着旋转顺序和旋转角度的改变，导致物体只能在一个固定的平面旋转，无法旋转到你预想的角度。由于物体的旋转，物体的坐标轴方向也发生了改变，导致其中2条坐标轴发生了重合。当你围绕着重合的坐标轴旋转时，物体的旋转方向始终在一个平面上旋转。</li></ul><h1 id="画线算法"><a href="#画线算法" class="headerlink" title="画线算法"></a>画线算法</h1><ul><li>光栅直线的特点<blockquote><p>X的值每次增长1 </p></blockquote></li></ul><blockquote><p>Y的值会在保持不变和增长1之间选择</p></blockquote><h2 id="DDA"><a href="#DDA" class="headerlink" title="DDA"></a>DDA</h2><h2 id="Bresenham"><a href="#Bresenham" class="headerlink" title="Bresenham"></a>Bresenham</h2><h1 id="点到平面计算距离"><a href="#点到平面计算距离" class="headerlink" title="点到平面计算距离"></a>点到平面计算距离</h1><p><img src="点到直线距离.png" alt></p><ul><li>设点为P，根据屏幕方程得到平面法向量N,取平面上一点Q,连接PQ,得到向量QP,设两条向量的夹角为Alpha,则cos(Alpha)可求，然后根据三角函数，距离可求</li></ul><h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>$\left[\begin{matrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{matrix} \right]$</p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li>绕x轴</li></ul><p>$\left[\begin{matrix}<br>    1 &amp; 0 &amp; 0 &amp; 0\\<br>    0 &amp; cos\theta  &amp; -sin\theta &amp; 0\\<br>    0 &amp; sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕y轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; 0 &amp; sin\theta &amp; 0\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\<br>    -sin\theta &amp; 0 &amp; cos\theta  &amp; 0 \\<br>        0 &amp; 0 &amp; 0 &amp; 1   \\<br>\end{matrix} \right]$</p><ul><li>绕z轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; -sin\theta &amp; 0 &amp; 0\\<br>    sin\theta &amp; cos\theta  &amp; 0 &amp; 0\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕任意轴<blockquote><p>太复杂了</p></blockquote></li></ul><blockquote><p>绕任意轴都可以轴上面三个组合得到</p></blockquote><h1 id="正交矩阵的逆矩阵"><a href="#正交矩阵的逆矩阵" class="headerlink" title="正交矩阵的逆矩阵"></a>正交矩阵的逆矩阵</h1><ul><li>转置</li></ul><h1 id="shaowmap"><a href="#shaowmap" class="headerlink" title="shaowmap"></a>shaowmap</h1><h1 id="延迟渲染和前向渲染"><a href="#延迟渲染和前向渲染" class="headerlink" title="延迟渲染和前向渲染"></a>延迟渲染和前向渲染</h1><h1 id="深度是什么，深度值啥时候写入"><a href="#深度是什么，深度值啥时候写入" class="headerlink" title="深度是什么，深度值啥时候写入"></a>深度是什么，深度值啥时候写入</h1><ul><li>光栅化的时候就能知道深度值</li></ul><h1 id="怎样从一个旋转缩放矩阵中拆分出缩放矩阵"><a href="#怎样从一个旋转缩放矩阵中拆分出缩放矩阵" class="headerlink" title="怎样从一个旋转缩放矩阵中拆分出缩放矩阵"></a>怎样从一个旋转缩放矩阵中拆分出缩放矩阵</h1><ul><li>缩放分量就是矩阵</li><li>中每一列的模的大小，然后得出缩放后除以相应大小就能得到旋转矩阵</li></ul><h1 id="点乘和叉乘应用场景"><a href="#点乘和叉乘应用场景" class="headerlink" title="点乘和叉乘应用场景"></a>点乘和叉乘应用场景</h1><ul><li>点乘可以快速得到两向量之间的夹角，判断两个向量是否同方向  </li><li>判定左右和内外</li></ul><h2 id="怎么判断一个点在矩形内，园内，三角形内"><a href="#怎么判断一个点在矩形内，园内，三角形内" class="headerlink" title="怎么判断一个点在矩形内，园内，三角形内"></a>怎么判断一个点在矩形内，园内，三角形内</h2><ul><li>通过叉乘判断是否这个点都在这个形状的一侧，如果都在一侧就是在内部，不然都在外部</li></ul><h1 id="Phong和blinnphong的区别"><a href="#Phong和blinnphong的区别" class="headerlink" title="Phong和blinnphong的区别"></a>Phong和blinnphong的区别</h1><p>phong = 环境光+漫反射+镜面反射<br>blinnphong在phong的高光部分进行修改，用法线和半角向量</p><h2 id="blinnphong的优缺点"><a href="#blinnphong的优缺点" class="headerlink" title="blinnphong的优缺点"></a>blinnphong的优缺点</h2><ul><li>运算效率高在Phong模型中，必须计算反射光线R，但是在BlinnPhong模型中，用N·H的值来取代V·R。</li><li>2.高光更加柔和、真实感没Phong模型强BlinnPhong 引入了 法线直接计算高光。在phong中，法线只是用于计算入射光线的反射光线，结果要比Phong更加柔和。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 智能指针</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/150555165" target="_blank" rel="noopener">现代 C++：一文读懂智能指针</a></p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h2><p>头文件：<code>#include &lt;memory&gt;</code></p><h2 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h2><pre><code class="lang-cpp">std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</code></pre><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul><li>共享资源所有权的指针。</li></ul><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul><li>共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</li></ul><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>独占资源所有权的指针。</li></ul><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h3 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h3><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>Aliasing constructor<blockquote><p>简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p></blockquote></li></ul><pre><code class="lang-cpp">// shared_ptr constructor example#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;using Vec = std::vector&lt;int&gt;;std::shared_ptr&lt;int&gt; GetSPtr() {    auto elts = {0, 1, 2, 3, 4};    std::shared_ptr&lt;Vec&gt; pvec = std::make_shared&lt;Vec&gt;(elts); //use_count == 1    std::shared_ptr&lt;int&gt; t(pvec, &amp;(*pvec)[2]);  //use_count == 2    pvec.reset(); // use_count == 1    return t;}int main() {    std::shared_ptr&lt;int&gt; sptr = GetSPtr();// use_count == 1 ,t,pvec都销毁,sptr引用    sptr.reset();// use_count == 1    cout&lt;&lt;*sptr.get()&lt;&lt;endl;  // =2  指向的是&amp;(*pvec)[2],并且延长了pvec指向vector&lt;int&gt;的生命周期    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理</title>
      <link href="/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vector实现原理"><a href="#vector实现原理" class="headerlink" title="vector实现原理"></a>vector实现原理</h1><p><a href="https://zhuanlan.zhihu.com/p/358113531" target="_blank" rel="noopener">(新手向)谈谈C++中的萃取</a><br><a href="https://blog.csdn.net/ncepu_Chen/article/details/114947710" target="_blank" rel="noopener">侯捷C++课程笔记03: STL标准库与泛型编程</a></p><ul><li>容器<code>vector</code>的代码如下:</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc= alloc&gt;class vector {public:    typedef T value_type;    typedef value_type* iterator;    typedef value_type&amp; reference;    typedef size_t size_type;protected:    iterator start;    iterator finish;    iterator end_of_storage;public:    iterator begin() { return start; }    iterator end() { return finish; }    size_type size() const { return size_type(end() - begin()); }    size_type capacity() const { return size_type(end_of_storage - begin()); }    bool empty() const { return begin() == end(); }    reference operator[](size_type n) { return *(begin() + n); }    reference front() { return *begin(); }    reference back() { return *(end() - 1); }};</code></pre><p><img src="https://img-blog.csdnimg.cn/20210321014124690.png" alt></p><p>容器<code>vector</code>的迭代器<code>start</code>指向第一个元素,迭代器<code>finish</code>指向最后一个元素的下一个元素,这两个迭代器对应begin()和end()的返回值,维持了<strong>前闭后开</strong>的特性.</p><p><code>vector</code><strong>对使用者是连续的</strong>,因此重载了<code>[]</code>运算符.</p><p><code>vector</code><strong>的实现也是连续的</strong>,因此使用指针类型做迭代器(即迭代器<code>vector&lt;T&gt;::iterator</code>的实际类型是原生指针<code>T*</code>).</p><h2 id="内存满了怎么办（push-back）"><a href="#内存满了怎么办（push-back）" class="headerlink" title="内存满了怎么办（push_back）"></a>内存满了怎么办（push_back）</h2><ul><li><code>vector::push_back</code>方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用<code>insert_aux</code>函数先扩容两倍再插入元素.</li></ul><pre><code class="lang-cpp">void push_back(const T &amp;x) {    if (finish != end_of_storage) { // 尚有备用空间,则直接插入,并调整finish迭代器        construct(finish, x);                ++finish;                        } else                             // 已无备用空间则调用 insert_aux 先扩容再插入元素        insert_aux(end(), x);}</code></pre><ul><li><code>insert_aux</code>被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_ux(iterator position, const T &amp;x) {    if (finish != end_of_storage) {     // 尚有备用空间,则将插入点后元素后移一位并插入元素，因为这个函数还会被其他函数调用，比如insert之类的所以还是要检查        construct(finish, *(finish - 1));   // 以vector最后一个元素值为新节点的初值        ++finish;        T x_copy = x;        copy_backward(position, finish - 2, finish - 1);        *position = x_copy;    } else {        // 已无备用空间,则先扩容,再插入        const size_type old_size = size();        const size_type len = old_size != 0 ?: 2 * old_size:1;  // 扩容后长度为原长度的两倍        iterator new_start = data_allocator::allocate(len);        iterator new_finish = new_start;        try {            new_finish = uninitialized_copy(start, position, new_start);    // 拷贝插入点前的元素            construct(new_finish, x);                                       // 插入新元素并调整水位            ++new_finish;            new_finish = uninitialized_copy(position, finish, new_finish);  // 拷贝插入点后的元素()，还是比如说insert函数，这种情况就要把后面的元素进行拷贝        }        catch (...) {            // 插入失败则回滚,释放内存并抛出错误            destroy(new_start, new_finish) :            data_allocator::deallocate(new_start, len);            throw;        }        // 释放原容器所占内存        destroy(begin(), end());        deallocate();        // 调整迭代器        start = new_start;        finish = new_finish;        end_of_storage = new_start + len;    }};</code></pre><h1 id="map实现原理"><a href="#map实现原理" class="headerlink" title="map实现原理"></a>map实现原理</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h1 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h1><ul><li>复杂度O(1)</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>直接定址法</li></ul><p><code>H(key) = key</code> 或 <code>H(Key) = a * key + b</code></p><ul><li>除留余数法</li></ul><p><code>H(key) = key % p(p &lt;=m , m = 散列表长)</code></p><ul><li><p>数字分析法</p><ul><li>如果关键字是r进行数，取数码分布比较均价的若干位作为key</li></ul></li><li><p>平法取中法</p><ul><li>将关键字平法取中间几位</li></ul></li></ul><h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><ul><li>空闲地址既可以存放同义词也可以存放非同义词</li></ul><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><h4 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h4><h4 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h4><hr><ul><li>开放定址法不能删除已有元素</li></ul><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>将同义词存放在一个线性表中</p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 RTTI</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/</url>
      
        <content type="html"><![CDATA[<h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><p>typeid、type_info 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Flyable                       // 能飞的{public:    virtual void takeoff() = 0;     // 起飞    virtual void land() = 0;        // 降落};class Bird : public Flyable         // 鸟{public:    void foraging() {...}           // 觅食    virtual void takeoff() {...}    virtual void land() {...}    virtual ~Bird(){}};class Plane : public Flyable        // 飞机{public:    void carry() {...}              // 运输    virtual void takeoff() {...}    virtual void land() {...}};class type_info{public:    const char* name() const;    bool operator == (const type_info &amp; rhs) const;    bool operator != (const type_info &amp; rhs) const;    int before(const type_info &amp; rhs) const;    virtual ~type_info();private:    ...};void doSomething(Flyable *obj)                 // 做些事情{    obj-&gt;takeoff();    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;        // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）    if(typeid(*obj) == typeid(Bird))            // 判断对象类型    {        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化        bird-&gt;foraging();    }    obj-&gt;land();}int main(){    Bird *b = new Bird();    doSomething(b);    delete b;    b = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 只在堆上或栈上生成对象的类</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h1><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p></blockquote><h2 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h2><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h2 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h2><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 delete this</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/</url>
      
        <content type="html"><![CDATA[<h1 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h1><blockquote><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p></blockquote><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 内存分配和管理</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h1><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h1 id="malloc与free"><a href="#malloc与free" class="headerlink" title="malloc与free"></a>malloc与free</h1><p>用于分配、释放内存</p><p>malloc、free 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">char *str = (char*) malloc(100);assert(str != nullptr);</code></pre><p>释放内存后指针置空</p><pre><code class="lang-cpp">free(p); p = nullptr;</code></pre><h1 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h1><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><p>new、delete 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">int main(){    T* t = new T();     // 先内存分配 ，再构造函数    delete t;           // 先析构函数，再内存释放    return 0;}</code></pre><h1 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h1><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><pre><code class="lang-cpp">new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list }</code></pre><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 虚函数</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/439495026" target="_blank" rel="noopener">请问虚析构函数是如何执行的?</a><br><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li>析构函数： 父类的后执行，子类的先执行</li></ul><h2 id="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"><a href="#构造函数不能定义为虚函数，析构函数一般需要定义为虚函数" class="headerlink" title="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"></a>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</h2><ul><li><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></li></ul><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><pre><code class="lang-cpp">virtual int A() = 0;</code></pre><h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文<strong>虚继承</strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p></blockquote><h1 id="虚函数指针与虚函数表"><a href="#虚函数指针与虚函数表" class="headerlink" title="虚函数指针与虚函数表"></a>虚函数指针与虚函数表</h1><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><blockquote><p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p></blockquote><ul><li>虚函数 C++对象的内存布局<ul><li>只有数据成员的对象</li><li>没有虚函数的对象</li><li>拥有仅一个虚函数的类对象</li><li>拥有多个虚函数的类对象</li><li>单继承且本身不存在虚函数的继承类的内存布局</li><li>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</li><li>定义了基类没有的虚函数的单继承的类对象布局</li><li>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</li><li>如果第1个直接基类没有虚函数(表)</li><li>What if 两个基类都没有虚函数表</li><li>如果有三个基类: 虚函数表分别是有, 没有, 有!</li></ul></li></ul><h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1><p>原因:虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。<br>目的：令某个类做出声明，承诺愿意共享它的基类<br>形式:</p><pre><code class="lang-cpp">//关键字public virtual的顺序随意class A:public virtual B;class C:virtual public B;</code></pre><ul><li><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></li><li><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></li></ul><p><a href="https://blog.csdn.net/longlovefilm/article/details/80558879" target="_blank" rel="noopener">C++ 虚继承实现原理（虚基类表指针与虚基类表</a></p><h2 id="虚继承与虚函数"><a href="#虚继承与虚函数" class="headerlink" title="虚继承与虚函数"></a>虚继承与虚函数</h2><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h1 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h1><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h1 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h1><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数·</li></ul></li></ul><h1 id="继承、向上转型、向下转型时虚函数调用规则"><a href="#继承、向上转型、向下转型时虚函数调用规则" class="headerlink" title="继承、向上转型、向下转型时虚函数调用规则"></a>继承、向上转型、向下转型时虚函数调用规则</h1><blockquote><p>参考:<a href="https://blog.csdn.net/o1101574955/article/details/77771357" target="_blank" rel="noopener">继承、向上转型、向下转型时虚函数调用规则</a></p></blockquote><ul><li>函数调用具体看三个关键信息：内存块的类型，当前类型，以及是否为虚函数<ul><li>对于虚函数,主要看查找谁的虚函数表<ul><li>对于对象调用函数,查找当前类型的类的虚函数表</li><li>对于指针类型,看内存块的具体类型,查找它的类的虚函数表’</li></ul></li><li>对于非虚函数，不涉及到查虚函数表的问题，直接调用当前类型的类里的函数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式整理</title>
      <link href="/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>单例模式</li></ul><pre><code class="lang-cpp">// 懒汉式单例模式class Singleton{private:    Singleton() { }    static Singleton * pInstance;public:    static Singleton * GetInstance()    {        if (pInstance == nullptr)            pInstance = new Singleton();        return pInstance;    }};// 线程安全的单例模式class Singleton{private:    Singleton() { }    ~Singleton() { }    Singleton(const Singleton &amp;);    Singleton &amp; operator = (const Singleton &amp;);public:    static Singleton &amp; GetInstance()    {        // 编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例        static Singleton instance; //对对象使用static会调用默认构造函数        return instance;    }};</code></pre><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 宏</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li><li>不做类型检查，在预编译阶段制作一对一替换</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 引用</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul><li>左值和右值<ul><li>辣鸡的C++ PRIMER解释<ul><li>左值(lvalue) : 是那些求值结果为对象或者函数的表达式，一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象。</li><li>右值(rvalue) : 是指一种表达式,其结果是值而非值所在的位置。 </li></ul></li><li>参考博客:<a href="https://blog.csdn.net/xuwqiang1994/article/details/79924310" target="_blank" rel="noopener">https://blog.csdn.net/xuwqiang1994/article/details/79924310</a><ul><li>左值(lvalue) : lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。</li><li>右值(rvalue) : rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是不在内存中占有确定位置的表达式。</li></ul></li><li>参考博客:<a href="https://blog.csdn.net/qq_24964575/article/details/52202989" target="_blank" rel="noopener">https://blog.csdn.net/qq_24964575/article/details/52202989</a><ul><li>左值可以当作右值使用,右值不能当左值用.</li><li>左值可以出现在=的任何一方,</li><li>出现在=右方的左值,是把左值当作右值使用,这是非常正常的.</li><li>右值,不能当作左值使用.</li><li>能够(单独)出现在=左方的是左值(实际是左右值,左值总是可以当作右值使用)</li><li>只能够出现在=右方的,是右值(纯粹的右值),不能当作左值使用.</li><li>左值代表地址单元,右值代表数据本身.</li><li>地址单元里的数据,是左值变量的右值的含义.</li><li>右值包括,纯数据,比如常数100,字符串常量”12345”等</li><li>以及地址单元中存储的数据.比如x ,这是左值当作右值使用代表的意义.</li><li>以及一些常变量(有确切地址的常量,可以象变量一样有个名字,其实就是变量,只是右值化了,不能当左值使用了)的含义.</li><li>左值代表存储器的一个单元.</li><li>这是一个物理概念,不仅仅是个地址(地址不过是个编号,是个数值而已),是个实实在在的东西.</li><li>右值代表数据,一个数值而已.</li></ul></li><li>参考博客:<a href="https://www.zhihu.com/question/382300648" target="_blank" rel="noopener">https://www.zhihu.com/question/382300648</a><ul><li>取地址符取到的是一个地址，没有实际存储在哪，所以是右值</li><li>如果是寄存器变量也没有地址，所以是右值</li></ul></li></ul></li></ul><blockquote><p>使用decltype时,左值返回引用类型，右值不返回引用类型。</p></blockquote><ul><li>对于自增自减（++i,i++）<ul><li>++i将对象本身作为左值返回</li><li>i++将对象原始值作为右值返回</li></ul></li></ul><h1 id="右值引用-c"><a href="#右值引用-c" class="headerlink" title="右值引用(c++)"></a>右值引用(c++)</h1><ul><li>定义 &amp;&amp;</li><li><p>右值引用只能引用到右值，不能引用到左值(const 例外)</p><blockquote><p>附加 <a href="https://www.zhihu.com/question/310966840" target="_blank" rel="noopener">为什么C++里const左值引用可以引用右值，这样做的考虑是什么？</a></p></blockquote></li><li><p>左值持久</p></li><li><p>右值短暂</p><ul><li>字面常量、临时对象</li><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul></li><li><p>引用右值的变量则是左值，不能再被右值引用</p></li></ul><pre><code class="lang-cpp">int &amp;&amp;rr1 = 42;//trueint &amp;&amp;rr2 = rr1;//error</code></pre><ul><li>move函数：获得绑定在左值上的右值引用<ul><li>调用move后，原变量除赋值和销毁外，不能再使用他</li></ul></li></ul><h2 id="右值引用作用"><a href="#右值引用作用" class="headerlink" title="右值引用作用"></a>右值引用作用</h2><ul><li>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul></li></ul><h1 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h1><p><a href="https://blog.csdn.net/zhangxiao93/article/details/74974546" target="_blank" rel="noopener">C++引用折叠</a></p><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li><li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li></ul><h1 id="右值引用详解"><a href="#右值引用详解" class="headerlink" title="右值引用详解"></a>右值引用详解</h1><ul><li>参考:<a href="https://www.jianshu.com/p/d19fc8447eaa" target="_blank" rel="noopener">[c++11]我理解的右值引用、移动语义和完美转发</a><h2 id="移动语义（Move-Sementics）—-移动构造和移动赋值"><a href="#移动语义（Move-Sementics）—-移动构造和移动赋值" class="headerlink" title="移动语义（Move Sementics）— 移动构造和移动赋值"></a>移动语义（Move Sementics）— 移动构造和移动赋值</h2></li><li>对于如下场景<ul><li>使用拷贝构造函数对string(“hello”)进行构造,会造成没有意义的资源申请和释放操作</li><li>而移动语义可以直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间</li></ul></li></ul><pre><code class="lang-cpp">  // 拷贝构造函数   MyString(const MyString&amp; str) {       CCtor ++;       m_data = new char[ strlen(str.m_data) + 1 ];       strcpy(m_data, str.m_data);   }   // 移动构造函数   MyString(MyString&amp;&amp; str) noexcept       :m_data(str.m_data) {       MCtor ++;       str.m_data = nullptr; //不再指向之前的资源了   }   // 拷贝赋值函数 =号重载   MyString&amp; operator=(const MyString&amp; str){       CAsgn ++;       if (this == &amp;str) // 避免自我赋值!!          return *this;       delete[] m_data;       m_data = new char[ strlen(str.m_data) + 1 ];       strcpy(m_data, str.m_data);       return *this;   }   // 移动赋值函数 =号重载   MyString&amp; operator=(MyString&amp;&amp; str) noexcept{       MAsgn ++;       if (this == &amp;str) // 避免自我赋值!!          return *this;       delete[] m_data;       m_data = str.m_data;       str.m_data = nullptr; //不再指向之前的资源了       return *this;   }</code></pre><ul><li>对于<code>String(&quot;hello&quot;)</code>它传入的参数是个临时对象,是右值,优先进入移动构造函数而不是拷贝构造函数<ul><li>拷贝构造函数是重新分配一块内存空间,将要拷贝的对象复制过来</li><li>因为对于构造的右值马上就会销毁,所以移动构造函数会将自己的指针指向内存中已有的资源.并将本来指向这个资源的指针置为nullptr</li></ul></li></ul><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h3><ul><li>对于一些生命周期短的局部左值,如果需要更充分的利用起来,可以使用std::move()将左值转换为右值，从而方便应用移动语义</li></ul><h2 id="universal-references-通用引用-—-引用折叠"><a href="#universal-references-通用引用-—-引用折叠" class="headerlink" title="universal references(通用引用) — 引用折叠"></a>universal references(通用引用) — 引用折叠</h2><ul><li><p>当右值引用和模板结合的时候.T&amp;&amp;并不一定表示右值引用，它可能是个左值引用又可能是个右值引用.</p><ul><li>这时&amp;&amp;是一个未定义的引用类型,称为universal references</li></ul></li><li><p>只有当发生自动类型推断时（如函数模板的类型自动推导，或auto关键字），&amp;&amp;才是一个universal references。</p></li></ul><pre><code class="lang-cpp">template&lt;typename T&gt;void f( T&amp;&amp; param); //这里T的类型需要推导，所以&amp;&amp;是一个 universal referencestemplate&lt;typename T&gt;class Test {  Test(Test&amp;&amp; rhs); //Test是一个特定的类型，不需要类型推导，所以&amp;&amp;表示右值引用  };void f(Test&amp;&amp; param); //右值引用//复杂一点template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param); //在调用这个函数之前，这个vector&lt;T&gt;中的推断类型//已经确定了，所以调用f函数的时候没有类型推断了，所以是 右值引用template&lt;typename T&gt;void f(const T&amp;&amp; param); //右值引用// universal references仅仅发生在 T&amp;&amp; 下面，任何一点附加条件都会使之失效</code></pre><h3 id="引用折叠-1"><a href="#引用折叠-1" class="headerlink" title="引用折叠"></a>引用折叠</h3><ul><li>当<code>T</code>被推导成了<code>string</code>, <code>T&amp;&amp;</code>就是<code>string&amp;&amp;</code></li><li><p>当<code>T</code>被推导成了<code>string&amp;</code>, <code>T&amp;&amp;</code>就是<code>string&amp; &amp;&amp;</code>,这将会发生引用折叠</p></li><li><p>规则如下:</p><ul><li>所有的右值引用叠加到右值引用上仍然使一个右值引用。</li><li>有的其他引用类型之间的叠加都将变成左值引用。</li></ul></li></ul><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><ul><li>转发:就是通过一个函数将参数继续转交给另一个函数进行处理</li><li>完美:原参数可能是右值，可能是左值，转发后保持参数的原有特征</li></ul><pre><code class="lang-cpp">void process(int&amp; i){    cout &lt;&lt; &quot;process(int&amp;):&quot; &lt;&lt; i &lt;&lt; endl;}void process(int&amp;&amp; i){    cout &lt;&lt; &quot;process(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; endl;}void myforward(int&amp;&amp; i){    cout &lt;&lt; &quot;myforward(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; endl;    process(i);}int main(){    int a = 0;    process(a); //a被视为左值 process(int&amp;):0    process(1); //1被视为右值 process(int&amp;&amp;):1    process(move(a)); //强制将a由左值改为右值 process(int&amp;&amp;):0    myforward(2);  //右值经过forward函数转交给process函数，却称为了一个左值，    //原因是该右值有了名字  所以是 process(int&amp;):2    myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&amp;):0    // myforward(a) // 错误用法，右值引用不接受左值}</code></pre><h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward()"></a>std::forward()</h3><ul><li>通过std::forward()可以完全转发右值<br>```cpp<br>void myforward(int&amp;&amp; i){<br>  cout &lt;&lt; “myforward(int&amp;&amp;):” &lt;&lt; i &lt;&lt; endl;<br>  process(std::forward<int>(i));<br>}</int></li></ul><p>myforward(2); // process(int&amp;&amp;):2</p><pre><code>* 对于同时解决左右值的完美转发,需要借助universal references通用引用类型和std::forward()模板函数共同实现完美转发.```cpp#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;void RunCode(int &amp;&amp;m) {    cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; endl;}void RunCode(int &amp;m) {    cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; endl;}void RunCode(const int &amp;&amp;m) {    cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; endl;}void RunCode(const int &amp;m) {    cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; endl;}// 这里利用了universal references，如果写T&amp;,就不支持传入右值，而写T&amp;&amp;，既能支持左值，又能支持右值template&lt;typename T&gt;void perfectForward(T &amp;&amp; t) {    RunCode(forward&lt;T&gt; (t));}template&lt;typename T&gt;void notPerfectForward(T &amp;&amp; t) {    RunCode(t);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 面向对象 -- 封装、继承、多态</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="https://gitee.com/huihut/interview/raw/master/images/面向对象基本特征.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>基类（父类）——&gt; 派生类（子类）<blockquote><p>继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p></blockquote></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><blockquote><p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p></blockquote><h3 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h3><p>函数重载</p><pre><code class="lang-cpp">class A{public:    void do(int a);    void do(int a, int b);};</code></pre><h3 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h3><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li></ul><p>动态多态使用</p><pre><code class="lang-cpp">class Shape                     // 形状类{public:    virtual double calcArea()    {        ...    }    virtual ~Shape();};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};class Rect : public Shape       // 矩形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    Shape * shape2 = new Rect(5.0, 6.0);    shape1-&gt;calcArea();         // 调用圆形类里面的方法    shape2-&gt;calcArea();         // 调用矩形类里面的方法    delete shape1;    shape1 = nullptr;    delete shape2;    shape2 = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 成员初始化列表</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><p>形式</p><pre><code class="lang-cpp">class test{public:    test(int _a,int _b):a(_a),b(_b);private:    int a;    int b;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 initializer_list初始化</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="含有可变（数量）形参的函数"><a href="#含有可变（数量）形参的函数" class="headerlink" title="含有可变（数量）形参的函数"></a>含有可变（数量）形参的函数</h1><ul><li><p><a href="https://blog.csdn.net/Clark_Sev/article/details/89500808?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">使用方法</a> </p></li><li><p>initializer_list 标准库类型</p><ul><li>成员永远是常量 </li><li>传递参数的时候用花括号括起来</li></ul></li><li><p>可变参模板</p><ul><li>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</li></ul></li></ul><p>initializer_list 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;template &lt;class T&gt;struct S {    std::vector&lt;T&gt; v;    S(std::initializer_list&lt;T&gt; l) : v(l) {         std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list\n&quot;;    }    void append(std::initializer_list&lt;T&gt; l) {        v.insert(v.end(), l.begin(), l.end());    }    std::pair&lt;const T*, std::size_t&gt; c_arr() const {        return {&amp;v[0], v.size()};  // 在 return 语句中复制列表初始化                                   // 这不使用 std::initializer_list    }};template &lt;typename T&gt;void templated_fn(T) {}int main(){    S&lt;int&gt; s = {1, 2, 3, 4, 5}; // 复制初始化    s.append({6, 7, 8});      // 函数调用中的列表初始化    std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\n&quot;;    for (auto n : s.v)        std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    std::cout &lt;&lt; &quot;Range-for over brace-init-list: \n&quot;;    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    auto al = {10, 11, 12};   // auto 的特殊规则    std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#39;\n&#39;;//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，                             // 它无类型，故 T 无法推导    templated_fn&lt;std::initializer_list&lt;int&gt;&gt;({1, 2, 3}); // OK    templated_fn&lt;std::vector&lt;int&gt;&gt;({1, 2, 3});           // 也 OK}</code></pre><ul><li>省略符形参<ul><li>应该只用在c和c++通用的类型，不适用于大多数类类型</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4面经</title>
      <link href="/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ai寻路怎么确保不跟其他ai撞等"><a href="#ai寻路怎么确保不跟其他ai撞等" class="headerlink" title="ai寻路怎么确保不跟其他ai撞等"></a>ai寻路怎么确保不跟其他ai撞等</h1><h1 id="抛物线模拟实现"><a href="#抛物线模拟实现" class="headerlink" title="抛物线模拟实现"></a>抛物线模拟实现</h1><h1 id="AI系统"><a href="#AI系统" class="headerlink" title="AI系统"></a>AI系统</h1><h2 id="UE4-NavMesh原理"><a href="#UE4-NavMesh原理" class="headerlink" title="UE4 NavMesh原理"></a>UE4 NavMesh原理</h2><ul><li><p>参考文章</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/74537236" target="_blank" rel="noopener">UE4 Navmesh寻路（一）Recast基础</a><br><a href="https://zhuanlan.zhihu.com/p/78873379" target="_blank" rel="noopener">UE4 Navmesh寻路（二）Detour寻路</a></p></blockquote></li><li><p>目前生成Navmesh数据主要有两种方式：多边形裁剪和体素化。</p><ul><li>多边形裁剪是直接对地形的多边形网格数据进行裁剪及合并，从而生成导航网格。方法比较直观，但难度更高，目前havok引擎使用了此方法。</li><li>体素化是对地形多边形网格进行栅格化，然后用这些“格子”重新生成导航网格，方法更复杂，但难度更低，Recast使用了此方案，而UE4使用了Recast。</li></ul></li></ul><h3 id="Recast"><a href="#Recast" class="headerlink" title="Recast"></a>Recast</h3><ul><li>Recast:将场景网格模型生成用于寻路的导航网格</li><li>Detour：利用导航网格进行寻路</li></ul><h1 id="UE4蓝图的意义"><a href="#UE4蓝图的意义" class="headerlink" title="UE4蓝图的意义"></a>UE4蓝图的意义</h1>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库整理</title>
      <link href="/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树-B-树-B-树-红黑树"><a href="#AVL树-B-树-B-树-红黑树" class="headerlink" title="AVL树/B-树/B+树/红黑树"></a>AVL树/B-树/B+树/红黑树</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul><li><p>1.结点是红色或黑色。</p></li><li><p>2.根结点是黑色。</p></li><li><p>3.每个叶子结点都是黑色的空结点（NIL结点）。</p></li><li><p>4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</p></li><li><p>5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="新结点（A）位于树根，没有父结点。"><a href="#新结点（A）位于树根，没有父结点。" class="headerlink" title="新结点（A）位于树根，没有父结点。"></a>新结点（A）位于树根，没有父结点。</h3></li><li>A直接变成黑色</li></ul><h3 id="新结点（B）的父结点是黑色。"><a href="#新结点（B）的父结点是黑色。" class="headerlink" title="新结点（B）的父结点是黑色。"></a>新结点（B）的父结点是黑色。</h3><ul><li>A不变</li></ul><h3 id="新结点（D）的父结点和叔叔结点都是红色。"><a href="#新结点（D）的父结点和叔叔结点都是红色。" class="headerlink" title="新结点（D）的父结点和叔叔结点都是红色。"></a>新结点（D）的父结点和叔叔结点都是红色。</h3><ul><li>爸爸叔叔变黑，爷爷变红，然后递归检查</li></ul><h3 id="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"><a href="#新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"></a>新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。</h3><h3 id="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"><a href="#新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"></a>新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。</h3><h3 id="4，5的镜像"><a href="#4，5的镜像" class="headerlink" title="4，5的镜像"></a>4，5的镜像</h3><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。"><a href="#如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。" class="headerlink" title="如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。"></a>如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。</h3><ul><li>类似二叉树，把右孩子的最大值放过来，并删除这个结点</li></ul><h3 id="根据待删除结点和其唯一子结点的颜色，分情况处理。"><a href="#根据待删除结点和其唯一子结点的颜色，分情况处理。" class="headerlink" title="根据待删除结点和其唯一子结点的颜色，分情况处理。"></a>根据待删除结点和其唯一子结点的颜色，分情况处理。</h3><ul><li>自身是红色，子结点是黑色：<ul><li>直接删</li></ul></li><li>自身是黑色，子结点是红色：<ul><li>直接删，子孩子变黑</li></ul></li><li>自身是黑色，子结点也是黑色<ul><li>子情况1，结点红黑树的根结点：<ul><li>直接删</li></ul></li><li>结点的父亲、兄弟、侄子结点都是黑色：<ul><li>把结点2的兄弟结点B改为红色，递归判断</li></ul></li><li>结点2的兄弟结点是红色：</li></ul></li></ul><h1 id="B-数"><a href="#B-数" class="headerlink" title="B-数"></a>B-数</h1><p><img src="b树b+树.png" alt></p><h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><ul><li><p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段</p></li><li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li></ul><h1 id="模式（schema）："><a href="#模式（schema）：" class="headerlink" title="模式（schema）："></a>模式（schema）：</h1><ul><li><p>模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p></li><li><p>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p></li><li><p>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</p></li></ul><h1 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h1><p>层次模型（hierarchical model）<br>网状模型（network model）<br>关系模型（relational model）</p><h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><ul><li><p>用于提升数据库的查找速度</p></li><li><p>顺序索引</p></li><li>B+ 树索引<blockquote><p>比哈希多个排序</p></blockquote></li><li>hash 索引</li></ul><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><ul><li><p>第一范式</p><blockquote><p>属性（字段）是最小单位不可再分</p></blockquote></li><li><p>第二范式</p><blockquote><p>满足 1NF，每个非主属性完全依赖于主键</p></blockquote></li><li><p>第三范式</p><blockquote><p>满足 2NF，任何非主属性不依赖于其他非主属性</p></blockquote></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li>是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li></ul><h2 id="事物的-ACID-特性"><a href="#事物的-ACID-特性" class="headerlink" title="事物的 ACID 特性"></a>事物的 ACID 特性</h2><ul><li><p>原子性、一致性、隔离性、持续性</p></li><li><p>事务是并发控制的基本单位。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 decltype</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/</url>
      
        <content type="html"><![CDATA[<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><ul><li>decltype 用于选择并返回操作数的数据类型</li></ul><blockquote><p>只推断类型，不计算表达式的值</p><p>decltype能返回包括顶层const和引用在内的类型</p></blockquote><pre><code class="lang-cpp">const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; // x is const intdecltype(cj) y = x; // y is const int&amp;,并初始化绑定xdecltype(cj) z;     // wrong 引用必须初始化</code></pre><ul><li>decltype与引用</li></ul><pre><code class="lang-cpp">int i = 42,*p=&amp;i,&amp;r=i;decltype(r)  //int&amp;decltype(r+0) //intdecltype(*p) //int&amp;</code></pre><ul><li>decltype((variable))的结果(即带括号的表达式)永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用的时候才是引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 enum</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/</url>
      
        <content type="html"><![CDATA[<h1 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h1><pre><code class="lang-cpp">//限定作用域的枚举类型(c++11)enum class open_modes { input, output, append };//不限定作用域的枚举类型enum color { red, yellow, green };//不限定作用域的匿名枚举类型enum { floatPrec = 6, doublePrec = 10 };</code></pre><ul><li><p>匿名枚举类型用处</p><ul><li>在程序中需要<strong>数值的名字</strong>的时候使用<ul><li>宏定义的缺点:在预处理阶段只做简单替换不做安全检查</li><li>匿名的enum枚举:编译器会对其进行类型检查，若代码中其他地方有和该名字冲突的，会报错</li><li>静态变量: 作用域在本文件内,编译阶段检查，比匿名enum内存占用多<blockquote><p><a href="https://zhuanlan.zhihu.com/p/267401289" target="_blank" rel="noopener">c语言之枚举类型（enum）</a></p></blockquote></li></ul></li></ul></li><li><p>和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p></li><li>关键字是 enum class(等价enum struct)</li><li>限定作用域枚举类型，作用域外无法访问；不限定作用域的枚举类型，枚举成员的作用域和枚举类型本身的作用域一致</li></ul><pre><code class="lang-cpp">enum class /*struct*/ MyEnum { A = 0};        // 限定作用域的枚举enum class /*struct*/ MyEnum1 { A = 0 };    // 限定作用域的枚举可以有重复的名字，使用时也必须加上作用域enum MyEnum2 { B = 0 };                        // 不限定作用域的枚举enum MyEnum3 { B = 0 };                        // 不限定作用域的枚举不能有重复的名字enum {test = 0} t,t1;                        // 未命名的不限定作用域的枚举,只能在定义是就定义对象MyEnum::A;                                          //限定作用域的枚举要带上作用域B;                                                     //true</code></pre><ul><li><p>默认情况下，枚举值从0开始，依次加1，如果没有显示提供值，就在前一个枚举值的基础上加1。枚举成员是const的。</p></li><li><p>只要enum有名字，我们就能定义并初始化该类型的成员。想要初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。</p></li><li><p>一个不限定作用域的枚举类型的对象或枚举成员自动的转成整型</p></li><li><p>在C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。如果我们指定了潜在类型，则一旦超出范围将引发错误。对于限定作用域的枚举成员，其缺省为int类型</p></li><li><p>在C++11 新标准中，我们可以提前声明enum。enum的前置声明必须指定其成员的大小。</p><pre><code class="lang-cpp">enum test : long;    // 不限定作用域的，必须指定成员类型enum class test1;    // 限定作用域的枚举类型可以使用默认成员类型int</code></pre></li><li><p>int值不可以做以enmu为形参的函数的实参。对与不限定作用域的enum做形参时，enum的值提升成int或更大的整型（注意只会提升成对应整型，不会隐式转换为unsigned char之类），实际提升的结果由枚举类型的潜在类型决定。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 范围解析运算符</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><p>:: 使用</p><pre><code class="lang-cpp">int count = 11;         // 全局（::）的 countclass A {public:    static int count;   // 类 A 的 count（A::count）};int A::count = 21;void fun(){    int count = 31;     // 初始化局部的 count 为 31    count = 32;         // 设置局部的 count 的值为 32}int main() {    ::count = 12;       // 测试 1：设置全局的 count 的值为 12    A::count = 22;      // 测试 2：设置类 A 的 count 为 22    fun();                // 测试 3    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 using</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/</url>
      
        <content type="html"><![CDATA[<h1 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h1><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><pre><code class="lang-cpp">using namespace_name::name;</code></pre><h2 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><pre><code class="lang-cpp">class Derived : Base {public:    using Base::Base;    /* ... */};</code></pre><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><pre><code class="lang-cpp">Derived(parms) : Base(args) { }</code></pre><h2 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h2><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><pre><code class="lang-cpp">using namespace_name name;</code></pre><h2 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h2><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><p>using 使用</p><p>尽量少使用 <code>using 指示</code></p><pre><code class="lang-cpp">using namespace std;</code></pre><p>应该多使用 <code>using 声明</code></p><pre><code class="lang-cpp">int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl;</code></pre><p>或者</p><pre><code class="lang-cpp">using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl;</code></pre><h1 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using = (类型别名)"></a>using = (类型别名)</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using double = wages; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于复合类型的别名的声明语句要小心"><a href="#对于复合类型的别名的声明语句要小心" class="headerlink" title="对于复合类型的别名的声明语句要小心"></a>对于复合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 friend友元</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h1><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><pre><code class="lang-cpp">//声明方式class CLASS_NAME{    friend //函数声明    friend //类声明    public:        //...    private:        //...}</code></pre><h1 id="相同class的各个objects互为友元"><a href="#相同class的各个objects互为友元" class="headerlink" title="相同class的各个objects互为友元"></a>相同class的各个objects互为友元</h1><pre><code class="lang-cpp">class complex{public:    complex (double r = 0,double i = 0):re(r),ri(i){}    //相同class的各个objects互为友元    int func(const complex&amp; param){return param.re + param.ri;}private:    double re,im;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 explicit关键字</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h1><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰类型转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li></ul><ul><li>转换构造函数</li></ul><blockquote><p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</p></blockquote><pre><code class="lang-cpp">Sales_data(std::string s) : Sales_data(s,0,0){} // 可以隐式(stirng -&gt; Sales_data)Sales_data(std::istream &amp;is) : Sales_data(){read(is,*this)} // 可以隐式（cin(istream) -&gt; Sales_data）</code></pre><h2 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h2><ul><li>对其他类型也只会允许一步类型转换</li></ul><pre><code class="lang-cpp">Sales_data::combine(&quot;99999&quot;); //error char* -&gt; string -&gt; Sales_data</code></pre><ul><li>可以显式隐式混用</li></ul><pre><code class="lang-cpp">Sales_data::combine(string(&quot;99999&quot;));Sales_data::combine(Sales_data(&quot;9999999&quot;));</code></pre><h2 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h2><ul><li><p>关键字 <font color="red">explicit</font></p></li><li><p>只能在类内的单个形参的构造函数前使用</p></li><li><p>并且explicit声明的构造函数只能用于直接初始化而不能用于拷贝初始化</p></li></ul><pre><code class="lang-cpp">Sales_data item1(null_book); //trueSales_data item2 = null_book; //error</code></pre><ul><li>explicit 使得构造函数不能用于隐式变换，但仍可以显式变换</li></ul><pre><code class="lang-cpp">item.combine(Sales_data(null_book));item.combine(Static_cast&lt;Sales_data&gt;(cin));</code></pre><h1 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h1><ul><li>形式</li></ul><pre><code class="lang-cpp">operator type() const;</code></pre><ul><li>type表示某种类型</li><li><p>可以面向除void以外的任意类型进行定义,并且要求能作为返回类型</p><ul><li>所以type不能是数组和函数，但可以是指向数组和函数的指针或绑定它们的引用</li><li>没有返回类型，没有形参，必须是成员函数</li></ul></li><li><p>显式的类型转换运算符(c++11新特性)</p><blockquote><p>即显示的类型转换运算符(c++11新特性)(explicit operator)</p><ul><li>通常与explicit一样</li><li>如果当表达式被用作条件，则编译其会将显式的类型转换自动应用于它。<ul><li>if、while、for 的控制表达式；</li><li>内建逻辑运算符 !、&amp;&amp; 和 || 的操作数；</li><li>条件运算符 ?: 的首个操作数；</li><li>static_assert 声明中的谓词；</li><li>noexcept 说明符中的表达式；</li><li>explicit 说明符中的表达式。(C++20 起)</li></ul></li></ul></blockquote></li></ul><ul><li>无论什么时候在条件中使用流对象，都会为IO类型定义operator bool的隐式转换</li></ul><h1 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h1><pre><code class="lang-cpp">struct A{    A(int) { }    operator bool() const { return true; }};struct B{    explicit B(int) {}    explicit operator bool() const { return true; }};void doA(A a) {}void doB(B b) {}int main(){    A a1(1);        // OK：直接初始化    A a2 = 1;        // OK：复制初始化    A a3{ 1 };        // OK：直接列表初始化    A a4 = { 1 };        // OK：复制列表初始化    A a5 = (A)1;        // OK：允许 static_cast 的显式转换     doA(1);            // OK：允许从 int 到 A 的隐式转换    if (a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a6(a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a7 = a1;        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a8 = static_cast&lt;bool&gt;(a1);  // OK ：static_cast 进行直接初始化    B b1(1);        // OK：直接初始化    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化    B b3{ 1 };        // OK：直接列表初始化    B b4 = { 1 };        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化    B b5 = (B)1;        // OK：允许 static_cast 的显式转换    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换    bool b8 = static_cast&lt;bool&gt;(b1);  // OK：static_cast 进行直接初始化    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习  c实现c++类</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h1><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同(虚函数表见<a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a>)</li></ul><blockquote><p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经整理</title>
      <link href="/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/solthx/RBTtree" target="_blank" rel="noopener">RBTtree</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li><p>进程是资源调度、分配的独立单位</p></li><li><p>这个还是看面经好了</p></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</li></ul><h2 id="cpu调度算法-进程调度"><a href="#cpu调度算法-进程调度" class="headerlink" title="cpu调度算法(进程调度)"></a>cpu调度算法(进程调度)</h2><ul><li>先来先服务</li><li>最短作业</li><li>最短剩余时间</li><li>时间片轮转</li><li>优先级调度</li><li>多级反馈队列</li></ul><h2 id="线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？"><a href="#线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？" class="headerlink" title="线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？"></a>线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？</h2><h3 id="进程线程区别"><a href="#进程线程区别" class="headerlink" title="进程线程区别"></a>进程线程区别</h3><p>*Ⅰ 拥有资源</p><pre><code>- 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</code></pre><ul><li>Ⅱ 调度<ul><li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li></ul></li><li>Ⅲ 系统开销<ul><li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li></ul></li><li>Ⅳ 通信方面<ul><li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ul></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><p>协程 Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。</p></li><li><p>线程是被内核所调度，线程被调度切换到另一个线程上下文的时候，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作设计用户态到内核态转换，开销比较多。</p></li><li><p>协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销。</p></li></ul><h2 id="虚拟内存、物理内存"><a href="#虚拟内存、物理内存" class="headerlink" title="虚拟内存、物理内存"></a>虚拟内存、物理内存</h2><ul><li><p>物理内存（内存条）：当打开程序时，系统会将这些程序加载到物理内存上。</p></li><li><p>虚拟内存（硬盘）：虚拟的不是物理内存，而是代替物理内存行使存储的功能，物理内存的运行程序的功能是无法用虚拟内存来完成的。</p></li><li><p>物理内存与虚拟内存的关系：当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。</p></li></ul><h2 id="虚拟地址空间（用户空间、内核空间）"><a href="#虚拟地址空间（用户空间、内核空间）" class="headerlink" title="虚拟地址空间（用户空间、内核空间）"></a>虚拟地址空间（用户空间、内核空间）</h2><p><a href="https://blog.csdn.net/qq_41668705/article/details/107041614" target="_blank" rel="noopener">C / C++系列 （3）：heap vs. stack &amp; new vs. malloc</a></p><p><a href="https://blog.csdn.net/qq_41668705/article/details/107173143" target="_blank" rel="noopener">C / C++系列 （4）：malloc内存分配 &amp; linux虚拟地址空间布局</a></p><ul><li>虚拟地址空间（作用：解决物理内存稀缺问题）：系统为每个进程所分配的4GB虚拟地址空间（32位系统），用来存放进程的虚拟地址，再通过MMU（内存管理单元）将虚拟地址映射到物理内存地址。</li><li>虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。</li><li>内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)</li><li>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。</li></ul><p><img src="Linux下elf文件与虚拟地址空间的映射关系.png" alt="Linux下elf文件与虚拟地址空间的映射关系"></p><h3 id="变量内存的分配方式"><a href="#变量内存的分配方式" class="headerlink" title="变量内存的分配方式"></a>变量内存的分配方式</h3><ul><li>静态存储区<ul><li>全局变量 ，static变量 </li></ul></li><li>栈<ul><li>局部变量 </li></ul></li><li>堆（动态内存分配）<ul><li>程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。</li><li>malloc接触的内存空间是虚拟内存</li></ul></li></ul><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><h4 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h4><ul><li>局部变量存放的位置，函数调用会在占空间生成栈帧,由系统控制</li></ul><blockquote><p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p></blockquote><pre><code>- 为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。- 记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。- 临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</code></pre><blockquote><p>注意点：</p></blockquote><pre><code>- 持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再收缩。- Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。- 堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。- 堆栈的大小在运行时由内核动态调整。</code></pre><h4 id="共享库区域（内存映射段）"><a href="#共享库区域（内存映射段）" class="headerlink" title="共享库区域（内存映射段）"></a>共享库区域（内存映射段）</h4><ul><li>内核用于将硬盘文件的内容直接映射到内存,内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库</li></ul><h4 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h4><ul><li>动态分配的内存,由用户控制</li></ul><blockquote><p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</p><p>分配的堆内存是经过字节对齐的空间，以适合原子操作。</p><p>堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p><h4 id="可读可写段"><a href="#可读可写段" class="headerlink" title="可读可写段"></a>可读可写段</h4><h5 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h5><ul><li>未初始化或初值为0的全局变量和静态局部变量<h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5></li><li>已初始化且初值非0的全局变量和静态局部变量</li></ul></blockquote><hr><ul><li>BSS段和数据段的区别<ul><li>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间<ul><li>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</li></ul></li><li>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</li></ul></li></ul><h4 id="只读代码段"><a href="#只读代码段" class="headerlink" title="只读代码段"></a>只读代码段</h4><ul><li>可执行代码、字符串字面值、只读变量</li></ul><hr><ul><li>代码段也称正文段或文本段</li><li>通常用于存放程序执行代码(即CPU执行的机器指令)。</li><li>代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。</li></ul><h4 id="保留区"><a href="#保留区" class="headerlink" title="保留区"></a>保留区</h4><ul><li>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。</li></ul><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><ul><li>包括内核数据和内核栈等</li><li>用来存放操作系统内核代码和数据等<ul><li>内核代码和数据区在每个进程的地址空间中都相同</li><li>用户态不能访问内核区</li></ul></li><li>内核栈就是用来纪录进程内核态的执行状态的，  进程的内核栈清空了还怎么进程switch呢.进程的切换都是内核态的工作，进程切换基本就是内核栈的切换</li></ul><h2 id="目标文件（elf）"><a href="#目标文件（elf）" class="headerlink" title="目标文件（elf）"></a>目标文件（elf）</h2>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 union联合体</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/</url>
      
        <content type="html"><![CDATA[<h1 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public（也可以有private和protected）</li><li>可以含有构造函数、析构函数(此处就是不加virtual的析构函数)</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><p>union 使用</p><pre><code class="lang-cpp">#include&lt;iostream&gt;union UnionTest {    UnionTest() : i(10) {};    int i;    double d;};static union {    int i;    double d;};int main() {    UnionTest u;    union {        int i;        double d;    };    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10    ::i = 20;    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20    i = 30;    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 struct和typedef struct</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/</url>
      
        <content type="html"><![CDATA[<h1 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h1><h2 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h2><pre><code class="lang-c">// ctypedef struct Student {    int age; } S;</code></pre><p>等价于</p><pre><code class="lang-c">// cstruct Student {     int age; };typedef struct Student S;</code></pre><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h2 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h2><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><pre><code class="lang-cpp">// cppstruct Student {     int age; };void f( Student me );       // 正确，&quot;struct&quot; 关键字可省略</code></pre><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><pre><code class="lang-cpp">typedef struct Student {     int age; } S;void Student() {}           // 正确，定义后 &quot;Student&quot; 只代表此函数//void S() {}               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名int main() {    Student();     struct Student me;      // 或者 &quot;S me&quot;;    return 0;}</code></pre><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using wages = double; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于符合符合类型的别名的声明语句要小心"><a href="#对于符合符合类型的别名的声明语句要小心" class="headerlink" title="对于符合符合类型的别名的声明语句要小心"></a>对于符合符合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 class和struct</title>
      <link href="/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/"/>
      <url>/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h1><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 extern C</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/</url>
      
        <content type="html"><![CDATA[<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><ul><li>extern “xxx”表示链接指示，用于c++调用其他语言编写的程序<blockquote><p>还要求c++编译器有权访问其他语言的编译器（包括c语言），并且兼容</p></blockquote></li></ul><blockquote><p>还可以链接其他语言的程序比如 extern “Ada”</p></blockquote><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><pre><code>- 符号修饰:[extern &quot;C&quot; 本质论——符号和符号修饰](https://blog.csdn.net/u011025903/article/details/11804587)</code></pre><p>extern “C” 使用</p><pre><code class="lang-cpp">#ifdef __cplusplus//方式1extern &quot;C&quot; {#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus}#endif//方式2extern &quot;C&quot; size_t strlen(const char *);</code></pre><ul><li>当一个#include指示被放置在复合链接指示的花括号中，头文件中的所有普通函数声明都人未还是由链接指示的语言编写的。</li></ul><pre><code class="lang-cpp">extern &quot;C&quot; {    #include &lt;string.h&gt;}</code></pre><ul><li>链接指示可以嵌套</li></ul><h1 id="指向extern-“C”函数的指针"><a href="#指向extern-“C”函数的指针" class="headerlink" title="指向extern “C”函数的指针"></a>指向extern “C”函数的指针</h1><ul><li>使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示</li></ul><pre><code class="lang-cpp">//pf指向一个C函数，该函数接受一个int返回voidextern &quot;C&quot; void (*pf)(int);</code></pre><ul><li><font color="red">指向C函数的指针与指向C++函数的指针是不一样的类型</font>,不能用在初试化或赋值操作中</li></ul><pre><code class="lang-cpp">void (*pf1)(int); //指向c++函数void &quot;C&quot; void (*pf2)(int); //指向C函数pf1 = pf2;//error</code></pre><ul><li>链接指示对整个声明都有效<blockquote><p>链接指示不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效</p></blockquote></li></ul><pre><code class="lang-cpp">//f1是一个C函数，它的形参是一个指向C函数的指针extern &quot;C&quot; void fl(void(*)(int));</code></pre><ul><li>因为链接指示同时作用于声明语句中的所有函数，如果要给C++传入C函数指针，必须使用类型别名</li></ul><pre><code class="lang-cpp">//FC是一个指向C函数的指针extern &quot;C&quot; typedef void FC(int);//f2是一个C++函数，该函数的形参是指向C函数的指针void f2(FC *);</code></pre><ul><li>使用链接指示对函数进行定义，可以令C++函数在其他语言中调用<blockquote><p>但类型受到限制，比如c语言理解不了类</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; double calc(double dparm){    /*    ...    */}</code></pre><ul><li>链接指示对应的语言支持重载则<strong>可能</strong>可以重载<blockquote><p>c语言不支持重载，所以不能声明两个函数名相同的函数</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; void print(const char*);extern &quot;C&quot; void print(int);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 位域</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="不可移植性"><a href="#不可移植性" class="headerlink" title="不可移植性"></a>不可移植性</h1><ul><li><p>不可移植性：程序从一台机器转移到另一台机器时，通常需要重新编写该程序。</p><blockquote><p>比如算术类型的大小在不同机器上不一样</p></blockquote></li><li><p>相关概念</p><blockquote><p><a href>位域</a></p></blockquote></li></ul><blockquote><p><a href>Volatile</a></p><p><a href>链接指示:extern “C”</a></p></blockquote><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><pre><code class="lang-cpp">//位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，用于指定成员所占的二进制位数;Bit mode: 2;    // mode 占 2 位</code></pre><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，<font color="red">因为</font>带符号类型中的位域的行为将因具体实现而定</li><li><p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p></li><li><p>如果类内的连续定义的位域占用空间在同一个整数的相邻位，那么将会提供压缩，具体与机器相关</p></li><li><p>超过1位的位域通常使用内置的位运算符进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 数组 array vector</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-array-vector的区别"><a href="#数组-array-vector的区别" class="headerlink" title="数组 array vector的区别"></a>数组 array vector的区别</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/346838779" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/346838779</a></p></li><li><p>相同点：</p><ul><li>vector和array是容器；</li><li>三者均可以使用下表运算符对元素进行操作，即vector和array都针对下标运算符[]进行了重载；</li><li>三者在内存的方面都使用连续内存，即在vector和array的底层存储结构均使用数组 </li></ul></li></ul><ul><li>不同点：<ul><li>array 定义的时候必须定义数组的元素个数为常量表达式，而vector 可为变量表达式；</li><li>vector属于变长容器，即可以根据数据的插入删除重新构建容器容量；</li><li>但array和数组属于定长容量。vector和array在声明变量后，在生命周期完成后，会自动地释放其所占用的内存。对于数组，如果是采用new[]申请的内存空间，必须在使用delete[]完毕后手动释放其内存。</li><li>array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 sizeof()</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><ul><li>sizeof 运算符返回一条表达式或一个类型名字所占的字节数。<blockquote><p>满足右结合律<br>sizeof <em>p = sizeof(</em>p);</p></blockquote></li></ul><blockquote><p>返回值：size_t类型的常量表达式</p></blockquote><pre><code class="lang-cpp">//使用方法sizeof (type)sizeof expr //返回表达式结果类型的大小，不实际计算运算对象的值</code></pre><ul><li>不实际计算运算对象，即使对象是空指针也可以运行</li></ul><h2 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h2><ul><li>可以通过 作用域 符号来获取成员的大小</li></ul><pre><code class="lang-cpp">sizeof ClassName::ClassMember;//ClassName的ClassMember成员对应类型的大小</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对char或者类型为char的表达式，结果为1</li><li>对引用类型，结果为被引用对象所占空间的大小</li><li>对指针类型，结果为指针本身所占空间的大小</li><li>对解引用指针类型，结果为指向的对象所占空间的大小，指针不需要有效</li><li>对数组，结果为数组所占空间的大小，等价于数组中所有元素所占空间之和。sizeof不把数组转换为指针进行处理</li><li>对string和vector等，返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li></ul><h1 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h1><ul><li>这个宏会返回一个结构体成员相对于结构体开头的字节偏移量（<strong>经过结构对齐之后</strong>）<ul><li>type 结构体名称</li><li>结构体成员名称</li></ul></li><li>这个宏非常有用，由于结构体对齐的问题，整个结构体的大小并不是所有成员大小之和，往往要比他们的和大，（当然我们也可以执行结构体按一个字节进行对其），所以利用这个宏可以很好计算出每个结构体成员相对于结构体开头偏移的字节数。</li></ul><pre><code class="lang-cpp">#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;struct struct_test{    float fild1;    double fild2;    int fild3;    short fild4;    long long fild5;};int main(void){    printf(&quot;struct_test size is %lu \nfild1 offset %lu\nfild2 offset %lu \nfild3 offset %lu \nfild4 offset %lu \nfild5 offset %lu\n&quot;,                        sizeof(struct struct_test),                        offsetof(struct struct_test,fild1),                        offsetof(struct struct_test,fild2),                        offsetof(struct struct_test,fild3),                        offsetof(struct struct_test,fild4),                        offsetof(struct struct_test,fild5));    return 0;}/*struct_test size is 32 fild1 offset 0fild2 offset 8 fild3 offset 16 fild4 offset 20 fild5 offset 24*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 pragma pack(n)</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/</url>
      
        <content type="html"><![CDATA[<h1 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h1><p>设定结构体、联合体以及类成员变量以 n 字节方式对齐</p><p><a href="https://blog.csdn.net/fuzhongmin05/article/details/59112081/" target="_blank" rel="noopener">C++成员函数在内存中的存储方式</a></p><ul><li>类成员函数和非成员函数代码存放在代码区</li></ul><h1 id="pragma-pack-n-使用"><a href="#pragma-pack-n-使用" class="headerlink" title="pragma pack(n) 使用"></a>pragma pack(n) 使用</h1><pre><code class="lang-cpp">#pragma pack(push)  // 保存对齐状态#pragma pack(4)     // 设定为 4 字节对齐struct test{    char m1;    double m4;    int m3;};#pragma pack(pop)   // 恢复对齐状态</code></pre><ul><li><p><a href="https://blog.csdn.net/aidem_brown/article/details/77540527" target="_blank" rel="noopener">补充</a></p><ul><li><h1 id="pragma-pack-n-作用：C编译器将按照n个字节对齐。"><a href="#pragma-pack-n-作用：C编译器将按照n个字节对齐。" class="headerlink" title="pragma pack (n)            作用：C编译器将按照n个字节对齐。"></a>pragma pack (n)            作用：C编译器将按照n个字节对齐。</h1></li><li><h1 id="pragma-pack-作用：取消自定义字节对齐方式。"><a href="#pragma-pack-作用：取消自定义字节对齐方式。" class="headerlink" title="pragma pack ()             作用：取消自定义字节对齐方式。"></a>pragma pack ()             作用：取消自定义字节对齐方式。</h1></li><li><h1 id="pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"><a href="#pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐" class="headerlink" title="pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"></a>pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐</h1></li><li><h1 id="pragma-pack-pop-作用：恢复对齐状态"><a href="#pragma-pack-pop-作用：恢复对齐状态" class="headerlink" title="pragma pack (pop)          作用：恢复对齐状态"></a>pragma pack (pop)          作用：恢复对齐状态</h1></li></ul></li><li><p>因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优，但是很多时候两者差别不大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 assert</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/</url>
      
        <content type="html"><![CDATA[<h1 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h1><ul><li><p>由预处理器管理，可以直接使用</p></li><li><p>断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。</assert.h></cassert></assert.h></p></li></ul><blockquote><p>无需std或using声明</p></blockquote><h1 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h1><ul><li>NDEBUG可以决定assert是否启用。但是注意要定义在assert声明之前。具体看以下连接</li></ul><blockquote><p><a href="https://www.zhihu.com/question/23075111" target="_blank" rel="noopener">https://www.zhihu.com/question/23075111</a>  </p></blockquote><ul><li>一些局部静态变量，可以用于调试</li></ul><p><img src="局部静态变量.png" alt></p><pre><code class="lang-cpp">//assert() 使用#define NDEBUG          // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL );    // assert 不可用</code></pre><h1 id="UE4-断言"><a href="#UE4-断言" class="headerlink" title="UE4 断言"></a>UE4 <a href="https://docs.unrealengine.com/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assertions/index.html" target="_blank" rel="noopener">断言</a></h1><ul><li>源码位置<blockquote><p>Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h</p></blockquote></li></ul><h2 id="check族"><a href="#check族" class="headerlink" title="check族"></a>check族</h2><ul><li><p>Check族系最接近基础 assert，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。</p></li><li><p>检查宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 以保留一个true值（通常为 1），使Check宏可在所有版本中运行。</p><blockquote><p>此法在以下情况中十分实用：怀疑Check宏中的代码正在修改值；发现了仅存在于在发布版本中且难以追踪的bug，但认为现有Check宏能找到这些bug。项目发布时应将 USE_CHECKS_IN_SHIPPING 设为默认值 0。</p></blockquote></li></ul><h2 id="verify族"><a href="#verify族" class="headerlink" title="verify族"></a>verify族</h2><ul><li><p>在大部分版本中，Verify族系的行为与Check族系相同。但即便在禁用Check宏的版本中，Verify宏也会计算其表达式的值。这意味着仅当该表达式需要独立于诊断检查之外运行时，才应使用Verify宏。</p></li><li><p>验证宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中完整运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 来保留一个true值（通常为 1），从而覆盖此行为。</p></li><li><p><strong>在所有其他情况下，Verify宏将计算其表达式，但不会停止执行或将文本输出到日志。</strong></p></li></ul><h2 id="ensure族"><a href="#ensure族" class="headerlink" title="ensure族"></a>ensure族</h2><ul><li><p>Ensure族系类似于Verify族系，但可在出现非致命错误时使用。若Ensure宏的表达式计算得出的值为false，引擎将通知崩溃报告器，但仍会继续运行。</p></li><li><p>为避免崩溃报告器收到太多通知，Ensure宏在每次引擎或编辑器会话中仅报告一次。若实际情况需要Ensure宏在每次表达式计算得值为false时都报告一次，则使用”Always”版本的宏。</p></li><li><p>Ensure宏在所有版本中计算其表达式的值，但仅在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中联系崩溃报告器。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 强制类型转换</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h1><blockquote><p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p></blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>把空指针转换成目标类型的空指针。</li><li>把任何类型的表达式转换成void类型。</li><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安</li></ul></li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>转换引用失败会抛出bad_cast异常，转换指针失败会返回nullptr。</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul><li>用于删除 const、volatile([ˈvɒlətaɪl]) 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h2 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h2><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><p>bad_cast 使用</p><pre><code class="lang-cpp">try {      Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape);   }  catch (bad_cast b) {      cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what();  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 volatile</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile-ˈvɑː-lə-t̬əl"><a href="#volatile-ˈvɑː-lə-t̬əl" class="headerlink" title="volatile[ /ˈvɑː.lə.t̬əl/]"></a>volatile[ /ˈvɑː.lə.t̬əl/]</h1><pre><code class="lang-cpp">volatile int i = 10;</code></pre><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p><blockquote><p>volatile跟const类似可以跟指针，引用等组合</p></blockquote></li></ul><blockquote><p>带有volatile的成员函数只能被volatile的对象调用。</p></blockquote><ul><li>合成的拷贝对volatile对象无效<blockquote><p>如果没有定义复制构造函数，编译器会自动合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数会对成员逐个进行初始化，将新对象初始化为原对象的副本。</p></blockquote></li></ul><blockquote><p>合成的成员接受的形参类型是常量（非 volatile）引用，以此不能把一个非volatile引用绑定到一个volatile，因此需要自定义。</p></blockquote><pre><code class="lang-cpp">class Foo{public:    //从一个volatile对象进行拷贝    Foo(const volatile Foo&amp;);    //将一个volatile对象赋值给一个*非*Volatile对象    Foo&amp; operator=(volatile const Foo&amp;);    //将一个volatile对象赋值给一个volatile对象    //这个没问题volatile表示这个函数只能被volatile对象调用，而这是个符号重载，所以左值一定是volatile类型    Foo&amp; operator=(volatile const Foo&amp;) volatile;    //Foo类的其他部分//}</code></pre><h1 id="注意与java等其他语言的volatile作区别"><a href="#注意与java等其他语言的volatile作区别" class="headerlink" title="注意与java等其他语言的volatile作区别"></a>注意与java等其他语言的volatile作区别</h1><ul><li>volatile 不能解决多线程中的问题。</li><li>按照 <a href="http://web.archive.org/web/20180120044239/http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren</a> 的总结，volatile 只在三种场合下是合适的。<ul><li>和信号处理（signal handler）相关的场合；</li><li>和内存映射硬件（memory mapped hardware）相关的场合；</li><li>和非本地跳转（setjmp 和 longjmp）相关的场合。</li></ul></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">谈谈 C/C++ 中的 volatile</a><blockquote><p>要注意C/C++的volatile无法解决多线程问题</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 inline内联函数</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/</url>
      
        <content type="html"><![CDATA[<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>相当于把内联函数里面的内容写在调用内联函数处；//?</li><li>相当于不用执行进入函数的步骤，直接执行函数体；<blockquote><p>函数调用的时候，会在虚存中的栈区当前地址记录到帧指针寄存器，并生成该函数的上下文内容并执行相应的操作，调用结束后还会弹出该函数的数据，清理上下文信息。 </p></blockquote></li></ul><blockquote><p>感觉记得不准确，到时候重新看一下计算机系统中的函数调用过程</p><ul><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>inline 使用</p><pre><code class="lang-cpp">// 内联的声明可以不加inline// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) {/****/};// 类内定义，隐式内联class A {    int doA() { return 0; }         // 隐式内联}// 类外定义，需要显式内联class A {    int doA();}inline int A::doA() { return 0; }   // 需要显式内联</code></pre><h2 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h2><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h2><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>虚函数内联使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  using namespace std;class Base{public:    inline virtual void who()    {        cout &lt;&lt; &quot;I am Base\n&quot;;    }    virtual ~Base() {}};class Derived : public Base{public:    inline void who()  // 不写inline时隐式内联    {        cout &lt;&lt; &quot;I am Derived\n&quot;;    }};int main(){    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.who();    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr = new Derived();    ptr-&gt;who();    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr = nullptr;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 this指针</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h1><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针： //??<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 Static</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p></li></ul><blockquote><p>既可以是public也是private</p></blockquote><ul><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ul><blockquote><p>类的静态成员函数不包括this指针,所以静态成员函数不能设置为const</p><p><a href="https://blog.csdn.net/u010476094/article/details/38959265" target="_blank" rel="noopener">C++静态成员函数不能声明为const、volatile、virtual的原因 与 C++的对象模型</a></p></blockquote><ul><li>在类外定义静态成员，不用再重复声明static关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++整理</title>
      <link href="/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/"/>
      <url>/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="析构函数为什么最好是虚函数"><a href="#析构函数为什么最好是虚函数" class="headerlink" title="析构函数为什么最好是虚函数"></a><span id="destructor">析构函数为什么最好是虚函数</span></h2><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li><p>析构函数： 父类的后执行，子类的先执行</p></li><li><p>附加</p><blockquote><p>默认构造函数（无参构造函数），有参构造函数，拷贝构造函数，级别依次递增。当我们提供了后面的，前面的编译器就不会提供了。</p></blockquote></li></ul><h2 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/103384358" target="_blank" rel="noopener">C++ 类在内存中的存储方式(一)</a></li></ul><h2 id="new-delete-与new-delete之间的差别，以及具体实现"><a href="#new-delete-与new-delete之间的差别，以及具体实现" class="headerlink" title="new[]/delete[]与new/delete之间的差别，以及具体实现"></a>new[]/delete[]与new/delete之间的差别，以及具体实现</h2><ul><li><a href="https://wetest.qq.com/lab/view/318.html" target="_blank" rel="noopener">c++ new delete 常踩的坑</a></li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul><li><p>引用必须被初始化，指针不必。</p></li><li><p>引用初始化以后不能被改变，指针可以改变所指的对象。</p></li><li><p>不存在指向空值的引用，但是存在指向空值的指针。</p></li></ul><h2 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h2><blockquote><p>不同的对象调用同一个函数，表现出不同的状态，称为多态。</p></blockquote><ul><li><p>一是增加程序的灵活性</p><blockquote><p>不同继承自父类的子类，对同一函数可以有不同的表现</p></blockquote></li><li><p>二是增加程序的可扩展性</p><blockquote><p>新增子类，只需修改需要重写的函数</p></blockquote></li></ul><h2 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new/delete和malloc/free的区别"></a>new/delete和malloc/free的区别</h2><ul><li><a href="https://blog.csdn.net/nyist_zxp/article/details/80810742" target="_blank" rel="noopener">C++ new和malloc的区别</a></li></ul><h2 id="define的底层实现"><a href="#define的底层实现" class="headerlink" title="#define的底层实现"></a>#define的底层实现</h2><ul><li><h1 id="define是一条预处理命令，它的作用就是定义宏。"><a href="#define是一条预处理命令，它的作用就是定义宏。" class="headerlink" title="define是一条预处理命令，它的作用就是定义宏。"></a>define是一条预处理命令，它的作用就是定义宏。</h1></li><li><p>宏并不是函数,宏并不是语句,宏并不是类型定义。</p></li><li><p>预处理时进行宏展开，把宏名替换成文本，这个文本可以是字符串，代码等。</p></li></ul><h2 id="const-int-p和int-const-p的区别"><a href="#const-int-p和int-const-p的区别" class="headerlink" title="const int p和int const p的区别"></a>const int <em>p和int</em> const p的区别</h2><ul><li><p>对于const和指针结合的变量，要从右往左看</p></li><li><p>int* const p 是常量指针，指的是p本身是个常量，p的值不能边，但p指向的内容可以改变，这是个顶层cosnt</p></li><li><p>const int *p 是指针常量，指的是指向常量的指针，p的值能改变，p指向的内容不能改变，这个个底层const</p></li></ul><h2 id="c-的编译过程"><a href="#c-的编译过程" class="headerlink" title="c++的编译过程"></a>c++的编译过程</h2><ul><li>预处理、编译、汇编、链接<blockquote><p><a href="https://www.cnblogs.com/ericling/articles/11736681.html" target="_blank" rel="noopener">C/C++完整编译过程详解</a></p></blockquote></li></ul><h2 id="python为什么效率低"><a href="#python为什么效率低" class="headerlink" title="python为什么效率低"></a>python为什么效率低</h2><ul><li>动态语言：运行时可以改变程序结构</li><li>解释运行：先转换为字节码再解释字节码</li><li>一切都是对象：需要维护引用计数<!-- * GIL：全局解释器锁 --></li><li>垃圾回收：自动垃圾回收中断当前程序</li></ul><h2 id="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"><a href="#定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector" class="headerlink" title="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"></a>定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector</h2><ul><li>不能 不是POD类型 ，memcpy只能进行浅拷贝 </li></ul><h2 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h2><ul><li><p>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</p><blockquote><p><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></p></blockquote></li><li><p><a href="#destructor">析构函数为什么最好是虚函数</a></p></li></ul><h2 id="调试的时候打断点的原理"><a href="#调试的时候打断点的原理" class="headerlink" title="调试的时候打断点的原理"></a>调试的时候打断点的原理</h2><p><a href="https://zhuanlan.zhihu.com/p/34003929" target="_blank" rel="noopener">调试程序时，设置断点的原理是什么？</a></p><h2 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h2><ul><li><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></li></ul><h2 id="vector-list区别和相关内容"><a href="#vector-list区别和相关内容" class="headerlink" title="vector,list区别和相关内容"></a>vector,list区别和相关内容</h2><p><a href="https://zhuanlan.zhihu.com/p/270527588" target="_blank" rel="noopener">C++ vector和list的区别</a></p><h2 id="emplace-back和push-back有什么区别"><a href="#emplace-back和push-back有什么区别" class="headerlink" title="emplace_back和push_back有什么区别"></a>emplace_back和push_back有什么区别</h2><p><a href="https://zhuanlan.zhihu.com/p/183861524" target="_blank" rel="noopener">C++姿势点: push_back和emplace_back</a></p><h1 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h1><ul><li><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p></li><li><p>预处理</p><blockquote><p>预处理主要是处理各种宏展开；删除注释；保留编译器用到的编译器指令等。</p></blockquote></li></ul><blockquote><p>添加行号和文件标识符，为编译器产生调试信息提供便利；</p></blockquote><ul><li><p>编译</p><blockquote><p>编译是在预处理文件基础上经过一系列词法分析、语法分析及优化后生成汇编代码。</p></blockquote></li><li><p>汇编</p><blockquote><p>汇编是将汇编代码转化为机器可以执行的指令。</p></blockquote></li><li><p>链接</p><blockquote><p>将汇编生成的目标文件链接生成可执行文件</p></blockquote></li></ul><h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><ul><li><p>库:成熟的可复用代码</p></li><li><p>静态库(.a,.lib)动态库(.so,.dll)</p></li></ul><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><ul><li><p>在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p></li><li><p>特点：</p><blockquote><p>静态库对函数库的链接是放在<strong>编译时期</strong>完成的。</p></blockquote></li></ul><blockquote><p>程序在运行时与函数库再无瓜葛，移植方便。</p><p>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p></blockquote><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><ul><li><p>目的：为解决静态库浪费空间；对程序的更新、部署和发布会带来麻烦。</p></li><li><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p></li><li><p>特点：</p><blockquote><p>动态库把对一些库函数的链接载入推迟到程序运行的时期。</p></blockquote></li></ul><blockquote><p>可以实现进程之间的资源共享。（因此动态库也称为共享库）</p><p>将一些程序升级变得简单。</p><p>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。</p></blockquote><h1 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h1><p><a href="https://zhuanlan.zhihu.com/p/30007037" target="_blank" rel="noopener">C/C++内存对齐详解</a></p><h1 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h1><h2 id="静态存储区域"><a href="#静态存储区域" class="headerlink" title="静态存储区域"></a>静态存储区域</h2><ul><li>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2></li><li>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。效率很高，但是分配的内存容量有限。<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2></li><li>亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</li></ul><h1 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h1><ul><li><p>对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。过多的递归就会导致栈溢出</p></li><li><p>栈溢出的危害</p><blockquote><p>缓冲区溢出攻击，原因程序没有对作为缓冲区的数组进行越界检查</p></blockquote></li></ul><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><ul><li>重写是子类继承父类，可以对父类中声明为虚函数的函数进行重新定义，屏蔽父类的定义。</li><li>重载是指c++可以声明函数名相同，函数签名不同的函数，可以通过传入形参的不同来调用不同的函数</li></ul><h1 id="虚表指针是存在类里面还是对象里面"><a href="#虚表指针是存在类里面还是对象里面" class="headerlink" title="虚表指针是存在类里面还是对象里面"></a>虚表指针是存在类里面还是对象里面</h1><ul><li>对象</li></ul><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><ul><li>接口是一个概念。它在C++中用抽象类来实现</li><li><p>接口类应该是只提供方法声明，而自身不提供方法定义的抽象类。接口类自身不能实例化，接口类的方法定义/实现只能由接口类的子类来完成。</p></li><li><p>而对于C++，其接口类一般具有以下特征：</p><blockquote><p>最好不要有成员变量，但可以有静态常量（static const或enum）</p></blockquote></li></ul><blockquote><p>要有纯虚接口方法</p><p>要有虚析构函数，并提供默认实现</p><p>不要声明构造函数</p></blockquote><h1 id="参数为什么要从右往做压榨"><a href="#参数为什么要从右往做压榨" class="headerlink" title="参数为什么要从右往做压榨"></a>参数为什么要从右往做压榨</h1><ul><li><p>进一步发现，Pascal语言不支持可变长参数，而C语言支持这种特色，正是这个原因使得C语言函数参数入栈顺序为从右至左。具体原因为：C方式参数入栈顺序(从右至左)的好处就是可以动态变化参数个数。通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。</p></li><li><p>因此，C语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式。换句话说，如果不支持这个特色，C语言完全和Pascal一样，采用自左向右的参数入栈方式。</p></li></ul><h1 id="lambda表达式，引用捕获"><a href="#lambda表达式，引用捕获" class="headerlink" title="lambda表达式，引用捕获"></a>lambda表达式，引用捕获</h1><ul><li>lambda表达式表示一个可调用的代码单元，类似于一个匿名的内联函数</li></ul><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><ul><li>拷贝，要求变量可以被拷贝</li><li>与参数不同lambda的拷贝是在创建时拷贝，而不是在调用时拷贝<h2 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h2></li><li>类似普通引用</li></ul><h1 id="C-的GC机制"><a href="#C-的GC机制" class="headerlink" title="C++的GC机制"></a>C++的GC机制</h1><ul><li>csapp</li><li><a href="https://www.cnblogs.com/QG-whz/p/5079638.html" target="_blank" rel="noopener">C++垃圾回收机制</a></li><li>而C++ 0x则提供了基于引用计数算法的智能指针进行内存管理</li></ul><h1 id="array-vector，数组"><a href="#array-vector，数组" class="headerlink" title="array,vector，数组"></a>array,vector，数组</h1><p><a href="https://blog.csdn.net/alidada_blog/article/details/83029438?from=singlemessage" target="_blank" rel="noopener">array和vector，数组三者区别和联系</a></p><ul><li>共同点<ul><li>（1.）都和数组相似，都可以使用标准数组的表示方法来访问每个元素（array和vector都对下标运算符[ ]进行了重载）</li><li>（2.）三者的存储都是连续的，可以进行随机访问</li></ul></li><li>不同点<ul><li>（0.）数组是不安全的，array和vector是比较安全的（有效的避免越界等问题）</li><li>（1.）array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</li><li>（2.）array可以将一个对象赋值给另一个array对象，但是数组不行</li><li>（3.）vector属于变长的容器，即可以根据数据的插入和删除重新构造容器容量；但是array和数组属于定长容器</li><li>（4.）vector和array提供了更好的数据访问机制，即可以使用front()和back()以及at()（at()可以避免a[-1]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误</li><li>（5.）vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器</li><li>（6.）vector和array提供了size()和Empty()，而数组只能通过sizeof()/strlen()以及遍历计数来获取大小和是否为空</li><li>（7.）vector和array提供了两个容器对象的内容交换，即swap()的机制，而数组对于交换只能通过遍历的方式逐个交换元素</li><li>（8 .）array提供了初始化所有成员的方法fill（）</li><li>（9.）由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题</li><li>（10.）vector和array在声明变量后，在声明周期完成后，会自动地释放其所占用的内存。对于数组如果用new[ ]/malloc申请的空间，必须用对应的delete[ ]和free来释放内存</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer刷题笔记"><a href="#剑指Offer刷题笔记" class="headerlink" title="剑指Offer刷题笔记"></a>剑指Offer刷题笔记</h1><ul><li>2021年2月末，为准备研三的秋招，开始算法题的康复运动<blockquote><p>(“&hearts;” 表示刷的时候做出了最优解)</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>#</th><th>Title</th><th>Solution</th><th>Tag</th><th>Difficulty</th><th>最优时间复杂度&amp;&amp;空间复杂度</th><th>最优解</th></tr></thead><tbody><tr><td>剑指 Offer 03</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></td><td><a href="https://sanctorum003.github.io/2021/02/26/LeetCode/[%E5%89%91%E6%8C%87Offer]%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>数组 &amp;&amp; 哈希表</td><td>Easy</td><td>O(N) &amp;&amp; O(1)</td><td></td></tr><tr><td>剑指 Offer 09</td><td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></td><td><a href="https://sanctorum003.github.io/2021/02/28/LeetCode/[%E5%89%91%E6%8C%87Offer]%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">C++</a></td><td>栈 &amp;&amp; 设计</td><td>Hard</td><td></td><td></td></tr><tr><td>剑指 Offer 11</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></td><td><a href="https://sanctorum003.github.io/2021/03/01/LeetCode/[%E5%89%91%E6%8C%87Offer]%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>二分查找</td><td>Easy(Hard)</td><td>O(lgN) &amp;&amp; O(1)</td><td></td></tr><tr><td>303</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Easy</td><td>建立O(N) &amp; 调用O(1)</td><td></td></tr><tr><td>304</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">二维区域和检索 - 矩阵不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td>&hearts;</td></tr><tr><td>338</td><td><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特网计数</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td></td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a></td><td><a href>c++</a></td><td>Medium</td><td>DP &amp;&amp; 二分</td><td>O(NlogN) &amp;&amp; O(N)</td><td></td></tr><tr><td>354</td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">俄罗斯套娃信封问题</a></td><td><a href>c++</a></td><td>Hard</td><td>DP &amp;&amp; 二分</td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> menu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 06.从尾到头打印链表</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><h1 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h1><ul><li>正序输出 + 翻转数组</li></ul><h1 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h1><ul><li>正序输入栈 + 从栈输入Vector</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><pre><code class="lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head) {        if(!head) return {};        vector&lt;int&gt; t = reversePrint(head-&gt;next);        t.push_back(head-&gt;val);        return t;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LinkList </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 07.重建二叉树</title>
      <link href="/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></li></ul><h1 id="分治（不带index辅助）"><a href="#分治（不带index辅助）" class="headerlink" title="分治（不带index辅助）"></a>分治（不带index辅助）</h1><ul><li><p>这个自己写的，空间复杂度较高</p><pre><code class="lang-cpp">/*** Definition for a binary tree node.* struct TreeNode {*     int val;*     TreeNode *left;*     TreeNode *right;*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}* };*/class Solution {public:  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {      if(preorder.empty() || inorder.empty()) return NULL;      //1. find root                              3      //2. split into left &amp; right                9 | 3 | 15 20 7      //3. 分治      int rootVal = preorder[0];      TreeNode* root = new TreeNode(rootVal);      vector&lt;int&gt;::iterator inorderRootPos;      inorderRootPos = find(inorder.begin(),inorder.end(),rootVal);      vector&lt;int&gt; inorderLeft(inorder.begin(),inorderRootPos);//注意范围      vector&lt;int&gt; inorderRight(inorderRootPos+1,inorder.end());      // //  inorder  L ROOT R      // //  preorder Root L R      int leftElemtNum = inorderRootPos-inorder.begin();      vector&lt;int&gt; preorderLeft(preorder.begin()+1,preorder.begin()+leftElemtNum+1);      vector&lt;int&gt; preorderRight(preorder.begin()+leftElemtNum+1,preorder.end());      TreeNode* LeftChild = buildTree(preorderLeft,inorderLeft);      TreeNode* RightChild = buildTree(preorderRight,inorderRight);      root-&gt;left = LeftChild;      root-&gt;right = RightChild;      return root;  }};</code></pre></li><li>时间复杂度:O(N)</li><li>空间复杂度:O(N+h)=O(N) [h为构造的树的高度,这里还有多次的创建数组的空间]</li></ul><h1 id="分治（利用index优化空间复杂度）"><a href="#分治（利用index优化空间复杂度）" class="headerlink" title="分治（利用index优化空间复杂度）"></a>分治（利用index优化空间复杂度）</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Tree </tag>
            
            <tag> Divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集总结</title>
      <link href="/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h1><pre><code class="lang-cpp">const int N=30005;int fa[N],s[N],h[N];void Init(int n){    for(int i=1;i&lt;=n;++i)        fa[i]=i,ran[i]=0;    //刚开始每个人都是自己的老大，每个人都没有手下}int Find(int x){    return x==fa[x]?x:fa[x]=Find(fa[x]);}void Merge(int x,int y){    int fx=Find(x);    int fy=Find(y);    if(fx==fy)  return;    if(ran[fx]&lt;ran[fy])        fa[fx]=fy;    else    {        fa[fy]=fx;        if(ran[fx]==ran[fy])            ran[fx]++;    }}</code></pre><ul><li>模板引用来源:<a href="https://www.cnblogs.com/StungYep/p/12254027.html" target="_blank" rel="noopener">https://www.cnblogs.com/StungYep/p/12254027.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 200.无重复字符的最长子串</title>
      <link href="/2021/01/16/LeetCode/%5BLC%5D%20200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>/2021/01/16/LeetCode/%5BLC%5D%20200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>基础DFS题</li></ul><pre><code class="lang-cpp">class Solution {public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i ,int j)    {        if(i&lt;0 || i &gt;= grid.size() || j&lt;0 || j &gt;= grid[0].size()  || grid[i][j]==&#39;0&#39;) return;        //通过将&#39;1&#39;改为&#39;0&#39;来说明该位置已经被遍历过        grid[i][j] = &#39;0&#39;;        dfs(grid,i-1,j);        dfs(grid,i+1,j);        dfs(grid,i,j-1);        dfs(grid,i,j+1);    }    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int m = grid.size();        int n = grid[0].size();        int res = 0;        for(int i = 0; i &lt; m; ++i)        {            for(int j = 0; j &lt; n; ++j)            {                if(grid[i][j] == &#39;1&#39;)                {                       dfs(grid,i,j);                    res++;                }            }        }        return res;    }};</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>基础BFS题</li></ul><pre><code class="lang-cpp">class Solution {public:    bool isIsland(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i ,int j)    {        if(i&lt;0 || i &gt;= grid.size() || j &lt; 0 || j&gt;= grid[0].size() || grid[i][j] == &#39;0&#39; ) return false;        grid[i][j] = &#39;0&#39;;        return true;    }    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int res = 0;        int m = grid.size();        int n = grid[0].size();        queue&lt;pair&lt;int,int&gt;&gt; q;        for(int i = 0; i &lt;m;++i)        {            for(int j = 0; j &lt; n;++j)            {                if(grid[i][j] == &#39;1&#39; )                {                    q.push(make_pair(i,j));                    res++;                }                while(!q.empty())                {                    pair&lt;int,int&gt; p = q.front();                    q.pop();                    int x = p.first;                    int y = p.second;                    if(isIsland(grid,x+1,y)) q.push(make_pair(x+1,y));                    if(isIsland(grid,x-1,y)) q.push(make_pair(x-1,y));                    if(isIsland(grid,x,y+1)) q.push(make_pair(x,y+1));                    if(isIsland(grid,x,y-1)) q.push(make_pair(x,y-1));                }            }        }        return res++;    }};</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(???)$<blockquote><p>这个的空间复杂度有歧义，leetcode官方的答案写的是O(min(M,N)),我认为是O(max(m,n))</p></blockquote></li></ul><blockquote><p>x x x [1]<br>x x [1] 1<br>[1] [1] 1 1<br>x为已经遍历的位置,[1]为在队列里的位置</p></blockquote><p>但是看了这个<a href="https://stackoverflow.com/questions/50901203/dfs-and-bfs-time-and-space-complexities-of-number-of-islands-on-leetcode/50912382#50912382" target="_blank" rel="noopener">帖子</a>，时间复杂度应该是O(MN)</p><blockquote><p>PS:基本没人问这个问题，也没什么人提，一堆人刷题从来不管空间复杂度，时间复杂度的。。。。</p></blockquote><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul><li><p>简单的并查集学习</p><ul><li><a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93647900</a></li></ul></li><li><p>看了这篇文章做的这个题，感觉写的太复杂了，将并查集扩展到了2维</p><pre><code class="lang-cpp">class Solution {public:  void Init(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt;&amp; rank,int m,int n)  {      for(int i = 0; i &lt; m ;++i)      {          for(int j = 0; j &lt; n; ++j)          {              v[i][j] = make_pair(i,j);              rank[i][j] = 1;          }      }  }  pair&lt;int,int&gt; Find(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,pair&lt;int,int&gt; x)  {      int a = x.first;      int b = x.second;      return x == v[a][b] ? x : (v[a][b] = Find(v,v[a][b]));  }  void Merge(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt;&amp; rank,pair&lt;int,int&gt; i,pair&lt;int,int&gt; j)  {      pair&lt;int,int&gt; x = Find(v,i), y = Find(v,j);      int a = x.first;      int b = x.second;      int c = y.first;      int d = y.second;      if (rank[a][b] &lt;= rank[c][d])          v[a][b] = y;      else          v[c][d] = x;      if (rank[a][b] == rank[c][d] &amp;&amp; x != y)          rank[c][d]++;  }  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {      int m = grid.size();      int n = grid[0].size();      vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; v(m,vector&lt;pair&lt;int,int&gt;&gt;(n,make_pair&lt;int,int&gt;(0,0)));      vector&lt;vector&lt;int&gt;&gt; rank(m,vector&lt;int&gt;(n,0));      Init(v,rank,m,n);      for(int i = 0;i &lt;m;++i)      {          for(int j = 0; j &lt; n; ++j)          {              if(grid[i][j] == &#39;1&#39;)              {                  if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == &#39;1&#39;)   Merge(v,rank,make_pair(i-1,j),make_pair(i,j));                  if(i+1&lt;m &amp;&amp; grid[i+1][j] == &#39;1&#39;)    Merge(v,rank,make_pair(i+1,j),make_pair(i,j));                  if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == &#39;1&#39;)   Merge(v,rank,make_pair(i,j-1),make_pair(i,j));                  if(j+1&lt;n &amp;&amp; grid[i][j+1] == &#39;1&#39;)    Merge(v,rank,make_pair(i,j+1),make_pair(i,j));              }          }      }      set&lt;pair&lt;int,int&gt;&gt; s;      for(int i = 0; i &lt; m; ++i)      {          for(int j = 0; j &lt; n;++j)          {              if(grid[i][j] == &#39;1&#39;)                  s.insert(Find(v,make_pair(i,j)));          }      }      return s.size();  }};</code></pre></li></ul><ul><li>时间复杂度：T T <blockquote><p>不太懂，证明可以看算法导论，我这里直接拉一下leetcode上的说明</p></blockquote></li></ul><blockquote><p>时间复杂度：$O(MN * \alpha(MN))$，其中 M 和 N 分别为行数和列数。注意当使用路径压缩（见 find 函数）和按秩合并（见数组 rank）实现并查集时，单次操作的时间复杂度为 $\alpha(MN)$，其中 $\alpha(x)$ 为反阿克曼函数，当自变量 x 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 $\alpha(x)$的值不会超过 5，因此也可以看成是常数时间复杂度。</p><ul><li>空间复杂度：$O(MN)$</li></ul></blockquote><ul><li>写法简化版本<br>```cpp</li></ul><p>```</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5.最长回文子串</title>
      <link href="/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的关键点：初始条件和状态转换方程。<br>设：s[l][r]表示字符串中下标L到R的位置<br>则有如下转态转换方程<br>    s[l][r] = s[l+1][r-1] &amp;&amp; (s[l] == s[r])<br>那初始状态呢<br>    s[l][l] = ture<br>    s[l][l+1] = (s[l] == s[l+1])</p><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        vector&lt;vector&lt;bool&gt;&gt; v(s.size(),vector&lt;bool&gt;(s.size(),false));        string res;        for(int i = 0; i &lt; v.size();++i)        {            for(int j = i; j &lt; v.size();++j)            {                if(i == j)                    v[i][j] = true;                else if(j-i == 1)                    v[i][j] = s[i] == s[j] ? true : false;            }        }        //这里需要注意一点的是从后往前遍历，因为v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);会优先用到数组尾部的数据        for(int i = v.size()-1; i &gt;= 0;--i)        {            for(int j = i; j &lt; v.size();++j)            {                if(j-i &gt; 1)                    v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);                if(v[i][j] == true &amp;&amp; j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);              }        }        return res;    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3.无重复字符的最长子串</title>
      <link href="/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_longest-substring-without-repeating-characters.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>子串和子序列的区别<ul><li>子串是是连续的</li><li>子序列可以不是连续的<ul><li>比如”pwwkew”中,”pwke”是最长子序列,”wke”是最长子串</li></ul></li></ul></li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>通过两个指针$i$,$j$，维护一个区间，保证这个区间的子串中无重复元素。</li><li>每次迭代的时候$j$向后移动，判断当前j指针的元素在上一次迭代的区间中是否存在。<ul><li>不存在，$i$不动</li><li>存在，$i = find_pos(nums[j]) + 1$</li></ul></li><li>每次迭代时更新最长无重复的子串长度。</li></ul><p>对于在元素中查询方式有以下三种方法。</p><h3 id="朴素循环"><a href="#朴素循环" class="headerlink" title="朴素循环"></a>朴素循环</h3><ul><li><p>在判断是否有重复元素时遍历一遍区间内的元素</p><pre><code class="lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {      if(s.size() == 0)  return 0;      int i = 0;      int j = 0;      int res = 0;      do      {          for(int k =  i; k &lt;j ; ++k)          {              if(s[k] == s[j])              {                  i = k+1;                  break;              }          }          res = max(res,j-i+1);           ++j;      }while(i &lt; s.size() &amp;&amp; j &lt; s.size());      return res;  }};</code></pre></li><li>时间复杂度:$O(n^{2})$</li><li>空间复杂度:$O(1)$</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="eg.png" alt></p><ul><li>这里需要注意判断元素所对应的下标是否还在当前滑动窗口范围内</li></ul><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        unordered_map&lt;char,int&gt; m;        int i =0;        int j = 0;        int res = 0;        do        {            if( m.find(s[j])!= m.end() &amp;&amp; m[s[j]] &gt;= i ) //这里主要要求找到的值要大于等于i            {                i = m[s[j]]+1;                m[s[j]] = j;            }            else             {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:unordered_map:O(n)</li><li>空间复杂度:O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        int m[128]; //利用ascii来存储下标        fill(m,m+128,-1);        int i =0;        int j = 0;        int res = 0;        do        {            if(m[s[j]] &gt;= i)  //这里主要要求找到的值要大于等于i            {                              i = m[s[j]] + 1;                m[s[j]] = j;            }            else            {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> DoublePointer </tag>
            
            <tag> String </tag>
            
            <tag> SlidingWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_two-sum.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>数组无序</li><li>返回<strong>下标</strong></li></ul></li></ul><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><ul><li><p>二重循环</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; v;      for(int i = 0; i &lt; nums.size();++i)          for(int j = i+1; j &lt; nums.size();++j)              if(nums[i] + nums[j] == target)              {                  v.push_back(i);                  v.push_back(j);              }      return v;  }};</code></pre></li><li><p>时间复杂度:O($n^{2}$)</p></li><li>空间复杂度 O(1)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>排序($nlog(n)$)之后使用双指针($O(n)$)找出所求的值</li><li>所求的是原数组中的下标，所以排序前复制一份。之后利用找到的值来找到下标</li><li><p>需要注意从原数组找下标时，下标大小和数值重复的问题。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; tmp = nums;      sort(tmp.begin(),tmp.end());      int i = 0;      int j = tmp.size()-1;      while(i &lt; j)      {          if(tmp[i] + tmp[j] &gt; target) --j;          else if(tmp[i] + tmp[j] &lt; target) ++i;          else break;      }      bool bi = false;      bool bj = false;      for(int k = 0; k &lt; nums.size();++k)      {          if(!bi &amp;&amp; nums[k] == tmp[i] )          {              i=k;              bi = true;              continue;          }          if(!bj &amp;&amp; nums[k] == tmp[j])          {              j = k;              bj = true;              continue;          }      }      if(i &gt; j)          swap(i,j);      return {i,j};  }};</code></pre></li><li><p>时间复杂度: $O(nlog(n) + n + n) = O(nlog(n))$</p></li><li>空间复杂度: $O(n)$</li></ul><h2 id="两遍哈希"><a href="#两遍哈希" class="headerlink" title="两遍哈希"></a>两遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。<ul><li>这里会注意到一点，可能数组中的值会重复，导致一个值关联多个下标，而实际代码中的结果会使得最后一个重复值关联相应下标。</li><li>但是这并不会影响结果。如此考虑，因为<strong>结果唯一</strong>，所以结果要取重复值，则数组中该结果对应的重复值有且仅有2个，不然不满足结果唯一。</li><li>所以在查找的时候，用的是原数组进行迭代，所以重复的第一个值要找的就是重复的后一个值，所以上述正好满足我们的要求</li></ul></li><li><p>利用原数组进行查找 target - nums[i] 是否在map中,map::find为O(log(n))，其基于红黑树。unordered_map::find()为O(1),其基于哈希表</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)          m[nums[i]] = i;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)              return {i,m[target-nums[i]]};      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(n)</li></ul><h2 id="一遍哈希"><a href="#一遍哈希" class="headerlink" title="一遍哈希"></a>一遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。</li><li><p>在这里直接循环原数组，查找map中否有target - nums[i]。没有的话加入map中。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end())          {              return {m[target-nums[i]],i};          }          else          {              m[nums[i]] = i;          }      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Marching</title>
      <link href="/2020/01/10/CG/Render/Render-RayMarching/"/>
      <url>/2020/01/10/CG/Render/Render-RayMarching/</url>
      
        <content type="html"><![CDATA[<p><img src="raytrace.png" alt="from &quot;Ray tracing&quot; on Wikipedia"></p><ul><li>Ray Marching和Ray Tracing有一些相似之处。看上图，可以看出来他们都说从摄像机的位置开始,遍历屏幕上的所有像素，通过从摄像机穿过像素的射线来计算出该点像素的颜色。</li><li>对于Ray Marching来说，通过使用SDF函数来判断是否碰撞到物体。SDF函数就是signed distance function，比如说对于球体。  </li></ul><script type="math/tex; mode=display">SDF(P)=||\vec{p}-\vec{c}||-r \left\{\begin{aligned}< & 0, 在球体内部 \\= & 0, 在球体边上 \\> & 0, 在球体外部\end{aligned}\right.</script><ul><li>上述就是一个球体的SDF函数,而求得的SDF函数的值就是点P到球体的最短距离。</li></ul><script type="math/tex; mode=display">p = eye + depth * raydirection</script><ul><li>对于测试点P的depth来说,增加SPF(p)的大小肯定是不会发生碰撞的。然后考虑到如果该射线最终能撞到物体,那么depth肯定是一个固定值,而如果不撞到其他物体的话,那么depth = + $\infty$。所以需要设置p的最小值(初试值),最大值(超过这个值认为没有hit),depth的最小值(小于这个值认为ray marching结束),ray marching步长(超过这个值认为ray marching结束)</li></ul><p><img src="spheretrace.jpg" alt="From GPU Gems 2: Chapter 8."></p><ul><li>可以拿上图举例,从点P0开始,计算场景中所有SDF的值,并取最小值,那么depth加上这个值肯定不会发生碰撞。</li></ul><script type="math/tex; mode=display">SDF(p) = min(SDF_{1}(p),SDF_{2}(p),...)</script><pre><code class="lang-cpp">//Shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){    float tp1 = CircleSDF(vec3(0,0,0),1.f,tp);    float tp2 = CircleSDF(vec3(1,1,0),1.f,tp);    return min(tp1,tp2);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    //因为屏幕的原点在中心,而fragCoord的原点在左上角，进行变换    dir.xy = fragCoord - size/2.f;    //通过fov来设置视野范围       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    //注意一定要标准化    return normalize(dir);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &lt; MAX_DIS - E)    {        fragColor = vec4(1,0.75,0.79,1.f);        return;    }      fragColor = vec4(0.f,0.f,0.f,1.f); }</code></pre><h1 id="表面法线"><a href="#表面法线" class="headerlink" title="表面法线"></a>表面法线</h1><ul><li>梯度的值 == 法线的值</li></ul><script type="math/tex; mode=display">∇f=( \frac{​∂f}{​∂x},\frac{​∂f}{​∂y},\frac{​∂f}{​∂z})</script><ul><li>上面的式子可以用下面的式子来近似<blockquote><p>But no need to break out the calculus chops here. Instead of taking the real derivative of the function, we’ll do an approximation by sampling points around the point on the surface, much like how you learned to calculate slope in a function as over rise-over-run before you learned how to do derivatives.</p></blockquote></li></ul><script type="math/tex; mode=display">\vec{n} = \left[ \begin{matrix}​f(x+ε,y,z)−f(x−ε,y,z) \\​f(x,y+ε,z)−f(x,y−ε,z) \\​f(x,y,z+ε)−f(x,y,z−ε) \\\end{matrix} \right]​​</script><pre><code class="lang-cpp">//shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){     return CircleSDF(vec3(0,0,0),1.f,tp);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    dir.xy = fragCoord - size/2.f;       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    return normalize(dir);}vec3 estimateNormal(vec3 p,float EPSILON) {    return normalize(vec3(        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))    ));}vec3 GetColor(vec3 p){    return estimateNormal(p,0.01f);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &gt; MAX_DIS - E)    {        fragColor = vec4(0.f,0.f,0.f,1.f);        return;    }    fragColor = vec4(GetColor(eye + depth * dir),1.f);}</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/" target="_blank" rel="noopener">http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a><br><a href="https://zhuanlan.zhihu.com/p/36759481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36759481</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-CoordinateSystems</title>
      <link href="/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/"/>
      <url>/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Transformations</title>
      <link href="/2019/12/04/CG/Opengl/LearnOpengl-Transformations/"/>
      <url>/2019/12/04/CG/Opengl/LearnOpengl-Transformations/</url>
      
        <content type="html"><![CDATA[<ul><li>单位向量 $\hat{n}$</li></ul><h1 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h1><ul><li>它允许我们在3D向量上进行位移</li><li>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ul><li>用于避免万向结死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Textures</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Textures/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Textures/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h1><ul><li><p>纹理坐标中,左下角位(0,0),右上角位(1,1)<br><img src="tex_coords.png" alt></p></li><li><p>使用纹理坐标获取纹理颜色叫做<strong>采样(Sampling)</strong></p></li></ul><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><ul><li>原文讲的够好了<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></li></ul><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><ul><li><p>产生原因:纹理坐标可以取任意浮点值，所以纹理元素与纹理坐标无法一一对应</p></li><li><p>纹理元素(Texel)</p></li></ul><blockquote><p>而纹素是纹理图片空间的基本单元，可以看成是纹理的组成“像素”</p></blockquote><ul><li>纹理过滤（Texture Filtering)</li></ul><blockquote><p>一个像素一般不会正好对应于一个纹元（texel)。所以像素的颜色无法直接得到，需要经过一定的运算，这个过程就是纹理过滤。<br>参考网址：<a href="https://zhuanlan.zhihu.com/p/91208143" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91208143</a></p></blockquote><ul><li>有两种常见的纹理过滤的方式:GL_NEAREST和GL_LINEAR</li></ul><blockquote><p>邻近过滤:选择中心点最接近纹理坐标的那个像素<br>线性过滤:基于纹理坐标附近的纹理像素，计算出一个插值。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。<br>具体项目可见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a>  </p></blockquote><ul><li>如何设置过滤方式</li></ul><pre><code class="lang-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><blockquote><p>GL_TEXTURE_MAG_FILTTER:纹理元素的数量 &lt; 图元像素的数量。比如texture为256*256，图元为512*512。相当于纹理元素被放大，一个纹理元素的颜色决定多个图元像素的颜色</p><p>GL_TEXTURE_MIN_FILTER 纹理元素的数量 &gt; 图元像素的数量。比如texture为512*512,图元为256*256。相当于纹理被缩小，一个图元像素的颜色由多个纹理像素决定。</p></blockquote><h1 id="多级渐远纹理-Mipmap"><a href="#多级渐远纹理-Mipmap" class="headerlink" title="多级渐远纹理(Mipmap)"></a>多级渐远纹理(Mipmap)</h1><ul><li><p>产生原因:我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段(像素)，OpenGL从高分辨率纹理中为这些片段（像素）获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段（像素）只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p></li><li><p>多级渐远纹理：简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一</p></li><li><p>距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 </p></li><li><p>Mipmap的例子如下<br><img src="mipmaps.png" alt></p></li><li><p>可以在GL_TEXTURE_MIN_FILTER中使用多级渐远纹理过滤选项，但是在GL_TEXTURE_MAG_FILTER中无法使用，纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p></li></ul><h1 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><pre><code class="lang-cpp">int width, height, nrChannels;//地址、宽度、高度、颜色通道的个数、期望通道数（得到的data中的数据的通道数目）unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</code></pre><h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><pre><code class="lang-cpp">unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    //用于生成2D纹理    // 参数一：设置纹理目标，一般为GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D    // 参数二：Mipmap级别,手动设置每个的话这里设0    // 参数三：纹理存储格式    // 参数四：宽度    // 参数五：长度    // 0    // 参数六：image的的存储格式    // 参数七：图像数据    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    //为当前绑定的纹理自动生成所有需要的多级渐远纹理。    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}//释放图像的内存stbi_image_free(data);</code></pre><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><ul><li>在定点数组中添加纹理坐标</li><li>在VS中声明纹理坐标属性</li><li>利用glVertexAttribPointer给定点数组中的纹理坐标解释，并启用该定点属性</li><li>在PS中获取VS中的纹理坐标，声明sampler2D变量</li><li>glActiveTexture激活对应的纹理单元</li><li>利用texture(ourTexture, TexCoord)使用之前设置的纹理参数对相应的颜色值进行采样</li></ul><h1 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h1><ul><li>uniform sampler2D MySampler存放纹理的位置称为纹理单元。</li><li>opengl有GL_TEXTURE0 - GL_TEXTURE15总共16个纹理单元。</li><li>使用方式如下</li></ul><pre><code class="lang-cpp">// 设置着色器采样器使用哪个纹理单元ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置</code></pre><pre><code class="lang-cpp">//激活纹理单元glActiveTexture(GL_TEXTURE0);//绑定时会自动使用当前激活的纹理单元 glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);</code></pre><ul><li>纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</li></ul><h1 id="图片翻转问题"><a href="#图片翻转问题" class="headerlink" title="图片翻转问题"></a>图片翻转问题</h1><ul><li>纹理可能上下颠倒，这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。</li></ul><pre><code class="lang-cpp">//解决方法stbi_set_flip_vertically_on_load(true);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Shaders</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Shaders/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Shaders/</url>
      
        <content type="html"><![CDATA[<ul><li><p>很多都是概念性的东西，教程里整理的很好<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1</a></p></li><li><p>layout (location = 0)</p><blockquote><p>为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。</p></blockquote></li><li><p>如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）</p></li></ul><h1 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h1><ul><li>uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</li><li>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4Live_RenderProcess</title>
      <link href="/2019/10/08/CG/UE4/Old/UE4Live-RenderProcess/"/>
      <url>/2019/10/08/CG/UE4/Old/UE4Live-RenderProcess/</url>
      
        <content type="html"><![CDATA[<p>视频地址 <a href="https://www.bilibili.com/video/av35615021?t=3626" target="_blank" rel="noopener">https://www.bilibili.com/video/av35615021?t=3626</a><br>相关图片 <a href="https://blog.csdn.net/jli_family/article/details/86584208" target="_blank" rel="noopener">https://blog.csdn.net/jli_family/article/details/86584208</a></p><p><img src="UE4Live_RenderProcess.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloTriangle</title>
      <link href="/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/"/>
      <url>/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/</url>
      
        <content type="html"><![CDATA[<ul><li><p>通过opengl绘制图形，需要通过opengl的渲染管线，这一过程实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p></li><li><p>对于利用opengl画出一个三角形，归纳为以下步骤</p></li></ul><h1 id="build-and-compile-our-shader-program"><a href="#build-and-compile-our-shader-program" class="headerlink" title="build and compile our shader program"></a>build and compile our shader program</h1><p><img src="Opengl_ShaderCreate.png" alt></p><ul><li>在OpenGL的渲染管线中，我们必须要配置VS和FS(PS)两个着色器,可以选择配置GS。</li></ul><pre><code class="lang-cpp">//创建着色器的方式/***  * 创建一个指定类型的着色器，返回指向这个着色器的在显存地址的引用***/int MyShader = glCreateShader(TYPE_OF_SHADER);</code></pre><ul><li>着色器程序运行的着色器语言，在opengl中使用的是GLSL。所以我们需要编写GLSL,并且将其绑定到我们创建的着色器上</li></ul><pre><code class="lang-cpp">/***  * MyShaderSource中写入待绑定的GLSL程序***/const char *MyShaderSource = &quot;#version 330 core\n&quot;    &quot;out vec4 FragColor;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;    &quot;}\n\0&quot;;/***  * 将GLSL程序与Shader进行绑定  * Shader显存地址/程序数量/字符串(数组)/字符串数组长度***/glShaderSource(MyShader, 1, &amp;MyShaderSource, NULL);</code></pre><ul><li>进行着色器编译并显示Debug信息</li></ul><pre><code class="lang-cpp">glCompileShader(vertexShader);// check for shader compile errorsint success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success){    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}</code></pre><ul><li>到这里我们的着色器就编译好了，接下来我们需要将编译好的着色器链接成一个着色器对象。这个着色器对象就是我们将数据渲染到屏幕所使用的的渲染管线。</li></ul><pre><code class="lang-cpp">unsigned int shaderProgram;shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) {    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGTRAM::LINK_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}/***  * 在之后可以调用glUseProgram(shaderProgram)来使用这个我们已经链接好的着色器程序对象。***///别忘了垃圾回收，这两个这时候已经没用了glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h1 id="set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes"><a href="#set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes" class="headerlink" title="set up vertex data (and buffer(s)) and configure vertex attributes"></a>set up vertex data (and buffer(s)) and configure vertex attributes</h1><ul><li>我们要画图形的话，需要几样的东西，首先是需要在内存中准备顶点，然后传输到显存中。</li></ul><h2 id="VBO-vertex-buffer-objects-顶点缓冲对象"><a href="#VBO-vertex-buffer-objects-顶点缓冲对象" class="headerlink" title="VBO(vertex buffer objects):顶点缓冲对象"></a>VBO(vertex buffer objects):顶点缓冲对象</h2><pre><code class="lang-cpp">unsigned int VBO;//这里用&amp;，是因为直接改变VBO指向内存单元的数据，执行完后VBO保存一个显存地址glGenBuffers(1, &amp;VBO);//这一步将显存地址与GL_ARRAY_BUFFER绑定，这样之后所有对GL_ARRAY_BUFFER，其实就是在操作VBO所指的显存区域。glBindBuffer(GL_ARRAY_BUFFER, VBO);//这一步是用于将内存中的数据传输到显存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><ul><li>上述代码用于创建一个叫做VBO缓冲对象的东西，这个用于存储将来从内存传输过来的定点数据。</li></ul><h2 id="解释显存中的缓存数据"><a href="#解释显存中的缓存数据" class="headerlink" title="解释显存中的缓存数据"></a>解释显存中的缓存数据</h2><ul><li>在显存中的数据，我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。</li></ul><pre><code class="lang-cpp">//该函数用于让OpenGL知道该如何解析顶点数据//第一个参数表示该数据希望传输到VS的哪一个参数。比如//  layout (location = 0) in vec3 aPos;//  layout (location = 1) in vec3 bPos;//第一个参数设为0则该数据传入aPos,1则传入bPos//第二个参数表示该定点属性的大小，这里是3//第三个参数表示大小为3，每个部分的类型为float//第四个参数表示是否要标准化设备坐标(Normalized Device Coordinates, NDC)//第五个参数表示每个顶点属性的总大小,对于紧密排列的数据可以用0代替//第六感参数表示位置数据在缓冲中起始位置的偏移量(Offset)，比如sizeof(float)，则偏移一个float值，3*sizeof(float)，则偏移一个定点glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</code></pre><ul><li>接下来我们应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</li></ul><pre><code class="lang-cpp">glEnableVertexAttribArray(0);</code></pre><h2 id="VAO-Vertex-Array-Objec-顶点数组对象"><a href="#VAO-Vertex-Array-Objec-顶点数组对象" class="headerlink" title="VAO(Vertex Array Objec):顶点数组对象"></a>VAO(Vertex Array Objec):顶点数组对象</h2><ul><li>一个顶点数组对象会储存以下这些内容：<blockquote><p>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</p></blockquote></li></ul><blockquote><p>通过glVertexAttribPointer设置的顶点属性配置。</p><p>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</p></blockquote><ul><li>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</li><li>也就是说我们对VBO的所有配置都会保存在我们所绑定的VAO中，如果之后想要使用这一配置，只需要重新绑定它就行了。</li></ul><pre><code class="lang-cpp">//VAO绑定unsigned int VAO;glGenVertexArrays(1, &amp;VAO);glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO解绑glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO使用glBindVertexArray(VAO);</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code class="lang-cpp">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..// 1. bind Vertex Array ObjectglBindVertexArray(VAO);// 2. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. then set our vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);  //glBindVertexArray(0);...// ..:: Drawing code (in render loop) ::..// 4. draw the objectglUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();</code></pre><h1 id="render-loop"><a href="#render-loop" class="headerlink" title="render loop"></a>render loop</h1><ul><li>如何使用我们所自定义的着色器和配置好的定点属性呢?</li></ul><pre><code class="lang-cpp">// draw our first triangleglUseProgram(shaderProgram);glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organizedglDrawArrays(GL_TRIANGLES, 0, 3);// glBindVertexArray(0); // no need to unbind it every time</code></pre><ul><li>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象</li><li>在glBindVertexArray函数调用之后，会使用VAO中所保存的顶点数据配置</li><li>glDrawArray函数用于绘制图元，第一个函数是图元类型，第二个参数指定了顶点数组的起始索引，第三是顶点个数。绘制glVertexAttribPointer绑定后的第几个位置开始的几个定点。注意这里是定点的偏移，比如这里上下文中大小为 3*sizeof(float)</li><li>需要区分在glVertexAttribPointer中的offset和这里的索引</li></ul><h1 id="EBO-Element-Buffer-Object-引缓冲对象"><a href="#EBO-Element-Buffer-Object-引缓冲对象" class="headerlink" title="EBO(Element Buffer Object):引缓冲对象"></a>EBO(Element Buffer Object):引缓冲对象</h1><ul><li>用于指定定点的绘制顺序</li></ul><pre><code class="lang-cpp">unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</code></pre><pre><code class="lang-cpp">//这里改用这glDrawElements来画三角形glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><ul><li>注意VAO也会保存EBO的数组配置信息，glDrawElements会使用我们绑定的EBO中的索引顺序,所以要注意解绑VAO的顺序</li></ul><h1 id="绘制最终流程"><a href="#绘制最终流程" class="headerlink" title="绘制最终流程"></a>绘制最终流程</h1><pre><code class="lang-cpp">// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染编程 - 资源操作</title>
      <link href="/2019/10/07/CG/UE4/Old/UE4Render-ResourceOperation/"/>
      <url>/2019/10/07/CG/UE4/Old/UE4Render-ResourceOperation/</url>
      
        <content type="html"><![CDATA[<h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><ul><li>Compute Shader<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-</a><br><a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Compute_Shader</a></li></ul><h1 id="UAV"><a href="#UAV" class="headerlink" title="UAV"></a>UAV</h1><ul><li>Unordered Access view<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在shader文件中添加第二个颜色变量</title>
      <link href="/2019/10/06/CG/UE4/Old/UE4Render-addParams/"/>
      <url>/2019/10/06/CG/UE4/Old/UE4Render-addParams/</url>
      
        <content type="html"><![CDATA[<h1 id="在shader文件中添加第二个颜色变量"><a href="#在shader文件中添加第二个颜色变量" class="headerlink" title="在shader文件中添加第二个颜色变量"></a>在shader文件中添加第二个颜色变量</h1><p><a href="https://zhuanlan.zhihu.com/p/36635394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36635394</a><br><a href="https://zhuanlan.zhihu.com/p/36695496" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36695496</a><br>在看了shader编程的第二第三章后,觉的似懂非懂。再上面添加点东西,便于很深入的理解</p><h2 id="MyShader-usf"><a href="#MyShader-usf" class="headerlink" title="MyShader.usf"></a>MyShader.usf</h2><ul><li>我们从目标要求开始,这里我想要使得输出颜色变为两个颜色的和，比如可以让颜色变成R+G,R+B等等</li><li>这里我们现在usf文件中做如下添加和修改</li></ul><pre><code class="lang-cpp">// MyShader.usf#include &quot;/Engine/Public/Platform.ush&quot;float4 SimpleColor;// 增加一个颜色采样的变量float4 SimpleColor2;void MainVS( in float4 InPosition : ATTRIBUTE0, out float4 OutPosition : SV_POSITION ){ // screenspace position from vb    OutPosition = InPosition;}void MainPS(    out float4 OutColor : SV_Target0    ){    // 输出颜色变为两种颜色的叠加    OutColor = (SimpleColor + SimpleColor2);}</code></pre><h2 id="MyShaderTest-h"><a href="#MyShaderTest-h" class="headerlink" title="MyShaderTest.h"></a>MyShaderTest.h</h2><ul><li>因为添加了一个颜色变量，我们得将相关数据传进去。首先想到的是在蓝图中增加一个引脚</li></ul><pre><code class="lang-cpp">// MyShaderTest.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UObject/ObjectMacros.h&quot;#include &quot;Classes/Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;MyShaderTest.generated.h&quot;UCLASS(MinimalAPI, meta = (ScriptName = &quot;TestShaderLibrary&quot;))class UTestShaderBlueprintLibrary : public UBlueprintFunctionLibrary{    GENERATED_UCLASS_BODY()        UFUNCTION(BlueprintCallable, Category = &quot;ShaderTestPlugin&quot;, meta = (WorldContext = &quot;WorldContextObject&quot;))        // 在这里增加一个FLinearColor的形参就是增加一个引脚        static void DrawTestShaderRenderTarget(class UTextureRenderTarget2D* OutputRenderTarget, AActor* AC, FLinearColor MyColor,FLinearColor MyColor2);};</code></pre><h2 id="MyShaderTest-cpp"><a href="#MyShaderTest-cpp" class="headerlink" title="MyShaderTest.cpp"></a>MyShaderTest.cpp</h2><h3 id="DrawTestShaderRenderTarget"><a href="#DrawTestShaderRenderTarget" class="headerlink" title="DrawTestShaderRenderTarget"></a>DrawTestShaderRenderTarget</h3><ul><li>为此我们需要进入cpp文件中,添加相应的形参。这个函数是在逻辑线程中调用。</li><li>ENQUEUE_RENDER_COMMAND向渲染线程压入一个渲染命令， 调用DrawTestShaderRenderTarget_RenderThread</li><li>我们需要在lambda表达式中增加我们需要传的变量给渲染线程。<blockquote><p>DrawTestShaderRenderTarget中主要是对数据的获取和传递,一般不需要修改东西，只需要增加你要传递的各类数据。</p></blockquote></li></ul><pre><code class="lang-cpp">// MyShaderTest.cppvoid UTestShaderBlueprintLibrary::DrawTestShaderRenderTarget(    UTextureRenderTarget2D* OutputRenderTarget,    AActor* Ac,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInGameThread());    if (!OutputRenderTarget)    {        return;    }    FTextureRenderTargetResource* TextureRenderTargetResource = OutputRenderTarget-&gt;GameThread_GetRenderTargetResource();    UWorld* World = Ac-&gt;GetWorld();    ERHIFeatureLevel::Type FeatureLevel = World-&gt;Scene-&gt;GetFeatureLevel();    FName TextureRenderTargetName = OutputRenderTarget-&gt;GetFName();    ENQUEUE_RENDER_COMMAND(CaptureCommand)(        [TextureRenderTargetResource, FeatureLevel, MyColor,MyColor2, TextureRenderTargetName](FRHICommandListImmediate&amp; RHICmdList)    {        DrawTestShaderRenderTarget_RenderThread(RHICmdList, TextureRenderTargetResource, FeatureLevel, TextureRenderTargetName, MyColor,MyColor2);    }    );}</code></pre><h3 id="FMyShaderTest"><a href="#FMyShaderTest" class="headerlink" title="FMyShaderTest"></a>FMyShaderTest</h3><ul><li>因为给DrawTestShaderRenderTarget_RenderThread添加了一个数据，所以需要修改其函数，但是这个比较复杂我们先看简单的。</li><li>渲染管线中VS和PS是一定要自己配置的,所以创建自定义的VS和PS,需要从FGlobalShader继承。然后需要使用</li></ul><pre><code class="lang-cpp">IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><p>这个语句来使相关类和Vertex Shader或Pixel Shader文件绑定，这样渲染管线中将会使用我们自定义的定点着色器和像素着色器</p><ul><li>因为在VS和PS中有些配置是一样的,所以我们可以先从FGlobalShader派生一个FMyShaderTest的类,然后再从FMyShaderTest派生出我们的FShaderTestVS和FShaderTestPS。</li></ul><pre><code class="lang-cpp">// MyShaderTest.cppclass FMyShaderTest : public FGlobalShader{public:    FMyShaderTest() {}    FMyShaderTest(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FGlobalShader(Initializer)    {        SimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));        SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));    }    static bool ShouldCache(EShaderPlatform Platform)    {        return true;    }    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters)    {        //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);          return true;    }    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)    {        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);        OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);    }    void SetParameters(        FRHICommandListImmediate&amp; RHICmdList,        const FLinearColor &amp;MyColor,        const FLinearColor &amp;MyColor2    )    {        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);    }    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }private:    FShaderParameter SimpleColorVal;    FShaderParameter SimpleColorVal2;};</code></pre><p>其中</p><pre><code class="lang-cpp">// MyShaderTest.cppSimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));// MyShader.usffloat4 SimpleColor;float4 SimpleColor2;</code></pre><ul><li>这是将FMyShaderTest中的私有变量与MyShader.usf中变量进行绑定。</li><li><p>但是我们注意到我们还没有将颜色输入到FMyShaderTest中的私有变量。因此我们需要写一个函数用于把我们的颜色信息传到shader里。。</p><pre><code class="lang-cpp">// MyShaderTest.cppvoid SetParameters(  FRHICommandListImmediate&amp; RHICmdList,  const FLinearColor &amp;MyColor,  const FLinearColor &amp;MyColor2){  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);}</code></pre></li><li><p>因为这些参数在PS中使用到，所以此处使用GetPixelShader()参数</p></li></ul><pre><code class="lang-cpp">    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }</code></pre><ul><li>虚幻序列化，用于读取磁盘上的渲染数据，这里需要将我们所需要的SimpleColorVal，SimpleColorVal2;</li></ul><pre><code class="lang-cpp">static bool ShouldCache(EShaderPlatform Platform){    return true;}static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters){    //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);      return true;}static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment){    FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);    OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);}</code></pre><ul><li>剩下这些可以暂时不用管。<h3 id="VS-和-PS"><a href="#VS-和-PS" class="headerlink" title="VS 和 PS"></a>VS 和 PS</h3></li></ul><pre><code class="lang-cpp">class FShaderTestVS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestVS, Global);public:    FShaderTestVS() {}    FShaderTestVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};class FShaderTestPS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestPS, Global);public:    FShaderTestPS() {}    FShaderTestPS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><ul><li>这里从FMyShaderTest派生两个类分别利用IMPLEMENT_SHADER_TYPE宏指定为VS和PS</li></ul><pre><code class="lang-cpp">DECLARE_SHADER_TYPE(FShaderTestVS, Global);</code></pre><ul><li>该宏用于把该Shader加入全局shadermap中，在运行前会将shadermap中的所以shader进行编译。</li></ul><h3 id="DrawTestShaderRenderTarget-RenderThread"><a href="#DrawTestShaderRenderTarget-RenderThread" class="headerlink" title="DrawTestShaderRenderTarget_RenderThread"></a>DrawTestShaderRenderTarget_RenderThread</h3><pre><code class="lang-cpp">static void DrawTestShaderRenderTarget_RenderThread(    FRHICommandListImmediate&amp; RHICmdList,    FTextureRenderTargetResource* OutputRenderTargetResource,    ERHIFeatureLevel::Type FeatureLevel,    FName TextureRenderTargetName,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInRenderingThread());#if WANTS_DRAW_MESH_EVENTS      FString EventName;    TextureRenderTargetName.ToString(EventName);    SCOPED_DRAW_EVENTF(RHICmdList, SceneCapture, TEXT(&quot;ShaderTest %s&quot;), *EventName);#else      SCOPED_DRAW_EVENT(RHICmdList, DrawUVDisplacementToRenderTarget_RenderThread);#endif      //设置渲染目标      SetRenderTarget(        RHICmdList,        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        FTextureRHIRef(),        ESimpleRenderTargetMode::EUninitializedColorAndDepth,        FExclusiveDepthStencil::DepthNop_StencilNop    );    //设置视口      //FIntPoint DrawTargetResolution(OutputRenderTargetResource-&gt;GetSizeX(), OutputRenderTargetResource-&gt;GetSizeY());      //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      TShaderMap&lt;FGlobalShaderType&gt;* GlobalShaderMap = GetGlobalShaderMap(FeatureLevel);    TShaderMapRef&lt;FShaderTestVS&gt; VertexShader(GlobalShaderMap);    TShaderMapRef&lt;FShaderTestPS&gt; PixelShader(GlobalShaderMap);    // Set the graphic pipeline state.      FGraphicsPipelineStateInitializer GraphicsPSOInit;    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);    GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI();    GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI();    GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI();    GraphicsPSOInit.PrimitiveType = PT_TriangleList;    GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();    GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader);    GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader);    SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);    //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      PixelShader-&gt;SetParameters(RHICmdList, MyColor,MyColor2);    // Draw grid.      //uint32 PrimitiveCount = 2;      //RHICmdList.DrawPrimitive(PT_TriangleList, 0, PrimitiveCount, 1);      FVector4 Vertices[4];    Vertices[0].Set(-1.0f, 1.0f, 0, 1.0f);    Vertices[1].Set(1.0f, 1.0f, 0, 1.0f);    Vertices[2].Set(-1.0f, -1.0f, 0, 1.0f);    Vertices[3].Set(1.0f, -1.0f, 0, 1.0f);    static const uint16 Indices[6] =    {        0, 1, 2,        2, 1, 3    };    //DrawPrimitiveUP(RHICmdList, PT_TriangleStrip, 2, Vertices, sizeof(Vertices[0]));      DrawIndexedPrimitiveUP(        RHICmdList,        PT_TriangleList,        0,        ARRAY_COUNT(Vertices),        2,        Indices,        sizeof(Indices[0]),        Vertices,        sizeof(Vertices[0])    );    // Resolve render target.      RHICmdList.CopyToResolveTarget(        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        OutputRenderTargetResource-&gt;TextureRHI,        false, FResolveParams());}</code></pre><ul><li>这是渲染线程中执行的函数</li><li>这里只要在形参中添加MyColor2，以及SetParameters中添加MyColor2</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloWindow</title>
      <link href="/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/"/>
      <url>/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/</url>
      
        <content type="html"><![CDATA[<ul><li><p>glfwMakeContextCurrent(window)</p><blockquote><p>用于在当前线程上载入window的上下文。</p></blockquote></li><li><p>需要在使用opengl函数前加载glad用于定于函数地址</p><pre><code class="lang-cpp">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){  std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;  return -1;}</code></pre><p>疑问:必须在glfwMakeContextCurrent(window)之后才能初始化GLAD,为什么？</p><blockquote><p>我做了一些尝试,glViewport的操作,如果不初始化GLAD,将无法使用。而要初始化GLAD,要在当前线程载入window上下文—190921 </p></blockquote></li></ul><ul><li><p>glViewport()<br>最终显示的内容由glViewport和glfwCreateWindow的参数共同决定：不会超过glfwCreateWindow的大小,小于的话会由部分不加载出来</p><blockquote><p>如果glfwCreateWindow:800*600,glViewport:1600*600,最终 800*600<br>如果glfwCreateWindow:800*600,glViewport:400*300,最终 400*300</p></blockquote></li><li><p>glfwSetFramebufferSizeCallback()<br>这是一个回调绑定函数,他会相应窗口变化，并传递宽高给回调函数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第三章:变换</title>
      <link href="/2019/09/09/CG/DirextX/D3DTransform/"/>
      <url>/2019/09/09/CG/DirextX/D3DTransform/</url>
      
        <content type="html"><![CDATA[<h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>满足以下性质为线性变换<blockquote><p>1.$\tau(u+v) = \tau(u) + \tau(v)$<br>2.$\tau(ku) = k\tau(u)$<br>其中u,v为任意三维向量，k为标量 </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第四章:渲染管线</title>
      <link href="/2019/09/09/CG/DirextX/D3DInit/"/>
      <url>/2019/09/09/CG/DirextX/D3DInit/</url>
      
        <content type="html"><![CDATA[<h1 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h1><ul><li>我们必须使用特定的函数活其他的COM接口方法来获取指向COM接口的指针,而不能用<strong>new</strong>  </li><li>释放用其基类IUnkown的Release,而不能用<strong>delete</strong>  </li><li>COM接口都以<strong>I</strong>为前缀,例如ID3D11Texture2D  </li></ul><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><ul><li>2D纹理是一种数据元素矩阵，可以用于存储图像数据，每个元素存储一个像素颜色。也可以存储纹理法线  </li><li>纹理只支持特定格式的数据类型。有DXGI_FORMAT枚举类型描述  </li><li>存在一种弱类型（typeless），预先分配空间，但不解释类型。</li></ul><h1 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h1><ul><li><strong>离屏</strong>(off-screen) =&gt; <strong>后台缓冲区</strong>(back buffer)</li><li><strong>前台缓冲区</strong>(front buffer)</li><li>前后缓冲区互换的行为为<strong>呈现</strong>(presenting)<blockquote><p>这一操作只是交换两者指针指向的位置，所以速度很快<br><img src="SwapBuffer.png" alt></p></blockquote></li><li>前后缓冲区组成一个<strong>交换链</strong>(swap chain)</li></ul><h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><ul><li>深度缓冲区与后台缓冲区大小一样</li><li>D3D11 判断前后遮挡使用 深度缓存(depth buffering)或Z缓存(z-buffering)</li></ul><h1 id="纹理资源视图"><a href="#纹理资源视图" class="headerlink" title="纹理资源视图"></a>纹理资源视图</h1><ul><li><p>纹理可以被绑定到渲染管线（rendering pipeline）的不同阶段（stage）。  </p><blockquote><p>将纹理作为渲染目标（即，Direct3D渲染到纹理,在渲染结果暂存在纹理中），使用标志D3D11_BIND_RENDER_TARGET<br>着色器资源（即，在着色器中对纹理进行采样），使用标志D3D10_BIND_SHADER_RESOURCE</p></blockquote></li><li><p>纹理不能直接绑定到渲染管线，只能把与资源关联的资源视图绑定到不同的管线阶段  </p></li><li>Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图</strong>（resource view），渲染目标视图（ID3D11RenderTargetView）和着色器资源视图（ID3D11ShaderResourceView） </li><li>创建资源时一定要指定绑定标志值，不然将无法创建资源视图 <h2 id="资源视图的作用"><a href="#资源视图的作用" class="headerlink" title="资源视图的作用"></a>资源视图的作用</h2></li><li>（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</li><li>（2）如果在创建资源时指定的是弱类型（typeless）格式，那么在为它创建资源视图时就必须指定明确的资源类型。对于弱类型格式，纹理元素可能会在一个管线阶段中视为浮点数，而在另一个管线阶段中视为整数。</li></ul><h1 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h1><ul><li>超级采样（supersampling）:比如4x ssaa,将屏幕分别率提高4倍，然后每4个像素采样后取平均值。相当于深度缓存和后台缓存都扩大4倍。</li><li>多重采样（multisampling）:比如4x msaa,只在三角形的边缘进行处理。且每一个像素分为4个子像素。深度缓存和后台缓存也会扩大4倍。</li></ul><h1 id="特征等级"><a href="#特征等级" class="headerlink" title="特征等级"></a>特征等级</h1><ul><li>特征等级定义了一系列支持不同d3d功能的相应的等级，用意即如果一个用户的硬件不支持某一特征等级，程序可以选择较低的等级。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://enjoyphysics.cn/Article1513" target="_blank" rel="noopener">https://enjoyphysics.cn/Article1513</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染模块</title>
      <link href="/2019/09/05/CG/UE4/Old/UE4RenderModule/"/>
      <url>/2019/09/05/CG/UE4/Old/UE4RenderModule/</url>
      
        <content type="html"><![CDATA[<p>原文:<a href="https://zhuanlan.zhihu.com/p/72509370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72509370</a></p><h1 id="UE4场景和场景管理-Scene-、SceneManager"><a href="#UE4场景和场景管理-Scene-、SceneManager" class="headerlink" title="UE4场景和场景管理(Scene 、SceneManager)"></a>UE4场景和场景管理(Scene 、SceneManager)</h1><h2 id="Scene与UWorld和FScene"><a href="#Scene与UWorld和FScene" class="headerlink" title="Scene与UWorld和FScene"></a>Scene与UWorld和FScene</h2><ul><li>UE4 Scene有UWorld和FScene组成  </li><li>UWorld用于游戏线程，包括用户的主动行为，如物体的创建和删除。</li><li>FScene用于渲染线程，包括物体的被动行为。</li><li>UWorld和FScene一一对应</li></ul><h2 id="UWorld和ULevel和ULevelStraming"><a href="#UWorld和ULevel和ULevelStraming" class="headerlink" title="UWorld和ULevel和ULevelStraming"></a>UWorld和ULevel和ULevelStraming</h2><ul><li>UWorld由持久关卡(ULevel)和子关卡组成。子关卡可以动态加卸载，也被称为流关卡(ULevelStreaming)</li><li>流关卡(ULevelStreaming)加载和卸载由UWorldComposition负责。由基于视点距离和流关卡卡包围盒的简单的加载策略实现</li><li>具体物体放置在关卡活流关卡中，而不是在UWorld中</li></ul><h2 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h2><ul><li>FScene不具备复杂的场景管理功能</li><li>FScene有以下结构<blockquote><p>数组:用于管理各种可渲染对象和灯光<br>Octree:用于灯光和可渲染对象的快速查找<br>DrawList:用于Cache各个渲染指令</p></blockquote></li></ul><h1 id="SceneObject"><a href="#SceneObject" class="headerlink" title="SceneObject"></a>SceneObject</h1><ul><li>将具体物体放入场景(即关卡和流关卡)中的时候，各个独立物体是由AActor及其子类的对象实例来建模表达</li><li>AActor和其子类不直接持有渲染数据，具体的渲染相关的数据均在UActorComponent及其子类的实例中。</li><li>渲染相关的主要Component类结构层次如下<br><img src="ComponentClassLevel.jpg" alt></li></ul><h1 id="UE4渲染API封装"><a href="#UE4渲染API封装" class="headerlink" title="UE4渲染API封装"></a>UE4渲染API封装</h1><ul><li>UE4中的渲染API封装是个独立的模块(Module)，他们把它命名为RHI（Render Hardware Interface）</li><li>RHI的转发实现在RHICommandList.h文件里，除了基本的条件判断，大都是直接 转调渲染API实现的RHI子模块里的渲染指令。</li></ul><h1 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h1><ul><li>UE4对材质系统的封装可以理解为RenderPipeline输入的所有数据中除了几何体数据之外的所有其它数据。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li>材质分为材质模块(UMaterial)和材质实例(UMaterialInstance),两者继承自UMaterialInterface</li><li>UMaterial材质模板带有可编辑的节点图并可据此生成对应的Shader组合</li><li>UMaterialInstance材质实例则只需要引用UMaterial对应的Shader且只能修改材质模板暴露出来的材质参数。</li></ul><h2 id="FMaterialResource"><a href="#FMaterialResource" class="headerlink" title="FMaterialResource"></a>FMaterialResource</h2><ul><li>没关UMaterial中含有多个FMaterialResource，其继承自FMateriale。其负责为各个渲染API和材质所支持的各种质量等级生成对应的Shader组合</li></ul><h2 id="FMaterialRenderProxy"><a href="#FMaterialRenderProxy" class="headerlink" title="FMaterialRenderProxy"></a>FMaterialRenderProxy</h2><ul><li>FMaterialRenderProxy是FMaterial用于渲染线程的代理,它可以透过FMaterail和UMaterialInterface访问到Shader、渲染状态，光照模型等所有用户设置好的材质参数。</li></ul><hr><ul><li>UE4的材质中光照模型是不可定制的，除非修改源码</li></ul><h1 id="UE4中Shader生成"><a href="#UE4中Shader生成" class="headerlink" title="UE4中Shader生成"></a>UE4中Shader生成</h1><ul><li>UE4的shader基类为FShader,其有两个主要的子类FGlobalShader和FMaterialShader</li><li>FGlobalShader:全局Shader,会自动注册到全局ShaderCache中</li><li>FMaterialShader:用于材质(编辑器）的Shader，所有的后处理、UI、用于模型渲染的Shader都是它的子类。 </li><li>UE4 Shader生成分两部分<blockquote><p>第一部分是把材质编辑器中的节点图编译成HLSL代码，这一部分是通过FHLSLMaterialTranslator来完成的。<br>第二部分是把HLSL生成多平台的Shader代码，如Windows上的HLSL,Android上的GLSL,IOS上的MetalShader。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第五章:渲染管线</title>
      <link href="/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉"><a href="#三维视觉" class="headerlink" title="三维视觉"></a>三维视觉</h1><ul><li>渲染管线:在给定一个3D场景的几何描述及一架已确定位置和方向的虚拟摄像机时，根据虚拟摄像机的视角生成2D图像的一系列步骤<blockquote><p>渲染管线由许多步骤组成，每个步骤称为一个阶段</p></blockquote></li></ul><p><img src="5-1.jpg" alt></p><ul><li>线性透视（linear perspective）:在2d画布上两条平行的线不断向远处延伸，最终会相交到一点。这个点是零点（vanishing point）<br><img src="5-2.jpg" alt></li><li>景深现象（depth phenomenon）:物体的大小会随着深度的增加而减小<br><img src="5-3.jpg" alt></li><li>物体重叠（object overlap）:一个不透明的物体会挡住它后面的其他物体的一部分（或全部）<br><img src="5-4.jpg" alt></li><li>光照（lighting）和阴影（shading）:表现物体立体感和体积感<br><img src="5-5.jpg" alt><blockquote><p>阴影具有两个关键作用：一是告诉我们场景中的光源位置，二是告诉我们飞船距离地面的高度。<br><img src="5-6.jpg" alt></p></blockquote></li></ul><h1 id="模型的表现形式"><a href="#模型的表现形式" class="headerlink" title="模型的表现形式"></a>模型的表现形式</h1><ul><li>三角形是构成物体模型的基本单位</li></ul><h1 id="基本计算机颜色"><a href="#基本计算机颜色" class="headerlink" title="基本计算机颜色"></a>基本计算机颜色</h1><h2 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h2><ul><li><p>0.5(1, 1,1) = (0.5, 0.5, 0.5)</p><blockquote><p>将白色乘以0.5，得到一个中等强度的灰色</p></blockquote></li><li><p>分量乘法（componentwise multiplication）。</p><blockquote><p>$(c_{r},c_{g},c_{b}) ⨂ (k_{r},k_{g},k_{b}) = (c_{r}k_{r},c_{g}k_{g},c_{b}k_{b})$<br>(r,g,b)⨂(0.5,0.75,0.25) = (0.5r,0.75g,0.25b)<br>常用于光照方程,比如上述式子可以表示：光线照射物体时，反射50%红光，75%绿光，25%蓝光</p></blockquote></li></ul><h2 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h2><ul><li><p>alpha值：用于表示物体的不透明度</p><blockquote><p>alpha == 0 完全透明；alpha == 1 完全不透明</p></blockquote></li><li><p>r,g,b,a各用32位浮点型，所以这种表达方式共128位</p></li></ul><h2 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h2><ul><li><p>r,g,b,a分别用8位表示，每个分量又256种强度。</p></li><li><p>32位于128位互相转换</p><blockquote><p>32-&gt;128: 各分量除以256，转换为float<br>128-&gt;32: 各分量乘以256, 转换为int</p></blockquote></li><li><p>通常，许多颜色运算（例如，在像素着色器中）使用的都是128位颜色值；通过这一方式，我们可以有足够多的二进制位来保证计算的精确度，减少算术错误的累积。不过，最终的像素颜色通常是存储在后台缓冲区的32位颜色值中；目前的物理显示设备还不能充分利用更高的分辨率颜色。</p></li></ul><h1 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h1><p><img src="5-7.jpg" alt></p><blockquote><p>内存到阶段的箭头表示阶段从内存种读数据<br>内存到阶段的箭头表示阶段在内存种写数据</p></blockquote><h1 id="输入装配阶段-Input-Assembler-Stage"><a href="#输入装配阶段-Input-Assembler-Stage" class="headerlink" title="输入装配阶段(Input Assembler Stage)"></a>输入装配阶段(Input Assembler Stage)</h1><p>输入装配（Input Assembler，简称IA）阶段从内存读取几何数据（顶点和索引）并将这些数据组合为几何图元（例如，三角形、直线）。</p><blockquote><p>索引规定了顶点的组织形式，解释了该以何种方式组成图元。</p></blockquote><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><ul><li>Direct3D中的顶点由空间位置和各种附加属性组成。比如添加法线向量实现光照，添加纹理坐标实现纹理等等</li></ul><h2 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h2><ul><li>顶点缓冲区:在连续内存中存储了的一个顶点列表</li><li>图元拓扑:用来指定如何组织顶点缓冲区的顶点。例如每两个组成一条直线，每三个组成一个三角形</li></ul><h3 id="基本图元"><a href="#基本图元" class="headerlink" title="基本图元"></a>基本图元</h3><p><img src="5-8.png" alt></p><blockquote><p>(a)为点列表  D3D11_PRIMITIVE_TOPOLOGY_POINTLIST<br>(b)为线带 D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP<br>(c)为线列表 D3D11_PRIMITIVE_TOPOLOGY_LINELIST<br>(d)为三角形带 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 三角形带不会造成顶点的重复存储  </p></blockquote><p><img src="5-9.png" alt></p><blockquote><p>(a)为三角形列表 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST</p></blockquote><h3 id="带邻接信息的图元"><a href="#带邻接信息的图元" class="headerlink" title="带邻接信息的图元"></a>带邻接信息的图元</h3><ul><li>如上图(b)主要用于某些几何着色器的的算法 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ<blockquote><p>邻接图元顶点只能作为几何着色器的输入数据且不会被绘制出来</p></blockquote></li></ul><h3 id="控制点面片列表"><a href="#控制点面片列表" class="headerlink" title="控制点面片列表"></a>控制点面片列表</h3><ul><li>见13章  D3D11_PRIMITIVE_TOPOLOGY_N_CONTRIL_POINT_PATCHLIST<blockquote><p>用于图形渲染管线的细分阶段</p></blockquote></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>问题：通过三角形构造其他图形的时候，如果使用三角形列表，将会造成大量的顶点的重复。</p></li><li><p>产生影响: 1.增加内存需求量。2.增加图形硬件的处理负担。</p></li><li><p>方法一：使用三角形带。但是顶点必须按照带状组织，不灵活。</p></li><li><p>方法二：引入索引。</p><pre><code class="lang-cpp">//create a quadVertex v[4] = {v0, v1, v2, v3}; UINT indexList[6] = {0, 1, 2,    //Triangle0   0, 2, 3}; // Triangle 1 };</code></pre><blockquote><p>当顶点列表中的唯一顶点得到处理之后，显卡可以使用索引列表把顶点放在一起构成三角形。我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为：<br>1．索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。<br>2．通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p></blockquote></li></ul><h1 id="顶点着色器阶段-vertex-shader-Stage"><a href="#顶点着色器阶段-vertex-shader-Stage" class="headerlink" title="顶点着色器阶段(vertex shader Stage)"></a>顶点着色器阶段(vertex shader Stage)</h1><p>顶点着色器将IA阶段的输出的顶点实现相关效果再输出（例如变换，光照，置换贴图映射等）。此外此阶段还可以访问内存种的纹理和其他数据（变换矩阵和场景灯光）。可以概念性地认为在硬件上执行了如下代码：</p><pre><code class="lang-cpp">for(UINT i = 0; i &lt; numVertices; ++i)    outputVertex[i] = VertexShader(inputVertex[i]);</code></pre><h2 id="局部空间和世界空间"><a href="#局部空间和世界空间" class="headerlink" title="局部空间和世界空间"></a>局部空间和世界空间</h2><ul><li>世界变换:局部空间-&gt;世界空间</li></ul><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><ul><li>观察变换:世界空间-&gt;观察空间</li></ul><h2 id="齐次裁剪控件"><a href="#齐次裁剪控件" class="headerlink" title="齐次裁剪控件"></a>齐次裁剪控件</h2><p><a href="https://gameinstitute.qq.com/community/detail/117556" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/117556</a></p><h2 id="规范化设备坐标-NDC"><a href="#规范化设备坐标-NDC" class="headerlink" title="规范化设备坐标(NDC)"></a>规范化设备坐标(NDC)</h2><ul><li>将坐标都映射到[-1,1]，目的是消除设备差异性</li></ul><h1 id="曲面细分阶段"><a href="#曲面细分阶段" class="headerlink" title="曲面细分阶段"></a>曲面细分阶段</h1><ul><li>可选阶段,详见13章</li></ul><h1 id="几何着色器阶段"><a href="#几何着色器阶段" class="headerlink" title="几何着色器阶段"></a>几何着色器阶段</h1><ul><li>接收完整的图元数据</li><li>用于创建和销毁几何体<blockquote><p>根据接收到的图元数据来扩展图元或根据某些条件来拒绝输出某些图元数据<br>常用于将一个点扩展为一个四边形，或者将一条线扩展为一个四边形</p></blockquote></li><li>顶点位置在离开几何着色器之前，必须被变换到齐次裁剪空间。</li></ul><h1 id="裁剪阶段"><a href="#裁剪阶段" class="headerlink" title="裁剪阶段"></a>裁剪阶段</h1><ul><li>完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。</li><li>三角形被裁剪后会变成四边形，这需要重新划分三角形</li><li>Sutherland-Hodgeman裁剪法:</li></ul><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><ul><li>齐次裁剪空间-&gt;规范化设备空间-&gt;后台缓冲区的视口区域（此时x,y以像素为单位）</li><li>z值还要被深度缓存使用。</li></ul><h2 id="背面消隐"><a href="#背面消隐" class="headerlink" title="背面消隐"></a>背面消隐</h2><h3 id="判断三角形正反面"><a href="#判断三角形正反面" class="headerlink" title="判断三角形正反面"></a>判断三角形正反面</h3><ul><li>设三角形的定点排列为$v_{0},v_{1},v_{2}$</li><li>可以计算出三角形的法线，方法如下:<blockquote><p>$\vec{e_{0}} = v_{1} - v_{0}$<br>$\vec{e_{1}} = v_{2} - v_{1}$<br>$\vec{n} = \frac{\vec{e_{0}} × \vec{e_{1}}}{|| \vec{e_{0}} × \vec{e_{1}} ||}$</p></blockquote></li><li>带有法线向量的面为正面，而另一个面为背面<blockquote><p>当观察者看到三角形的正面时，我们说三角形是朝前的；当观察者看到三角形的背面时， 我们说三角形是朝后的。<br>因为按照我们选择的约定（即，我们计算三角形法线的方式），按顺时针方向环绕的三角形（相对于观察者）是朝前的，而按逆时针方向环绕的三角形（相对于观察者）是朝后的。</p></blockquote></li><li>D3D 顺时针</li></ul><h3 id="背面消隐-backface-culling"><a href="#背面消隐-backface-culling" class="headerlink" title="背面消隐(backface culling)"></a>背面消隐(backface culling)</h3><ul><li>背面消隐（backface culling）是指让管线放弃对朝后的三角形的处理。这可以将所要处理的三角形的数量降低到原数量的一半。</li><li>以下为2D和3D场景消隐前后的表现<br><img src="backfaceCulling2D.png" alt><br><img src="backfaceCulling3D.png" alt></li></ul><h2 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h2><ul><li>一条3D线被投影到投影窗口上（在屏幕空间中投影是一条2D线）。我们看到，在3D线上取等距离的点，在2D屏幕空间上的投影点却不是等距离的。所以，我们在3D空间中执行线性插值，在屏幕空间需要执行非线性插值。</li></ul><h1 id="像素着色器阶段"><a href="#像素着色器阶段" class="headerlink" title="像素着色器阶段"></a>像素着色器阶段</h1><ul><li>像素着色器（Pixel shader）是由我们编写的在GPU上执行的程序。像素着色器会处理每个像素片段（pixel fragment），它的输入是插值后的顶点属性，由此计算出一个颜色。像素着色器可以非常简单地输出一个颜色，也可以很复杂，例如实现逐像素光照、反射和阴影等效果。</li></ul><h1 id="输出合并阶段"><a href="#输出合并阶段" class="headerlink" title="输出合并阶段"></a>输出合并阶段</h1><ul><li>当像素片段由像素着色器生成之后，它们会被传送到渲染管线的输出合并（output<br>merger，简称OM）阶段。在该阶段中，某些像素片段会被丢弃（例如，未能通过深度测试或模板测试）。未丢弃的像素片段会被写入后台缓冲区。混合（blending）工作是在该阶段中完成的，一个像素可以与后台缓冲区中的当前像素进行混合，并以混合后的值作为该像素的最终颜色。某些特殊效果，比如透明度，就是通过混合来实现的；我们会在第9章专门讲解混合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之JSON学习</title>
      <link href="/2019/08/07/CG/UE4/Old/JSON/"/>
      <url>/2019/08/07/CG/UE4/Old/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>JSON格式</li><li>解析JSON文件</li><li>修改JSON文件</li></ul><h1 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/29119549" target="_blank" rel="noopener">十分钟搞定JSON和JSON对象</a></li></ul><p>想要使用JSO相关工具，必须在<strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;,         &quot;Json&quot;,         &quot;JsonUtilities&quot;    });</code></pre><h1 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h1><ul><li>我们在 \Content\Res\Data.json中天下如下测试例子</li></ul><pre><code class="lang-json">/** Data.json **/[    {        &quot;1-1&quot;:&quot;1-1&quot;,        &quot;1-2&quot;:&quot;1-2&quot;    },    {        &quot;2-1&quot;:&quot;2-1&quot;    },    {        &quot;3-1&quot;:        [            {                &quot;1&quot;:&quot;3-1-1&quot;            },            {                &quot;2&quot;:&quot;3-1-2&quot;            }        ]    }]</code></pre><ul><li>我们要首先得将他以字符串的形式读入<blockquote><p>FPaths::GameContentDir() 能获取 */Content/ 的位置<br>FFileHelper::LoadFileToString() Load a text file to an FString.</p></blockquote></li></ul><pre><code class="lang-cpp">bool MyJsonHandle::LoadStringFromFile(FString &amp; RelativePathName, FString &amp; FileName, FString &amp; ResultString){    if (!FileName.IsEmpty())    {        FString AbsloutePathName = FPaths::GameContentDir() + RelativePathName + FileName;        if (FPaths::FileExists(AbsloutePathName))        {            if (FFileHelper::LoadFileToString(ResultString, *AbsloutePathName))            {                return true;            }        }    }    return false;}`</code></pre><ul><li>接下来我们来解析我们所获取到的FString</li></ul><pre><code class="lang-cpp">/** MyJsonHandle.cpp **/bool MyJsonHandle::RecordDataJsonRead(){    FString result;    //这是我们上面自定义的函数    LoadStringFromFile(RelativePathName, DataFileName, result);    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse;    TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(result);    if (FJsonSerializer::Deserialize(JsonReader, JsonParse))    { //这样解析后的节点全部存在JsonParse中        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-1&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-2&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[1]-&gt;AsObject()-&gt;GetStringField(FString(&quot;2-1&quot;)));        //如果对象是嵌套的，则需要再声明一次TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt;来获取        TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse3 = JsonParse[2]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;3-1&quot;));        if (JsonParse3.IsValidIndex(0))        {            for (int cnt = 1; cnt &lt;= JsonParse3.Num(); ++cnt)            {                UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse3[cnt-1]-&gt;AsObject()-&gt;GetStringField(FString::FromInt(cnt)));            }        }        else        {            UE_LOG(LogTemp, Warning, TEXT(&quot;error JsonParse3&quot;));        }        return true;    }    return false;}</code></pre><h1 id="修改JSON文件"><a href="#修改JSON文件" class="headerlink" title="修改JSON文件"></a>修改JSON文件</h1><h2 id="设置单个属性"><a href="#设置单个属性" class="headerlink" title="设置单个属性"></a>设置单个属性</h2><ul><li>通过下面的代码生成一个<pre><code class="lang-cpp">/*** A Json Object is a structure holding an unordered set of name/value pairs.* In a Json file, it is represented by everything between curly braces {}.*/TSharedPtr&lt;FJsonObject&gt; Object1 = MakeShareable(new FJsonObject);Object1-&gt;SetStringField(&quot;1-1&quot;, &quot;1--1&quot;);Object1-&gt;SetStringField(&quot;1-2&quot;, &quot;1--2&quot;);TSharedPtr&lt;FJsonValueObject&gt; CultureValue = MakeShareable(new FJsonValueObject(CultureObject));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4学习</title>
      <link href="/2019/08/07/Menu/UE4Menu/"/>
      <url>/2019/08/07/Menu/UE4Menu/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&amp;_bid=167&amp;_wv=3&amp;ADUIN=1076613110&amp;ADSESSION=1556776713&amp;ADTAG=CLIENT.QQ.5611_.0&amp;ADPUBNO=26886&amp;taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><p><a href="https://sanctorum003.github.io/2019/08/02/HUD/" target="_blank" rel="noopener">虚幻4之Slate学习一 —— HUD</a><br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a><br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a><br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a><br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/CG/UE4/Old/DelegateAndMacro/"/>
      <url>/2019/08/06/CG/UE4/Old/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><div class="table-container"><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table></div><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="lang-CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="lang-cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="lang-cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="lang-cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="lang-cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="lang-cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="lang-cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li>事件原型<pre><code class="lang-cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="lang-cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li>FReply 告诉引擎如何处理事件<blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li>FReply::Handled() 告诉引擎事件处理完<blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p></li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/public:    //注意SOverlay::FOverlaySlot 是内部类    SOverlay::FOverlaySlot* MySlot;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>我们尝试编写图片的点击效果，来使用委托和宏。SImage默认不带这个效果。</li><li>首先我们创建一个继承于SlateWidget的C++类命名为MyImage</li><li>创建一个委托，用于与SLATE_EVENT绑定。相当于自定义一个需要单击会触发函数的函数原型</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/DECLARE_DELEGATE_RetVal(FReply,FImageOnClicked)</code></pre><ul><li>创建一个SLATE_EVENT,将之前创建的委托与该SLATE_EVENT绑定</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/SLATE_BEGIN_ARGS(SMyHUDWidget){}SLATE_EVENT(FImageOnClicked, ImageOnClicked)SLATE_END_ARGS()</code></pre><ul><li>然后在原来的SMyHUDWidget将SImage换成SMyImage并且可以调用ImageOnClicked()</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            /**              * TSharedPtr&lt;SMyImage&gt; MyImage;            **/            SAssignNew(MyImage, SMyImage)            //.ImageOnClicked()        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        .Expose(MySlot)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    //删除原来语句    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><ul><li>在SMyImage中添加图片</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/#include &quot;SMyImage.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SImage.h&quot;#include &quot;Public/UI/MySlateWidgetStyle.h&quot;#include &quot;Public/UI/MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyImage::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>此时效果如下<br><img src="MyImage.png" alt></p><ul><li>接着我们需要创建一个回调函数用于ImageOnClicked()，传入后event对应FImageOnClicked就绑定该函数了</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::ImageClicked(){    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, &quot;Suceess&quot;);    return FReply::Handled();}</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **//**    * TSharedPtr&lt;SMyImage&gt; MyImage;**/SAssignNew(MyImage, SMyImage).ImageOnClicked(this, &amp;SMyHUDWidget::ImageClicked)</code></pre><ul><li>但是这时候会发现，单击并没有什么效果。这是因为程序并不知道要根据单击触发。</li><li>我们需要在MyImage中重写鼠标相关函数</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/public:    FImageOnClicked ImageOnClick;    virtual FReply OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual FReply OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual void OnMouseLeave(const FPointerEvent&amp; MouseEvent) override;    bool BIsMouseButtonDown = false;</code></pre><ul><li>我们这时候需要在鼠标按下时调用委托，使用我们必须事先获取到这个委托，<em>FImageOnClicked ImageOnClick</em>就是用来声明该委托。</li><li>在构造中,通过InArgs._*可以来获取SLATE_BEGIN_ARGS(SMyHUDWidget)和SLATE_END_ARGS()之间的属性。</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/void SMyImage::Construct(const FArguments&amp; InArgs){    ImageOnClick = InArgs._ImageOnClicked;    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}</code></pre><ul><li>这样我们就可以重写鼠标事件，让其在点击时调用相关委托</li></ul><pre><code class="lang-cpp">FReply SMyImage::OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = true;    return FReply::Handled();}FReply SMyImage::OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    if (BIsMouseButtonDown == true)    {        BIsMouseButtonDown = false;        ImageOnClick.Execute();    }    return FReply::Handled();}void SMyImage::OnMouseLeave(const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = false;}</code></pre><ul><li>到此就完成了，点击图片时会显示<strong>SUCCEESS</strong><br><img src="Success.png" alt><blockquote><p>如果不成功可以尝试将播放模式设成模拟<br><img src="Simulation.png" alt></p></blockquote></li></ul><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/CG/UE4/Old/SlateWidget/"/>
      <url>/2019/08/04/CG/UE4/Old/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="lang-cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="lang-cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/CG/UE4/Old/WidgetStyle/"/>
      <url>/2019/08/03/CG/UE4/Old/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="lang-cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="lang-cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="lang-cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="lang-cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="lang-cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="lang-cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/CG/UE4/Old/HUD/"/>
      <url>/2019/08/02/CG/UE4/Old/HUD/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li><li>设置光标的相关属性</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="lang-cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="lang-cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="lang-cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将控件从视口删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将视口中的全部控件删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="设置光标"><a href="#设置光标" class="headerlink" title="设置光标"></a>设置光标</h1><ul><li>这里光标是默认的，我们需要让光标一直显示，不然对后面会有影像。</li><li>我们创建继承于PlayerController的MyController类。</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/AMyController::AMyController(){    /** Whether the mouse cursor should be displayed. */    bShowMouseCursor = true;}</code></pre><ul><li>我们还可以设置光标的移动范围</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/void AMyController::BeginPlay(){    /** Data structure used to setup an input mode that allows only the UI to respond to user input. */    FInputModeUIOnly InputMode;    /** Sets the mouse locking behavior of the viewport */    InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::LockAlways);    SetInputMode(InputMode);}</code></pre><ul><li>在Gamemode中应用，这样光标一直显示，且不能移出视口</li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;#include &quot;Public\MyController.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();    PlayerControllerClass = AMyController::StaticClass();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码</p><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/Algorithm/KMP/"/>
      <url>/2019/08/01/Algorithm/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p><p>3) 求当next数组当前位置<strong>j</strong></p><pre><code class="lang-cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>1) next[1]=0</p><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p><p>规则2：右移一位，最左边添-1，最右边自然溢出</p><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
