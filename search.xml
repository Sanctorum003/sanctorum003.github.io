<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/DelegateAndMacro/"/>
      <url>/2019/08/06/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p></blockquote><blockquote><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li><p>事件原型</p><pre><code class="cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li><p>FReply 告诉引擎如何处理事件</p><blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li><p>FReply::Handled() 告诉引擎事件处理完</p><blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p><pre><code class="cpp">/** SMyHUDWidget.h **/public:  //注意SOverlay::FOverlaySlot 是内部类  SOverlay::FOverlaySlot* MySlot;</code></pre></li></ul><pre><code class="cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/SlateWidget/"/>
      <url>/2019/08/04/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/WidgetStyle/"/>
      <url>/2019/08/03/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener"> 虚幻4之Slate学习三 —— 创建Slate控件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/HUD/"/>
      <url>/2019/08/02/HUD/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&_bid=167&_wv=3&ADUIN=1076613110&ADSESSION=1556776713&ADTAG=CLIENT.QQ.5611_.0&ADPUBNO=26886&taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(      MyWidgetPtr.ToSharedRef()      ));</code></pre></li><li>将控件从视口删除<pre><code class="cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef())); </code></pre></li><li>将视口中的全部控件删除<pre><code class="cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码</p><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— WidgetStyle</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/KMP/"/>
      <url>/2019/08/01/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p></blockquote><blockquote><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p></blockquote><blockquote><p>3) 求当next数组当前位置<strong>j</strong></p></blockquote><pre><code class="cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><blockquote><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p></blockquote><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><blockquote><p>1) next[1]=0</p></blockquote><blockquote><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p></blockquote><blockquote><p>规则2：右移一位，最左边添-1，最右边自然溢出</p></blockquote><blockquote><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
