<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++复习 Assert</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20Assert/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20Assert/</url>
      
        <content type="html"><![CDATA[<h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><ul><li>由预处理器管理，可以直接使用</li></ul><blockquote><p>无需std或using声明</p></blockquote><h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><ul><li>NDEBUG可以决定assert是否启用。但是注意要定义在assert声明之前。具体看以下连接</li></ul><blockquote><p><a href="https://www.zhihu.com/question/23075111" target="_blank" rel="noopener">https://www.zhihu.com/question/23075111</a></p></blockquote><ul><li>一些局部静态变量，可以用于调试<br><img src="局部静态变量.png" alt>P</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 inline内联函数</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile-ˈvɑː-lə-t̬əl"><a href="#volatile-ˈvɑː-lə-t̬əl" class="headerlink" title="volatile[ /ˈvɑː.lə.t̬əl/]"></a>volatile[ /ˈvɑː.lə.t̬əl/]</h1><pre><code class="lang-cpp">volatile int i = 10;</code></pre><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p><blockquote><p>volatile跟const类似可以跟指针，引用等组合</p></blockquote></li></ul><blockquote><p>带有volatile的成员函数只能被volatile的对象调用。</p></blockquote><ul><li>合成的拷贝对volatile对象无效<blockquote><p>如果没有定义复制构造函数，编译器会自动合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数会对成员逐个进行初始化，将新对象初始化为原对象的副本。</p></blockquote></li></ul><blockquote><p>合成的成员接受的形参类型是常量（非 volatile）引用，以此不能把一个非volatile引用绑定到一个volatile，因此需要自定义。</p></blockquote><pre><code class="lang-cpp">class Foo{public:    //从一个volatile对象进行拷贝    Foo(const volatile Foo&amp;);    //将一个volatile对象赋值给一个*非*Volatile对象    Foo&amp; operator=(volatile const Foo&amp;);    //将一个volatile对象赋值给一个volatile对象    //这个没问题volatile表示这个函数只能被volatile对象调用，而这是个符号重载，所以左值一定是volatile类型    Foo&amp; operator=(volatile const Foo&amp;) volatile;    //Foo类的其他部分//}</code></pre><ul><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">谈谈 C/C++ 中的 volatile</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 inline内联函数</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Inline/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Inline/</url>
      
        <content type="html"><![CDATA[<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>相当于把内联函数里面的内容写在调用内联函数处；//?</li><li>相当于不用执行进入函数的步骤，直接执行函数体；<blockquote><p>函数调用的时候，会在虚存中的栈区当前地址记录到帧指针寄存器，并生成该函数的上下文内容并执行相应的操作，调用结束后还会弹出该函数的数据，清理上下文信息。 </p></blockquote></li></ul><blockquote><p>感觉记得不准确，到时候重新看一下计算机系统中的函数调用过程</p><ul><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>inline 使用</p><pre><code class="lang-cpp">// 内联的声明可以不加inline// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) {/****/};// 类内定义，隐式内联class A {    int doA() { return 0; }         // 隐式内联}// 类外定义，需要显式内联class A {    int doA();}inline int A::doA() { return 0; }   // 需要显式内联</code></pre><h2 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h2><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h2><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>虚函数内联使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  using namespace std;class Base{public:    inline virtual void who()    {        cout &lt;&lt; &quot;I am Base\n&quot;;    }    virtual ~Base() {}};class Derived : public Base{public:    inline void who()  // 不写inline时隐式内联    {        cout &lt;&lt; &quot;I am Derived\n&quot;;    }};int main(){    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.who();    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr = new Derived();    ptr-&gt;who();    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr = nullptr;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 this指针</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h1><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针： //??<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 Static</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p></li></ul><blockquote><p>既可以是public也是private</p></blockquote><ul><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ul><blockquote><p>类的静态成员函数不包括this指针,所以静态成员函数不能设置为const</p><p><a href="https://blog.csdn.net/u010476094/article/details/38959265" target="_blank" rel="noopener">C++静态成员函数不能声明为const、volatile、virtual的原因 与 C++的对象模型</a></p></blockquote><ul><li>在类外定义静态成员，不用再重复声明static关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 Const</title>
      <link href="/2021/04/08/C++/C++%E5%A4%8D%E4%B9%A0%20Const/"/>
      <url>/2021/04/08/C++/C++%E5%A4%8D%E4%B9%A0%20Const/</url>
      
        <content type="html"><![CDATA[<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><ul><li>定义：<font color="red">const用于定义一个变量，它的值不能被改变</font></li></ul><h2 id="const对象必须初始化"><a href="#const对象必须初始化" class="headerlink" title="const对象必须初始化"></a>const对象必须初始化</h2><ul><li><p>然而并不是所有的const对象都必须初始化</p></li><li><p>顶层const必须初始化，因为本身不能改变，不初始化根本没法用。而底层const(常量指针)可以不初始化</p><blockquote><p>参考:<a href="https://blog.csdn.net/qq_21034239/article/details/70492318" target="_blank" rel="noopener">https://blog.csdn.net/qq_21034239/article/details/70492318</a></p></blockquote></li><li><p>其实没有那么简单,const对象必须初始化值对bulit-in类型和POD类行有效</p><ul><li>built-in类型是内置类型包括算术类型和空类型(void)</li><li>注意的是指针和引用是符合类型<blockquote><p>参考:<a href="https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away" target="_blank" rel="noopener">https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away</a><br>(翻译:<a href="https://www.it1352.com/465052.html" target="_blank" rel="noopener">https://www.it1352.com/465052.html</a>)</p></blockquote></li></ul></li></ul><h2 id="const对象仅对当前文件有效"><a href="#const对象仅对当前文件有效" class="headerlink" title="const对象仅对当前文件有效"></a>const对象仅对当前文件有效</h2><ul><li><p>在编译时会进行预处理，将代码中所有带const限定符的变量用初始化的常亮替代。</p></li><li><p>const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同在不同文件中分别定义了独立的变量。</p></li><li><p>如果要在多个文件中共享const对象，在需要声明变量的时候前面加extern</p></li></ul><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ul><li>用于声明<ul><li>变量只能被定义一次，但可以被多次声明。</li></ul></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><a href="./">C/C++程序编译链接过程(还没写)</a></li></ul><h2 id="对const的引用"><a href="#对const的引用" class="headerlink" title="对const的引用"></a>对const的引用</h2><ul><li><p>别称<font color="red">常量引用</font></p></li><li><p>常量引用可以引用常量和非常量</p></li><li>非常量引用不能引用常量</li></ul><pre><code class="lang-cpp">const int a = 1;int d = 1;const int &amp;b = a;//trueconst int &amp;c = 1;//trueconst int &amp;d = d;//trueint &amp;e = a;//false;</code></pre><ul><li><font color="red">初始化常量引用的时候可以使用任意类型和任意表达式，只要可以转换成相应的引用类型。</font><blockquote><p>原因：因为在常量引用绑定初始值的时候，生成了一个临时变量。其事实上绑定的是临时变量。</p></blockquote></li></ul><blockquote><p>这样保证了const int&amp;绑定的是int型的表达式</p><p>还有值得注意的是一般情况下引用的类型必须与其所引用的对象的类型一致</p></blockquote><pre><code class="lang-cpp">double dval = 3.14;const int &amp;ri = dval;</code></pre><p>等价于</p><pre><code class="lang-cpp">double dval = 3.14;const int temp = dval;const int &amp;ri = temp;</code></pre><ul><li>根据上述也可以解释为什么非常量引用不能引用常量，因为这样初始化绑定的是临时量。<blockquote><p>非const变量引用const量，其实绑定了中间变量temp，因为是非const量所以可以改变这非const量，按引用来const量也应该改变，但其实改变的是中间量temp，const量不变，产生矛盾，c++把这种行为定义为非法。</p></blockquote></li></ul><h3 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h3><ul><li>const只约束当前绑定的对象的相关操作，而不管对象本身是不是常量。</li></ul><pre><code class="lang-cpp">int a  = 1;int &amp;b = a;const int &amp;c = a;b = 2;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2a = 3cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2c = 4cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;// error: assignment of read-only reference ‘c’</code></pre><h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><blockquote><p>对于指针常量和常量指针的定义C++ primer里定义的跟大多数教材不一样</p><h3 id="指针常量-pointer-to-const"><a href="#指针常量-pointer-to-const" class="headerlink" title="指针常量(pointer to const)"></a>指针常量(pointer to const)</h3><ul><li>从右往左读，它是一个指针，是一个指向常量类型的指针。说明不能改变他所指向对象的内容。但是可以改变它指向的对象。</li></ul></blockquote><pre><code class="lang-cpp">const int a = 1;const int b = 2;const int *c = &amp;a;*c = 1;//faslec = &amp;b;//true</code></pre><h3 id="常量指针-const-pointer"><a href="#常量指针-const-pointer" class="headerlink" title="常量指针(const pointer)"></a>常量指针(const pointer)</h3><ul><li>从右往左读，它是一个常量，说明指针的地址不能改变。但是可以改变它指向对象的内容。</li></ul><pre><code class="lang-cpp">int a = 1;int b = 2;int *const c = &amp;a; c= &amp;b;//falsec= 2;//true</code></pre><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><ul><li>顶层const说明指针本身是个常量-常量指针(const pointer)</li><li>底层const说明指针指向的对象是个常量-指针常量(pointer to const)</li></ul><h3 id="const对拷贝的影响"><a href="#const对拷贝的影响" class="headerlink" title="const对拷贝的影响"></a>const对拷贝的影响</h3><ul><li>顶层const对拷贝无影响</li><li>底层const对拷贝有影像<blockquote><p>拷贝两者有相同的底层const的，或者被拷贝数据可以从非常量转变为常量,才无影响</p></blockquote></li></ul><pre><code class="lang-cpp">int main(){   // 顶层const对拷贝无影响    {        // const int -&gt; int  yes        const int b = 1;        int a = b;        // int -&gt; const int yes        int c = 1;        const int d = c;    }     // &amp;int(int*) -&gt; int *const/const int*/const int *const    int a = 1;    int *const b = &amp;a; //ok    const int *c = &amp;a; //ok    const int *const d = &amp;a; //ok    // &amp;(const int) -&gt; int *const/const int*/const int *const    const int e = 1;    int *const f = &amp;e; //error 没有相同的底层const    const int *g = &amp;e; //ok    const int *const h = &amp;e; //ok  &amp;e可以转换成const int *const    //(int cont*) -&gt; int *const/const int*/const int *const    int i = 1;    int *const  j= &amp;i;    int *const  k = j; //ok    const int*  l = j; //ok    const int *const m = j; //ok    return 0;}</code></pre><ul><li>总结(我自己有点绕晕了,总结一下)<blockquote><p>1) 对于非指针类型之间的拷贝,没有限制 const int &lt;-&gt; int</p></blockquote></li></ul><blockquote><p>2) 对于指针之间的拷贝。右值没有底层const,总合法;右值有底层const,则看左值有没有底层const,有则合法,没有则不合法。   </p><ul><li>常量对象不能赋值给非常量引用,常量对象不能赋值给非常量指针</li></ul><p>3) 对于指针和非指针之间，类型不同不合法;</p></blockquote><h2 id="constexpr和常量表达式-c-11"><a href="#constexpr和常量表达式-c-11" class="headerlink" title="constexpr和常量表达式[c++11]"></a>constexpr和常量表达式[c++11]</h2><ul><li>常量表达式(const expression)是指不会改变并且在编译过程就能得到计算结果的表达式<blockquote><p>数据类型是常量并且初始值是常量或字面值或两者混合的是常量表达式。</p></blockquote></li></ul><pre><code class="lang-cpp">const int a = 1; //trueconst int b = a+1; //trueint c = 1; //falseconst int d = get_d(); //false，该值在编译时才能获得，所以不是常量表达式</code></pre><h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><ul><li>constexpr定义的变量必须要用常量表达式初始化</li><li>constexpr是顶层const，即其本身为常量</li><li>对于字面量<blockquote><p>算术类型，引用和指针，字面值常量类，枚举都是字面值<br>自定义类，IO库，string类等不算字面值</p></blockquote></li></ul><h3 id="constexpr-指针"><a href="#constexpr-指针" class="headerlink" title="constexpr 指针"></a>constexpr 指针</h3><ul><li>constexpr指针只能指向地址固定的变量，比如全局变量，staitc变量</li></ul><pre><code class="lang-cpp">constexpr int *p1; //顶层constconst int *p2;  //底层constint *const p3;  //顶层constconstexpr const int *p4;//&lt;=&gt;const int *const p5;</code></pre><h2 id="const补充"><a href="#const补充" class="headerlink" title="const补充"></a>const补充</h2><p><a href="https://interview.huihut.com/#/?id=cc" target="_blank" rel="noopener">const 使用</a></p><pre><code class="lang-cpp">// 类class A{private:    const int a;                // 常对象成员，只能在初始化列表赋值public:    // 构造函数    A() : a(0) { };    A(int x) : a(x) { };        // 初始化列表    // const可用于对重载函数的区分    int getValue();             // 普通成员函数    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值};void function(){    // 对象    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量    const A a;                  // 常对象，只能调用常成员函数    const A *p = &amp;a;            // 指针变量，指向常对象    const A &amp;q = a;             // 指向常对象的引用    // 指针    char greeting[] = &quot;Hello&quot;;    char* p1 = greeting;                // 指针变量，指向字符数组变量    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量}// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char* Var);         // 参数指针所指内容为常量void function3(char* const Var);         // 参数指针为常量void function4(const int&amp; Var);          // 引用参数在函数内为常量// 函数返回值const int function5();      // 返回一个常数const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++重点复习及自我总结</title>
      <link href="/2021/03/01/Recruitment/C++%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
      <url>/2021/03/01/Recruitment/C++%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 11.旋转数组的最小数字</title>
      <link href="/2021/03/01/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2021/03/01/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </li></ul><blockquote><p>输入：[3,4,5,1,2]<br>输出：1</p><p>输入：[2,2,2,0,1]<br>输出：0</p></blockquote><h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><ul><li>时间复杂度:O(N)</li><li>空间复杂度:o(1)</li></ul><h1 id="方法二：二分"><a href="#方法二：二分" class="headerlink" title="方法二：二分"></a>方法二：二分</h1>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer刷题笔记"><a href="#剑指Offer刷题笔记" class="headerlink" title="剑指Offer刷题笔记"></a>剑指Offer刷题笔记</h1><ul><li>2021年2月末，为准备研三的秋招，开始算法题的康复运动<blockquote><p>(“&hearts;” 表示刷的时候做出了最优解)</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>#</th><th>Title</th><th>Solution</th><th>Tag</th><th>Difficulty</th><th>最优时间复杂度&amp;&amp;空间复杂度</th><th>最优解</th></tr></thead><tbody><tr><td>剑指 Offer 03</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></td><td><a href="https://sanctorum003.github.io/2021/02/26/LeetCode/[%E5%89%91%E6%8C%87Offer]%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>数组 &amp;&amp; 哈希表</td><td>Easy</td><td>O(N) &amp;&amp; O(1)</td><td></td></tr><tr><td>剑指 Offer 09</td><td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></td><td><a href="https://sanctorum003.github.io/2021/02/28/LeetCode/[%E5%89%91%E6%8C%87Offer]%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">C++</a></td><td>栈 &amp;&amp; 设计</td><td>Hard</td><td></td><td></td></tr><tr><td>剑指 Offer 11</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></td><td><a href="https://sanctorum003.github.io/2021/03/01/LeetCode/[%E5%89%91%E6%8C%87Offer]%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>二分查找</td><td>Easy(Hard)</td><td>O(lgN) &amp;&amp; O(1)</td><td></td></tr><tr><td>303</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Easy</td><td>建立O(N) &amp; 调用O(1)</td><td></td></tr><tr><td>304</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">二维区域和检索 - 矩阵不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td>&hearts;</td></tr><tr><td>338</td><td><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特网计数</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td></td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a></td><td><a href>c++</a></td><td>Medium</td><td>DP &amp;&amp; 二分</td><td>O(NlogN) &amp;&amp; O(N)</td><td></td></tr><tr><td>354</td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">俄罗斯套娃信封问题</a></td><td><a href>c++</a></td><td>Hard</td><td>DP &amp;&amp; 二分</td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 09.用两个栈实现队列</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 06.从尾到头打印链表</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><h1 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h1><ul><li>正序输出 + 翻转数组</li></ul><h1 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h1><ul><li>正序输入栈 + 从栈输入Vector</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><pre><code class="lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head) {        if(!head) return {};        vector&lt;int&gt; t = reversePrint(head-&gt;next);        t.push_back(head-&gt;val);        return t;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 07.重建二叉树</title>
      <link href="/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></li></ul><h1 id="分治（不带index辅助）"><a href="#分治（不带index辅助）" class="headerlink" title="分治（不带index辅助）"></a>分治（不带index辅助）</h1><ul><li><p>这个自己写的，空间复杂度较高</p><pre><code class="lang-cpp">/*** Definition for a binary tree node.* struct TreeNode {*     int val;*     TreeNode *left;*     TreeNode *right;*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}* };*/class Solution {public:  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {      if(preorder.empty() || inorder.empty()) return NULL;      //1. find root                              3      //2. split into left &amp; right                9 | 3 | 15 20 7      //3. 分治      int rootVal = preorder[0];      TreeNode* root = new TreeNode(rootVal);      vector&lt;int&gt;::iterator inorderRootPos;      inorderRootPos = find(inorder.begin(),inorder.end(),rootVal);      vector&lt;int&gt; inorderLeft(inorder.begin(),inorderRootPos);//注意范围      vector&lt;int&gt; inorderRight(inorderRootPos+1,inorder.end());      // //  inorder  L ROOT R      // //  preorder Root L R      int leftElemtNum = inorderRootPos-inorder.begin();      vector&lt;int&gt; preorderLeft(preorder.begin()+1,preorder.begin()+leftElemtNum+1);      vector&lt;int&gt; preorderRight(preorder.begin()+leftElemtNum+1,preorder.end());      TreeNode* LeftChild = buildTree(preorderLeft,inorderLeft);      TreeNode* RightChild = buildTree(preorderRight,inorderRight);      root-&gt;left = LeftChild;      root-&gt;right = RightChild;      return root;  }};</code></pre></li><li>时间复杂度:O(N)</li><li>空间复杂度:O(N+h)=O(N) [h为构造的树的高度,这里还有多次的创建数组的空间]</li></ul><h1 id="分治（利用index优化空间复杂度）"><a href="#分治（利用index优化空间复杂度）" class="headerlink" title="分治（利用index优化空间复杂度）"></a>分治（利用index优化空间复杂度）</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Tree </tag>
            
            <tag> Divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 05.替换空格</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2005.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2005.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a></li></ul><h1 id="建立新字符串"><a href="#建立新字符串" class="headerlink" title="建立新字符串"></a>建立新字符串</h1><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(n)</li></ul><h1 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h1><ul><li>利用string::resize()</li></ul><pre><code class="lang-cpp">class Solution {public:    string replaceSpace(string s) {        int len = s.size();        int cnt = 0;        for(const auto&amp; e : s)        {            if(e == &#39; &#39;)                cnt++;        }        s.resize(len+cnt*2);        int i = len-1;        int j = s.size()-1;        while(i &lt; j)        {            if(s[i] != &#39; &#39;)                s[j--] = s[i--];            else            {                s[j--] = &#39;0&#39;;                s[j--] = &#39;2&#39;;                s[j--] = &#39;%&#39;;                i--;            }        }        return s;    }};</code></pre><ul><li>时间复杂度:O(2n)</li><li>空间复杂度:O(t)[t为s中字符的数量]</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 双指针 </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 04.二维数组中的查找</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2004.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2004.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></li></ul><h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><ul><li>时间复杂度:O(MN)</li><li>空间复杂度:O(1)</li></ul><h1 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h1><ul><li>解题思路推荐看这个:<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</a></li></ul><pre><code class="lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {        int i = matrix.size()-1,j = 0;        while(i &gt;= 0 &amp;&amp; j&lt; matrix[0].size())        {            if(matrix[i][j] &gt; target)                i--;            else if(matrix[i][j] &lt; target)                j++;            else                 return true;        }        return false;    }};</code></pre><ul><li>时间复杂度:O(m+n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 03.数组中重复的数字</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></li></ul><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><pre><code class="lang-cpp">class Solution {public:    int findRepeatNumber(vector&lt;int&gt;&amp; nums) {        map&lt;int,int&gt; m;        for(const auto&amp; n : nums)        {            if(m[n] == 0) m[n]++;            else return n;        }        return -1;    }};</code></pre><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h1 id="方法二：原地置换"><a href="#方法二：原地置换" class="headerlink" title="方法二：原地置换"></a>方法二：原地置换</h1><pre><code class="lang-cpp">class Solution {public:    void swap(int&amp; a,int&amp; b)    {        a = a^b;        b = a^b;        a = a^b;    }    int findRepeatNumber(vector&lt;int&gt;&amp; nums) {        int i = 0;        while(i &lt; nums.size())        {             if(i != nums[i])            {                if(nums[i] == nums[nums[i]]) return nums[i];                   swap(nums[i],nums[nums[i]]);            }            else                ++i;        }        return -1;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> HashMap </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集总结</title>
      <link href="/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h1><pre><code class="lang-cpp">const int N=30005;int fa[N],s[N],h[N];void Init(int n){    for(int i=1;i&lt;=n;++i)        fa[i]=i,ran[i]=0;    //刚开始每个人都是自己的老大，每个人都没有手下}int Find(int x){    return x==fa[x]?x:fa[x]=Find(fa[x]);}void Merge(int x,int y){    int fx=Find(x);    int fy=Find(y);    if(fx==fy)  return;    if(ran[fx]&lt;ran[fy])        fa[fx]=fy;    else    {        fa[fy]=fx;        if(ran[fx]==ran[fy])            ran[fx]++;    }}</code></pre><ul><li>模板引用来源:<a href="https://www.cnblogs.com/StungYep/p/12254027.html" target="_blank" rel="noopener">https://www.cnblogs.com/StungYep/p/12254027.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5.最长回文子串</title>
      <link href="/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的关键点：初始条件和状态转换方程。<br>设：s[l][r]表示字符串中下标L到R的位置<br>则有如下转态转换方程<br>    s[l][r] = s[l+1][r-1] &amp;&amp; (s[l] == s[r])<br>那初始状态呢<br>    s[l][l] = ture<br>    s[l][l+1] = (s[l] == s[l+1])</p><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        vector&lt;vector&lt;bool&gt;&gt; v(s.size(),vector&lt;bool&gt;(s.size(),false));        string res;        for(int i = 0; i &lt; v.size();++i)        {            for(int j = i; j &lt; v.size();++j)            {                if(i == j)                    v[i][j] = true;                else if(j-i == 1)                    v[i][j] = s[i] == s[j] ? true : false;            }        }        //这里需要注意一点的是从后往前遍历，因为v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);会优先用到数组尾部的数据        for(int i = v.size()-1; i &gt;= 0;--i)        {            for(int j = i; j &lt; v.size();++j)            {                if(j-i &gt; 1)                    v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);                if(v[i][j] == true &amp;&amp; j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);              }        }        return res;    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3.无重复字符的最长子串</title>
      <link href="/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_longest-substring-without-repeating-characters.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>子串和子序列的区别<ul><li>子串是是连续的</li><li>子序列可以不是连续的<ul><li>比如”pwwkew”中,”pwke”是最长子序列,”wke”是最长子串</li></ul></li></ul></li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>通过两个指针$i$,$j$，维护一个区间，保证这个区间的子串中无重复元素。</li><li>每次迭代的时候$j$向后移动，判断当前j指针的元素在上一次迭代的区间中是否存在。<ul><li>不存在，$i$不动</li><li>存在，$i = find_pos(nums[j]) + 1$</li></ul></li><li>每次迭代时更新最长无重复的子串长度。</li></ul><p>对于在元素中查询方式有以下三种方法。</p><h3 id="朴素循环"><a href="#朴素循环" class="headerlink" title="朴素循环"></a>朴素循环</h3><ul><li><p>在判断是否有重复元素时遍历一遍区间内的元素</p><pre><code class="lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {      if(s.size() == 0)  return 0;      int i = 0;      int j = 0;      int res = 0;      do      {          for(int k =  i; k &lt;j ; ++k)          {              if(s[k] == s[j])              {                  i = k+1;                  break;              }          }          res = max(res,j-i+1);           ++j;      }while(i &lt; s.size() &amp;&amp; j &lt; s.size());      return res;  }};</code></pre></li><li>时间复杂度:$O(n^{2})$</li><li>空间复杂度:$O(1)$</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="eg.png" alt></p><ul><li>这里需要注意判断元素所对应的下标是否还在当前滑动窗口范围内</li></ul><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        unordered_map&lt;char,int&gt; m;        int i =0;        int j = 0;        int res = 0;        do        {            if( m.find(s[j])!= m.end() &amp;&amp; m[s[j]] &gt;= i ) //这里主要要求找到的值要大于等于i            {                i = m[s[j]]+1;                m[s[j]] = j;            }            else             {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:unordered_map:O(n)</li><li>空间复杂度:O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        int m[128]; //利用ascii来存储下标        fill(m,m+128,-1);        int i =0;        int j = 0;        int res = 0;        do        {            if(m[s[j]] &gt;= i)  //这里主要要求找到的值要大于等于i            {                              i = m[s[j]] + 1;                m[s[j]] = j;            }            else            {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> DoublePointer </tag>
            
            <tag> String </tag>
            
            <tag> SlidingWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_two-sum.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>数组无序</li><li>返回<strong>下标</strong></li></ul></li></ul><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><ul><li><p>二重循环</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; v;      for(int i = 0; i &lt; nums.size();++i)          for(int j = i+1; j &lt; nums.size();++j)              if(nums[i] + nums[j] == target)              {                  v.push_back(i);                  v.push_back(j);              }      return v;  }};</code></pre></li><li><p>时间复杂度:O($n^{2}$)</p></li><li>空间复杂度 O(1)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>排序($nlog(n)$)之后使用双指针($O(n)$)找出所求的值</li><li>所求的是原数组中的下标，所以排序前复制一份。之后利用找到的值来找到下标</li><li><p>需要注意从原数组找下标时，下标大小和数值重复的问题。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; tmp = nums;      sort(tmp.begin(),tmp.end());      int i = 0;      int j = tmp.size()-1;      while(i &lt; j)      {          if(tmp[i] + tmp[j] &gt; target) --j;          else if(tmp[i] + tmp[j] &lt; target) ++i;          else break;      }      bool bi = false;      bool bj = false;      for(int k = 0; k &lt; nums.size();++k)      {          if(!bi &amp;&amp; nums[k] == tmp[i] )          {              i=k;              bi = true;              continue;          }          if(!bj &amp;&amp; nums[k] == tmp[j])          {              j = k;              bj = true;              continue;          }      }      if(i &gt; j)          swap(i,j);      return {i,j};  }};</code></pre></li><li><p>时间复杂度: $O(nlog(n) + n + n) = O(nlog(n))$</p></li><li>空间复杂度: $O(n)$</li></ul><h2 id="两遍哈希"><a href="#两遍哈希" class="headerlink" title="两遍哈希"></a>两遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。<ul><li>这里会注意到一点，可能数组中的值会重复，导致一个值关联多个下标，而实际代码中的结果会使得最后一个重复值关联相应下标。</li><li>但是这并不会影响结果。如此考虑，因为<strong>结果唯一</strong>，所以结果要取重复值，则数组中该结果对应的重复值有且仅有2个，不然不满足结果唯一。</li><li>所以在查找的时候，用的是原数组进行迭代，所以重复的第一个值要找的就是重复的后一个值，所以上述正好满足我们的要求</li></ul></li><li><p>利用原数组进行查找 target - nums[i] 是否在map中,map::find为O(log(n))，其基于红黑树。unordered_map::find()为O(1),其基于哈希表</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)          m[nums[i]] = i;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)              return {i,m[target-nums[i]]};      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(n)</li></ul><h2 id="一遍哈希"><a href="#一遍哈希" class="headerlink" title="一遍哈希"></a>一遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。</li><li><p>在这里直接循环原数组，查找map中否有target - nums[i]。没有的话加入map中。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end())          {              return {m[target-nums[i]],i};          }          else          {              m[nums[i]] = i;          }      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Marching</title>
      <link href="/2020/01/10/CG/Render/Render-RayMarching/"/>
      <url>/2020/01/10/CG/Render/Render-RayMarching/</url>
      
        <content type="html"><![CDATA[<p><img src="raytrace.png" alt="from &quot;Ray tracing&quot; on Wikipedia"></p><ul><li>Ray Marching和Ray Tracing有一些相似之处。看上图，可以看出来他们都说从摄像机的位置开始,遍历屏幕上的所有像素，通过从摄像机穿过像素的射线来计算出该点像素的颜色。</li><li>对于Ray Marching来说，通过使用SDF函数来判断是否碰撞到物体。SDF函数就是signed distance function，比如说对于球体。  </li></ul><script type="math/tex; mode=display">SDF(P)=||\vec{p}-\vec{c}||-r \left\{\begin{aligned}< & 0, 在球体内部 \\= & 0, 在球体边上 \\> & 0, 在球体外部\end{aligned}\right.</script><ul><li>上述就是一个球体的SDF函数,而求得的SDF函数的值就是点P到球体的最短距离。</li></ul><script type="math/tex; mode=display">p = eye + depth * raydirection</script><ul><li>对于测试点P的depth来说,增加SPF(p)的大小肯定是不会发生碰撞的。然后考虑到如果该射线最终能撞到物体,那么depth肯定是一个固定值,而如果不撞到其他物体的话,那么depth = + $\infty$。所以需要设置p的最小值(初试值),最大值(超过这个值认为没有hit),depth的最小值(小于这个值认为ray marching结束),ray marching步长(超过这个值认为ray marching结束)</li></ul><p><img src="spheretrace.jpg" alt="From GPU Gems 2: Chapter 8."></p><ul><li>可以拿上图举例,从点P0开始,计算场景中所有SDF的值,并取最小值,那么depth加上这个值肯定不会发生碰撞。</li></ul><script type="math/tex; mode=display">SDF(p) = min(SDF_{1}(p),SDF_{2}(p),...)</script><pre><code class="lang-cpp">//Shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){    float tp1 = CircleSDF(vec3(0,0,0),1.f,tp);    float tp2 = CircleSDF(vec3(1,1,0),1.f,tp);    return min(tp1,tp2);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    //因为屏幕的原点在中心,而fragCoord的原点在左上角，进行变换    dir.xy = fragCoord - size/2.f;    //通过fov来设置视野范围       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    //注意一定要标准化    return normalize(dir);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &lt; MAX_DIS - E)    {        fragColor = vec4(1,0.75,0.79,1.f);        return;    }      fragColor = vec4(0.f,0.f,0.f,1.f); }</code></pre><h1 id="表面法线"><a href="#表面法线" class="headerlink" title="表面法线"></a>表面法线</h1><ul><li>梯度的值 == 法线的值</li></ul><script type="math/tex; mode=display">∇f=( \frac{​∂f}{​∂x},\frac{​∂f}{​∂y},\frac{​∂f}{​∂z})</script><ul><li>上面的式子可以用下面的式子来近似<blockquote><p>But no need to break out the calculus chops here. Instead of taking the real derivative of the function, we’ll do an approximation by sampling points around the point on the surface, much like how you learned to calculate slope in a function as over rise-over-run before you learned how to do derivatives.</p></blockquote></li></ul><script type="math/tex; mode=display">\vec{n} = \left[ \begin{matrix}​f(x+ε,y,z)−f(x−ε,y,z) \\​f(x,y+ε,z)−f(x,y−ε,z) \\​f(x,y,z+ε)−f(x,y,z−ε) \\\end{matrix} \right]​​</script><pre><code class="lang-cpp">//shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){     return CircleSDF(vec3(0,0,0),1.f,tp);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    dir.xy = fragCoord - size/2.f;       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    return normalize(dir);}vec3 estimateNormal(vec3 p,float EPSILON) {    return normalize(vec3(        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))    ));}vec3 GetColor(vec3 p){    return estimateNormal(p,0.01f);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &gt; MAX_DIS - E)    {        fragColor = vec4(0.f,0.f,0.f,1.f);        return;    }    fragColor = vec4(GetColor(eye + depth * dir),1.f);}</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/" target="_blank" rel="noopener">http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a><br><a href="https://zhuanlan.zhihu.com/p/36759481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36759481</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-CoordinateSystems</title>
      <link href="/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/"/>
      <url>/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Transformations</title>
      <link href="/2019/12/04/CG/Opengl/LearnOpengl-Transformations/"/>
      <url>/2019/12/04/CG/Opengl/LearnOpengl-Transformations/</url>
      
        <content type="html"><![CDATA[<ul><li>单位向量 $\hat{n}$</li></ul><h1 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h1><ul><li>它允许我们在3D向量上进行位移</li><li>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ul><li>用于避免万向结死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Textures</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Textures/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Textures/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h1><ul><li><p>纹理坐标中,左下角位(0,0),右上角位(1,1)<br><img src="tex_coords.png" alt></p></li><li><p>使用纹理坐标获取纹理颜色叫做<strong>采样(Sampling)</strong></p></li></ul><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><ul><li>原文讲的够好了<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></li></ul><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><ul><li><p>产生原因:纹理坐标可以取任意浮点值，所以纹理元素与纹理坐标无法一一对应</p></li><li><p>纹理元素(Texel)</p></li></ul><blockquote><p>而纹素是纹理图片空间的基本单元，可以看成是纹理的组成“像素”</p></blockquote><ul><li>纹理过滤（Texture Filtering)</li></ul><blockquote><p>一个像素一般不会正好对应于一个纹元（texel)。所以像素的颜色无法直接得到，需要经过一定的运算，这个过程就是纹理过滤。<br>参考网址：<a href="https://zhuanlan.zhihu.com/p/91208143" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91208143</a></p></blockquote><ul><li>有两种常见的纹理过滤的方式:GL_NEAREST和GL_LINEAR</li></ul><blockquote><p>邻近过滤:选择中心点最接近纹理坐标的那个像素<br>线性过滤:基于纹理坐标附近的纹理像素，计算出一个插值。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。<br>具体项目可见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a>  </p></blockquote><ul><li>如何设置过滤方式</li></ul><pre><code class="lang-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><blockquote><p>GL_TEXTURE_MAG_FILTTER:纹理元素的数量 &lt; 图元像素的数量。比如texture为256*256，图元为512*512。相当于纹理元素被放大，一个纹理元素的颜色决定多个图元像素的颜色</p><p>GL_TEXTURE_MIN_FILTER 纹理元素的数量 &gt; 图元像素的数量。比如texture为512*512,图元为256*256。相当于纹理被缩小，一个图元像素的颜色由多个纹理像素决定。</p></blockquote><h1 id="多级渐远纹理-Mipmap"><a href="#多级渐远纹理-Mipmap" class="headerlink" title="多级渐远纹理(Mipmap)"></a>多级渐远纹理(Mipmap)</h1><ul><li><p>产生原因:我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段(像素)，OpenGL从高分辨率纹理中为这些片段（像素）获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段（像素）只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p></li><li><p>多级渐远纹理：简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一</p></li><li><p>距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 </p></li><li><p>Mipmap的例子如下<br><img src="mipmaps.png" alt></p></li><li><p>可以在GL_TEXTURE_MIN_FILTER中使用多级渐远纹理过滤选项，但是在GL_TEXTURE_MAG_FILTER中无法使用，纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p></li></ul><h1 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><pre><code class="lang-cpp">int width, height, nrChannels;//地址、宽度、高度、颜色通道的个数、期望通道数（得到的data中的数据的通道数目）unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</code></pre><h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><pre><code class="lang-cpp">unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    //用于生成2D纹理    // 参数一：设置纹理目标，一般为GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D    // 参数二：Mipmap级别,手动设置每个的话这里设0    // 参数三：纹理存储格式    // 参数四：宽度    // 参数五：长度    // 0    // 参数六：image的的存储格式    // 参数七：图像数据    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    //为当前绑定的纹理自动生成所有需要的多级渐远纹理。    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}//释放图像的内存stbi_image_free(data);</code></pre><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><ul><li>在定点数组中添加纹理坐标</li><li>在VS中声明纹理坐标属性</li><li>利用glVertexAttribPointer给定点数组中的纹理坐标解释，并启用该定点属性</li><li>在PS中获取VS中的纹理坐标，声明sampler2D变量</li><li>glActiveTexture激活对应的纹理单元</li><li>利用texture(ourTexture, TexCoord)使用之前设置的纹理参数对相应的颜色值进行采样</li></ul><h1 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h1><ul><li>uniform sampler2D MySampler存放纹理的位置称为纹理单元。</li><li>opengl有GL_TEXTURE0 - GL_TEXTURE15总共16个纹理单元。</li><li>使用方式如下</li></ul><pre><code class="lang-cpp">// 设置着色器采样器使用哪个纹理单元ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置</code></pre><pre><code class="lang-cpp">//激活纹理单元glActiveTexture(GL_TEXTURE0);//绑定时会自动使用当前激活的纹理单元 glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);</code></pre><ul><li>纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</li></ul><h1 id="图片翻转问题"><a href="#图片翻转问题" class="headerlink" title="图片翻转问题"></a>图片翻转问题</h1><ul><li>纹理可能上下颠倒，这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。</li></ul><pre><code class="lang-cpp">//解决方法stbi_set_flip_vertically_on_load(true);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Shaders</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Shaders/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Shaders/</url>
      
        <content type="html"><![CDATA[<ul><li><p>很多都是概念性的东西，教程里整理的很好<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1</a></p></li><li><p>layout (location = 0)</p><blockquote><p>为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。</p></blockquote></li><li><p>如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）</p></li></ul><h1 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h1><ul><li>uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</li><li>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4Live_RenderProcess</title>
      <link href="/2019/10/08/CG/UE4/UE4Live-RenderProcess/"/>
      <url>/2019/10/08/CG/UE4/UE4Live-RenderProcess/</url>
      
        <content type="html"><![CDATA[<p>视频地址 <a href="https://www.bilibili.com/video/av35615021?t=3626" target="_blank" rel="noopener">https://www.bilibili.com/video/av35615021?t=3626</a><br>相关图片 <a href="https://blog.csdn.net/jli_family/article/details/86584208" target="_blank" rel="noopener">https://blog.csdn.net/jli_family/article/details/86584208</a></p><p><img src="UE4Live_RenderProcess.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloTriangle</title>
      <link href="/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/"/>
      <url>/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/</url>
      
        <content type="html"><![CDATA[<ul><li><p>通过opengl绘制图形，需要通过opengl的渲染管线，这一过程实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p></li><li><p>对于利用opengl画出一个三角形，归纳为以下步骤</p></li></ul><h1 id="build-and-compile-our-shader-program"><a href="#build-and-compile-our-shader-program" class="headerlink" title="build and compile our shader program"></a>build and compile our shader program</h1><p><img src="Opengl_ShaderCreate.png" alt></p><ul><li>在OpenGL的渲染管线中，我们必须要配置VS和FS(PS)两个着色器,可以选择配置GS。</li></ul><pre><code class="lang-cpp">//创建着色器的方式/***  * 创建一个指定类型的着色器，返回指向这个着色器的在显存地址的引用***/int MyShader = glCreateShader(TYPE_OF_SHADER);</code></pre><ul><li>着色器程序运行的着色器语言，在opengl中使用的是GLSL。所以我们需要编写GLSL,并且将其绑定到我们创建的着色器上</li></ul><pre><code class="lang-cpp">/***  * MyShaderSource中写入待绑定的GLSL程序***/const char *MyShaderSource = &quot;#version 330 core\n&quot;    &quot;out vec4 FragColor;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;    &quot;}\n\0&quot;;/***  * 将GLSL程序与Shader进行绑定  * Shader显存地址/程序数量/字符串(数组)/字符串数组长度***/glShaderSource(MyShader, 1, &amp;MyShaderSource, NULL);</code></pre><ul><li>进行着色器编译并显示Debug信息</li></ul><pre><code class="lang-cpp">glCompileShader(vertexShader);// check for shader compile errorsint success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success){    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}</code></pre><ul><li>到这里我们的着色器就编译好了，接下来我们需要将编译好的着色器链接成一个着色器对象。这个着色器对象就是我们将数据渲染到屏幕所使用的的渲染管线。</li></ul><pre><code class="lang-cpp">unsigned int shaderProgram;shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) {    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGTRAM::LINK_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}/***  * 在之后可以调用glUseProgram(shaderProgram)来使用这个我们已经链接好的着色器程序对象。***///别忘了垃圾回收，这两个这时候已经没用了glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h1 id="set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes"><a href="#set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes" class="headerlink" title="set up vertex data (and buffer(s)) and configure vertex attributes"></a>set up vertex data (and buffer(s)) and configure vertex attributes</h1><ul><li>我们要画图形的话，需要几样的东西，首先是需要在内存中准备顶点，然后传输到显存中。</li></ul><h2 id="VBO-vertex-buffer-objects-顶点缓冲对象"><a href="#VBO-vertex-buffer-objects-顶点缓冲对象" class="headerlink" title="VBO(vertex buffer objects):顶点缓冲对象"></a>VBO(vertex buffer objects):顶点缓冲对象</h2><pre><code class="lang-cpp">unsigned int VBO;//这里用&amp;，是因为直接改变VBO指向内存单元的数据，执行完后VBO保存一个显存地址glGenBuffers(1, &amp;VBO);//这一步将显存地址与GL_ARRAY_BUFFER绑定，这样之后所有对GL_ARRAY_BUFFER，其实就是在操作VBO所指的显存区域。glBindBuffer(GL_ARRAY_BUFFER, VBO);//这一步是用于将内存中的数据传输到显存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><ul><li>上述代码用于创建一个叫做VBO缓冲对象的东西，这个用于存储将来从内存传输过来的定点数据。</li></ul><h2 id="解释显存中的缓存数据"><a href="#解释显存中的缓存数据" class="headerlink" title="解释显存中的缓存数据"></a>解释显存中的缓存数据</h2><ul><li>在显存中的数据，我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。</li></ul><pre><code class="lang-cpp">//该函数用于让OpenGL知道该如何解析顶点数据//第一个参数表示该数据希望传输到VS的哪一个参数。比如//  layout (location = 0) in vec3 aPos;//  layout (location = 1) in vec3 bPos;//第一个参数设为0则该数据传入aPos,1则传入bPos//第二个参数表示该定点属性的大小，这里是3//第三个参数表示大小为3，每个部分的类型为float//第四个参数表示是否要标准化设备坐标(Normalized Device Coordinates, NDC)//第五个参数表示每个顶点属性的总大小,对于紧密排列的数据可以用0代替//第六感参数表示位置数据在缓冲中起始位置的偏移量(Offset)，比如sizeof(float)，则偏移一个float值，3*sizeof(float)，则偏移一个定点glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</code></pre><ul><li>接下来我们应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</li></ul><pre><code class="lang-cpp">glEnableVertexAttribArray(0);</code></pre><h2 id="VAO-Vertex-Array-Objec-顶点数组对象"><a href="#VAO-Vertex-Array-Objec-顶点数组对象" class="headerlink" title="VAO(Vertex Array Objec):顶点数组对象"></a>VAO(Vertex Array Objec):顶点数组对象</h2><ul><li>一个顶点数组对象会储存以下这些内容：<blockquote><p>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</p></blockquote></li></ul><blockquote><p>通过glVertexAttribPointer设置的顶点属性配置。</p><p>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</p></blockquote><ul><li>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</li><li>也就是说我们对VBO的所有配置都会保存在我们所绑定的VAO中，如果之后想要使用这一配置，只需要重新绑定它就行了。</li></ul><pre><code class="lang-cpp">//VAO绑定unsigned int VAO;glGenVertexArrays(1, &amp;VAO);glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO解绑glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO使用glBindVertexArray(VAO);</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code class="lang-cpp">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..// 1. bind Vertex Array ObjectglBindVertexArray(VAO);// 2. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. then set our vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);  //glBindVertexArray(0);...// ..:: Drawing code (in render loop) ::..// 4. draw the objectglUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();</code></pre><h1 id="render-loop"><a href="#render-loop" class="headerlink" title="render loop"></a>render loop</h1><ul><li>如何使用我们所自定义的着色器和配置好的定点属性呢?</li></ul><pre><code class="lang-cpp">// draw our first triangleglUseProgram(shaderProgram);glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organizedglDrawArrays(GL_TRIANGLES, 0, 3);// glBindVertexArray(0); // no need to unbind it every time</code></pre><ul><li>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象</li><li>在glBindVertexArray函数调用之后，会使用VAO中所保存的顶点数据配置</li><li>glDrawArray函数用于绘制图元，第一个函数是图元类型，第二个参数指定了顶点数组的起始索引，第三是顶点个数。绘制glVertexAttribPointer绑定后的第几个位置开始的几个定点。注意这里是定点的偏移，比如这里上下文中大小为 3*sizeof(float)</li><li>需要区分在glVertexAttribPointer中的offset和这里的索引</li></ul><h1 id="EBO-Element-Buffer-Object-引缓冲对象"><a href="#EBO-Element-Buffer-Object-引缓冲对象" class="headerlink" title="EBO(Element Buffer Object):引缓冲对象"></a>EBO(Element Buffer Object):引缓冲对象</h1><ul><li>用于指定定点的绘制顺序</li></ul><pre><code class="lang-cpp">unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</code></pre><pre><code class="lang-cpp">//这里改用这glDrawElements来画三角形glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><ul><li>注意VAO也会保存EBO的数组配置信息，glDrawElements会使用我们绑定的EBO中的索引顺序,所以要注意解绑VAO的顺序</li></ul><h1 id="绘制最终流程"><a href="#绘制最终流程" class="headerlink" title="绘制最终流程"></a>绘制最终流程</h1><pre><code class="lang-cpp">// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染编程 - 资源操作</title>
      <link href="/2019/10/07/CG/UE4/UE4Render-ResourceOperation/"/>
      <url>/2019/10/07/CG/UE4/UE4Render-ResourceOperation/</url>
      
        <content type="html"><![CDATA[<h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><ul><li>Compute Shader<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-</a><br><a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Compute_Shader</a></li></ul><h1 id="UAV"><a href="#UAV" class="headerlink" title="UAV"></a>UAV</h1><ul><li>Unordered Access view<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在shader文件中添加第二个颜色变量</title>
      <link href="/2019/10/06/CG/UE4/UE4Render-addParams/"/>
      <url>/2019/10/06/CG/UE4/UE4Render-addParams/</url>
      
        <content type="html"><![CDATA[<h1 id="在shader文件中添加第二个颜色变量"><a href="#在shader文件中添加第二个颜色变量" class="headerlink" title="在shader文件中添加第二个颜色变量"></a>在shader文件中添加第二个颜色变量</h1><p><a href="https://zhuanlan.zhihu.com/p/36635394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36635394</a><br><a href="https://zhuanlan.zhihu.com/p/36695496" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36695496</a><br>在看了shader编程的第二第三章后,觉的似懂非懂。再上面添加点东西,便于很深入的理解</p><h2 id="MyShader-usf"><a href="#MyShader-usf" class="headerlink" title="MyShader.usf"></a>MyShader.usf</h2><ul><li>我们从目标要求开始,这里我想要使得输出颜色变为两个颜色的和，比如可以让颜色变成R+G,R+B等等</li><li>这里我们现在usf文件中做如下添加和修改</li></ul><pre><code class="lang-cpp">// MyShader.usf#include &quot;/Engine/Public/Platform.ush&quot;float4 SimpleColor;// 增加一个颜色采样的变量float4 SimpleColor2;void MainVS( in float4 InPosition : ATTRIBUTE0, out float4 OutPosition : SV_POSITION ){ // screenspace position from vb    OutPosition = InPosition;}void MainPS(    out float4 OutColor : SV_Target0    ){    // 输出颜色变为两种颜色的叠加    OutColor = (SimpleColor + SimpleColor2);}</code></pre><h2 id="MyShaderTest-h"><a href="#MyShaderTest-h" class="headerlink" title="MyShaderTest.h"></a>MyShaderTest.h</h2><ul><li>因为添加了一个颜色变量，我们得将相关数据传进去。首先想到的是在蓝图中增加一个引脚</li></ul><pre><code class="lang-cpp">// MyShaderTest.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UObject/ObjectMacros.h&quot;#include &quot;Classes/Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;MyShaderTest.generated.h&quot;UCLASS(MinimalAPI, meta = (ScriptName = &quot;TestShaderLibrary&quot;))class UTestShaderBlueprintLibrary : public UBlueprintFunctionLibrary{    GENERATED_UCLASS_BODY()        UFUNCTION(BlueprintCallable, Category = &quot;ShaderTestPlugin&quot;, meta = (WorldContext = &quot;WorldContextObject&quot;))        // 在这里增加一个FLinearColor的形参就是增加一个引脚        static void DrawTestShaderRenderTarget(class UTextureRenderTarget2D* OutputRenderTarget, AActor* AC, FLinearColor MyColor,FLinearColor MyColor2);};</code></pre><h2 id="MyShaderTest-cpp"><a href="#MyShaderTest-cpp" class="headerlink" title="MyShaderTest.cpp"></a>MyShaderTest.cpp</h2><h3 id="DrawTestShaderRenderTarget"><a href="#DrawTestShaderRenderTarget" class="headerlink" title="DrawTestShaderRenderTarget"></a>DrawTestShaderRenderTarget</h3><ul><li>为此我们需要进入cpp文件中,添加相应的形参。这个函数是在逻辑线程中调用。</li><li>ENQUEUE_RENDER_COMMAND向渲染线程压入一个渲染命令， 调用DrawTestShaderRenderTarget_RenderThread</li><li>我们需要在lambda表达式中增加我们需要传的变量给渲染线程。<blockquote><p>DrawTestShaderRenderTarget中主要是对数据的获取和传递,一般不需要修改东西，只需要增加你要传递的各类数据。</p></blockquote></li></ul><pre><code class="lang-cpp">// MyShaderTest.cppvoid UTestShaderBlueprintLibrary::DrawTestShaderRenderTarget(    UTextureRenderTarget2D* OutputRenderTarget,    AActor* Ac,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInGameThread());    if (!OutputRenderTarget)    {        return;    }    FTextureRenderTargetResource* TextureRenderTargetResource = OutputRenderTarget-&gt;GameThread_GetRenderTargetResource();    UWorld* World = Ac-&gt;GetWorld();    ERHIFeatureLevel::Type FeatureLevel = World-&gt;Scene-&gt;GetFeatureLevel();    FName TextureRenderTargetName = OutputRenderTarget-&gt;GetFName();    ENQUEUE_RENDER_COMMAND(CaptureCommand)(        [TextureRenderTargetResource, FeatureLevel, MyColor,MyColor2, TextureRenderTargetName](FRHICommandListImmediate&amp; RHICmdList)    {        DrawTestShaderRenderTarget_RenderThread(RHICmdList, TextureRenderTargetResource, FeatureLevel, TextureRenderTargetName, MyColor,MyColor2);    }    );}</code></pre><h3 id="FMyShaderTest"><a href="#FMyShaderTest" class="headerlink" title="FMyShaderTest"></a>FMyShaderTest</h3><ul><li>因为给DrawTestShaderRenderTarget_RenderThread添加了一个数据，所以需要修改其函数，但是这个比较复杂我们先看简单的。</li><li>渲染管线中VS和PS是一定要自己配置的,所以创建自定义的VS和PS,需要从FGlobalShader继承。然后需要使用</li></ul><pre><code class="lang-cpp">IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><p>这个语句来使相关类和Vertex Shader或Pixel Shader文件绑定，这样渲染管线中将会使用我们自定义的定点着色器和像素着色器</p><ul><li>因为在VS和PS中有些配置是一样的,所以我们可以先从FGlobalShader派生一个FMyShaderTest的类,然后再从FMyShaderTest派生出我们的FShaderTestVS和FShaderTestPS。</li></ul><pre><code class="lang-cpp">// MyShaderTest.cppclass FMyShaderTest : public FGlobalShader{public:    FMyShaderTest() {}    FMyShaderTest(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FGlobalShader(Initializer)    {        SimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));        SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));    }    static bool ShouldCache(EShaderPlatform Platform)    {        return true;    }    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters)    {        //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);          return true;    }    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)    {        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);        OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);    }    void SetParameters(        FRHICommandListImmediate&amp; RHICmdList,        const FLinearColor &amp;MyColor,        const FLinearColor &amp;MyColor2    )    {        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);    }    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }private:    FShaderParameter SimpleColorVal;    FShaderParameter SimpleColorVal2;};</code></pre><p>其中</p><pre><code class="lang-cpp">// MyShaderTest.cppSimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));// MyShader.usffloat4 SimpleColor;float4 SimpleColor2;</code></pre><ul><li>这是将FMyShaderTest中的私有变量与MyShader.usf中变量进行绑定。</li><li><p>但是我们注意到我们还没有将颜色输入到FMyShaderTest中的私有变量。因此我们需要写一个函数用于把我们的颜色信息传到shader里。。</p><pre><code class="lang-cpp">// MyShaderTest.cppvoid SetParameters(  FRHICommandListImmediate&amp; RHICmdList,  const FLinearColor &amp;MyColor,  const FLinearColor &amp;MyColor2){  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);}</code></pre></li><li><p>因为这些参数在PS中使用到，所以此处使用GetPixelShader()参数</p></li></ul><pre><code class="lang-cpp">    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }</code></pre><ul><li>虚幻序列化，用于读取磁盘上的渲染数据，这里需要将我们所需要的SimpleColorVal，SimpleColorVal2;</li></ul><pre><code class="lang-cpp">static bool ShouldCache(EShaderPlatform Platform){    return true;}static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters){    //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);      return true;}static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment){    FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);    OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);}</code></pre><ul><li>剩下这些可以暂时不用管。<h3 id="VS-和-PS"><a href="#VS-和-PS" class="headerlink" title="VS 和 PS"></a>VS 和 PS</h3></li></ul><pre><code class="lang-cpp">class FShaderTestVS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestVS, Global);public:    FShaderTestVS() {}    FShaderTestVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};class FShaderTestPS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestPS, Global);public:    FShaderTestPS() {}    FShaderTestPS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><ul><li>这里从FMyShaderTest派生两个类分别利用IMPLEMENT_SHADER_TYPE宏指定为VS和PS</li></ul><pre><code class="lang-cpp">DECLARE_SHADER_TYPE(FShaderTestVS, Global);</code></pre><ul><li>该宏用于把该Shader加入全局shadermap中，在运行前会将shadermap中的所以shader进行编译。</li></ul><h3 id="DrawTestShaderRenderTarget-RenderThread"><a href="#DrawTestShaderRenderTarget-RenderThread" class="headerlink" title="DrawTestShaderRenderTarget_RenderThread"></a>DrawTestShaderRenderTarget_RenderThread</h3><pre><code class="lang-cpp">static void DrawTestShaderRenderTarget_RenderThread(    FRHICommandListImmediate&amp; RHICmdList,    FTextureRenderTargetResource* OutputRenderTargetResource,    ERHIFeatureLevel::Type FeatureLevel,    FName TextureRenderTargetName,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInRenderingThread());#if WANTS_DRAW_MESH_EVENTS      FString EventName;    TextureRenderTargetName.ToString(EventName);    SCOPED_DRAW_EVENTF(RHICmdList, SceneCapture, TEXT(&quot;ShaderTest %s&quot;), *EventName);#else      SCOPED_DRAW_EVENT(RHICmdList, DrawUVDisplacementToRenderTarget_RenderThread);#endif      //设置渲染目标      SetRenderTarget(        RHICmdList,        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        FTextureRHIRef(),        ESimpleRenderTargetMode::EUninitializedColorAndDepth,        FExclusiveDepthStencil::DepthNop_StencilNop    );    //设置视口      //FIntPoint DrawTargetResolution(OutputRenderTargetResource-&gt;GetSizeX(), OutputRenderTargetResource-&gt;GetSizeY());      //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      TShaderMap&lt;FGlobalShaderType&gt;* GlobalShaderMap = GetGlobalShaderMap(FeatureLevel);    TShaderMapRef&lt;FShaderTestVS&gt; VertexShader(GlobalShaderMap);    TShaderMapRef&lt;FShaderTestPS&gt; PixelShader(GlobalShaderMap);    // Set the graphic pipeline state.      FGraphicsPipelineStateInitializer GraphicsPSOInit;    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);    GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI();    GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI();    GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI();    GraphicsPSOInit.PrimitiveType = PT_TriangleList;    GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();    GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader);    GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader);    SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);    //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      PixelShader-&gt;SetParameters(RHICmdList, MyColor,MyColor2);    // Draw grid.      //uint32 PrimitiveCount = 2;      //RHICmdList.DrawPrimitive(PT_TriangleList, 0, PrimitiveCount, 1);      FVector4 Vertices[4];    Vertices[0].Set(-1.0f, 1.0f, 0, 1.0f);    Vertices[1].Set(1.0f, 1.0f, 0, 1.0f);    Vertices[2].Set(-1.0f, -1.0f, 0, 1.0f);    Vertices[3].Set(1.0f, -1.0f, 0, 1.0f);    static const uint16 Indices[6] =    {        0, 1, 2,        2, 1, 3    };    //DrawPrimitiveUP(RHICmdList, PT_TriangleStrip, 2, Vertices, sizeof(Vertices[0]));      DrawIndexedPrimitiveUP(        RHICmdList,        PT_TriangleList,        0,        ARRAY_COUNT(Vertices),        2,        Indices,        sizeof(Indices[0]),        Vertices,        sizeof(Vertices[0])    );    // Resolve render target.      RHICmdList.CopyToResolveTarget(        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        OutputRenderTargetResource-&gt;TextureRHI,        false, FResolveParams());}</code></pre><ul><li>这是渲染线程中执行的函数</li><li>这里只要在形参中添加MyColor2，以及SetParameters中添加MyColor2</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloWindow</title>
      <link href="/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/"/>
      <url>/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/</url>
      
        <content type="html"><![CDATA[<ul><li><p>glfwMakeContextCurrent(window)</p><blockquote><p>用于在当前线程上载入window的上下文。</p></blockquote></li><li><p>需要在使用opengl函数前加载glad用于定于函数地址</p><pre><code class="lang-cpp">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){  std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;  return -1;}</code></pre><p>疑问:必须在glfwMakeContextCurrent(window)之后才能初始化GLAD,为什么？</p><blockquote><p>我做了一些尝试,glViewport的操作,如果不初始化GLAD,将无法使用。而要初始化GLAD,要在当前线程载入window上下文—190921 </p></blockquote></li></ul><ul><li><p>glViewport()<br>最终显示的内容由glViewport和glfwCreateWindow的参数共同决定：不会超过glfwCreateWindow的大小,小于的话会由部分不加载出来</p><blockquote><p>如果glfwCreateWindow:800*600,glViewport:1600*600,最终 800*600<br>如果glfwCreateWindow:800*600,glViewport:400*300,最终 400*300</p></blockquote></li><li><p>glfwSetFramebufferSizeCallback()<br>这是一个回调绑定函数,他会相应窗口变化，并传递宽高给回调函数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第三章:变换</title>
      <link href="/2019/09/09/CG/DirextX/D3DTransform/"/>
      <url>/2019/09/09/CG/DirextX/D3DTransform/</url>
      
        <content type="html"><![CDATA[<h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>满足以下性质为线性变换<blockquote><p>1.$\tau(u+v) = \tau(u) + \tau(v)$<br>2.$\tau(ku) = k\tau(u)$<br>其中u,v为任意三维向量，k为标量 </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第四章:渲染管线</title>
      <link href="/2019/09/09/CG/DirextX/D3DInit/"/>
      <url>/2019/09/09/CG/DirextX/D3DInit/</url>
      
        <content type="html"><![CDATA[<h1 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h1><ul><li>我们必须使用特定的函数活其他的COM接口方法来获取指向COM接口的指针,而不能用<strong>new</strong>  </li><li>释放用其基类IUnkown的Release,而不能用<strong>delete</strong>  </li><li>COM接口都以<strong>I</strong>为前缀,例如ID3D11Texture2D  </li></ul><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><ul><li>2D纹理是一种数据元素矩阵，可以用于存储图像数据，每个元素存储一个像素颜色。也可以存储纹理法线  </li><li>纹理只支持特定格式的数据类型。有DXGI_FORMAT枚举类型描述  </li><li>存在一种弱类型（typeless），预先分配空间，但不解释类型。</li></ul><h1 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h1><ul><li><strong>离屏</strong>(off-screen) =&gt; <strong>后台缓冲区</strong>(back buffer)</li><li><strong>前台缓冲区</strong>(front buffer)</li><li>前后缓冲区互换的行为为<strong>呈现</strong>(presenting)<blockquote><p>这一操作只是交换两者指针指向的位置，所以速度很快<br><img src="SwapBuffer.png" alt></p></blockquote></li><li>前后缓冲区组成一个<strong>交换链</strong>(swap chain)</li></ul><h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><ul><li>深度缓冲区与后台缓冲区大小一样</li><li>D3D11 判断前后遮挡使用 深度缓存(depth buffering)或Z缓存(z-buffering)</li></ul><h1 id="纹理资源视图"><a href="#纹理资源视图" class="headerlink" title="纹理资源视图"></a>纹理资源视图</h1><ul><li><p>纹理可以被绑定到渲染管线（rendering pipeline）的不同阶段（stage）。  </p><blockquote><p>将纹理作为渲染目标（即，Direct3D渲染到纹理,在渲染结果暂存在纹理中），使用标志D3D11_BIND_RENDER_TARGET<br>着色器资源（即，在着色器中对纹理进行采样），使用标志D3D10_BIND_SHADER_RESOURCE</p></blockquote></li><li><p>纹理不能直接绑定到渲染管线，只能把与资源关联的资源视图绑定到不同的管线阶段  </p></li><li>Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图</strong>（resource view），渲染目标视图（ID3D11RenderTargetView）和着色器资源视图（ID3D11ShaderResourceView） </li><li>创建资源时一定要指定绑定标志值，不然将无法创建资源视图 <h2 id="资源视图的作用"><a href="#资源视图的作用" class="headerlink" title="资源视图的作用"></a>资源视图的作用</h2></li><li>（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</li><li>（2）如果在创建资源时指定的是弱类型（typeless）格式，那么在为它创建资源视图时就必须指定明确的资源类型。对于弱类型格式，纹理元素可能会在一个管线阶段中视为浮点数，而在另一个管线阶段中视为整数。</li></ul><h1 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h1><ul><li>超级采样（supersampling）:比如4x ssaa,将屏幕分别率提高4倍，然后每4个像素采样后取平均值。相当于深度缓存和后台缓存都扩大4倍。</li><li>多重采样（multisampling）:比如4x msaa,只在三角形的边缘进行处理。且每一个像素分为4个子像素。深度缓存和后台缓存也会扩大4倍。</li></ul><h1 id="特征等级"><a href="#特征等级" class="headerlink" title="特征等级"></a>特征等级</h1><ul><li>特征等级定义了一系列支持不同d3d功能的相应的等级，用意即如果一个用户的硬件不支持某一特征等级，程序可以选择较低的等级。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://enjoyphysics.cn/Article1513" target="_blank" rel="noopener">https://enjoyphysics.cn/Article1513</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染模块</title>
      <link href="/2019/09/05/CG/UE4/UE4RenderModule/"/>
      <url>/2019/09/05/CG/UE4/UE4RenderModule/</url>
      
        <content type="html"><![CDATA[<p>原文:<a href="https://zhuanlan.zhihu.com/p/72509370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72509370</a></p><h1 id="UE4场景和场景管理-Scene-、SceneManager"><a href="#UE4场景和场景管理-Scene-、SceneManager" class="headerlink" title="UE4场景和场景管理(Scene 、SceneManager)"></a>UE4场景和场景管理(Scene 、SceneManager)</h1><h2 id="Scene与UWorld和FScene"><a href="#Scene与UWorld和FScene" class="headerlink" title="Scene与UWorld和FScene"></a>Scene与UWorld和FScene</h2><ul><li>UE4 Scene有UWorld和FScene组成  </li><li>UWorld用于游戏线程，包括用户的主动行为，如物体的创建和删除。</li><li>FScene用于渲染线程，包括物体的被动行为。</li><li>UWorld和FScene一一对应</li></ul><h2 id="UWorld和ULevel和ULevelStraming"><a href="#UWorld和ULevel和ULevelStraming" class="headerlink" title="UWorld和ULevel和ULevelStraming"></a>UWorld和ULevel和ULevelStraming</h2><ul><li>UWorld由持久关卡(ULevel)和子关卡组成。子关卡可以动态加卸载，也被称为流关卡(ULevelStreaming)</li><li>流关卡(ULevelStreaming)加载和卸载由UWorldComposition负责。由基于视点距离和流关卡卡包围盒的简单的加载策略实现</li><li>具体物体放置在关卡活流关卡中，而不是在UWorld中</li></ul><h2 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h2><ul><li>FScene不具备复杂的场景管理功能</li><li>FScene有以下结构<blockquote><p>数组:用于管理各种可渲染对象和灯光<br>Octree:用于灯光和可渲染对象的快速查找<br>DrawList:用于Cache各个渲染指令</p></blockquote></li></ul><h1 id="SceneObject"><a href="#SceneObject" class="headerlink" title="SceneObject"></a>SceneObject</h1><ul><li>将具体物体放入场景(即关卡和流关卡)中的时候，各个独立物体是由AActor及其子类的对象实例来建模表达</li><li>AActor和其子类不直接持有渲染数据，具体的渲染相关的数据均在UActorComponent及其子类的实例中。</li><li>渲染相关的主要Component类结构层次如下<br><img src="ComponentClassLevel.jpg" alt></li></ul><h1 id="UE4渲染API封装"><a href="#UE4渲染API封装" class="headerlink" title="UE4渲染API封装"></a>UE4渲染API封装</h1><ul><li>UE4中的渲染API封装是个独立的模块(Module)，他们把它命名为RHI（Render Hardware Interface）</li><li>RHI的转发实现在RHICommandList.h文件里，除了基本的条件判断，大都是直接 转调渲染API实现的RHI子模块里的渲染指令。</li></ul><h1 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h1><ul><li>UE4对材质系统的封装可以理解为RenderPipeline输入的所有数据中除了几何体数据之外的所有其它数据。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li>材质分为材质模块(UMaterial)和材质实例(UMaterialInstance),两者继承自UMaterialInterface</li><li>UMaterial材质模板带有可编辑的节点图并可据此生成对应的Shader组合</li><li>UMaterialInstance材质实例则只需要引用UMaterial对应的Shader且只能修改材质模板暴露出来的材质参数。</li></ul><h2 id="FMaterialResource"><a href="#FMaterialResource" class="headerlink" title="FMaterialResource"></a>FMaterialResource</h2><ul><li>没关UMaterial中含有多个FMaterialResource，其继承自FMateriale。其负责为各个渲染API和材质所支持的各种质量等级生成对应的Shader组合</li></ul><h2 id="FMaterialRenderProxy"><a href="#FMaterialRenderProxy" class="headerlink" title="FMaterialRenderProxy"></a>FMaterialRenderProxy</h2><ul><li>FMaterialRenderProxy是FMaterial用于渲染线程的代理,它可以透过FMaterail和UMaterialInterface访问到Shader、渲染状态，光照模型等所有用户设置好的材质参数。</li></ul><hr><ul><li>UE4的材质中光照模型是不可定制的，除非修改源码</li></ul><h1 id="UE4中Shader生成"><a href="#UE4中Shader生成" class="headerlink" title="UE4中Shader生成"></a>UE4中Shader生成</h1><ul><li>UE4的shader基类为FShader,其有两个主要的子类FGlobalShader和FMaterialShader</li><li>FGlobalShader:全局Shader,会自动注册到全局ShaderCache中</li><li>FMaterialShader:用于材质(编辑器）的Shader，所有的后处理、UI、用于模型渲染的Shader都是它的子类。 </li><li>UE4 Shader生成分两部分<blockquote><p>第一部分是把材质编辑器中的节点图编译成HLSL代码，这一部分是通过FHLSLMaterialTranslator来完成的。<br>第二部分是把HLSL生成多平台的Shader代码，如Windows上的HLSL,Android上的GLSL,IOS上的MetalShader。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第五章:渲染管线</title>
      <link href="/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉"><a href="#三维视觉" class="headerlink" title="三维视觉"></a>三维视觉</h1><ul><li>渲染管线:在给定一个3D场景的几何描述及一架已确定位置和方向的虚拟摄像机时，根据虚拟摄像机的视角生成2D图像的一系列步骤<blockquote><p>渲染管线由许多步骤组成，每个步骤称为一个阶段</p></blockquote></li></ul><p><img src="5-1.jpg" alt></p><ul><li>线性透视（linear perspective）:在2d画布上两条平行的线不断向远处延伸，最终会相交到一点。这个点是零点（vanishing point）<br><img src="5-2.jpg" alt></li><li>景深现象（depth phenomenon）:物体的大小会随着深度的增加而减小<br><img src="5-3.jpg" alt></li><li>物体重叠（object overlap）:一个不透明的物体会挡住它后面的其他物体的一部分（或全部）<br><img src="5-4.jpg" alt></li><li>光照（lighting）和阴影（shading）:表现物体立体感和体积感<br><img src="5-5.jpg" alt><blockquote><p>阴影具有两个关键作用：一是告诉我们场景中的光源位置，二是告诉我们飞船距离地面的高度。<br><img src="5-6.jpg" alt></p></blockquote></li></ul><h1 id="模型的表现形式"><a href="#模型的表现形式" class="headerlink" title="模型的表现形式"></a>模型的表现形式</h1><ul><li>三角形是构成物体模型的基本单位</li></ul><h1 id="基本计算机颜色"><a href="#基本计算机颜色" class="headerlink" title="基本计算机颜色"></a>基本计算机颜色</h1><h2 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h2><ul><li><p>0.5(1, 1,1) = (0.5, 0.5, 0.5)</p><blockquote><p>将白色乘以0.5，得到一个中等强度的灰色</p></blockquote></li><li><p>分量乘法（componentwise multiplication）。</p><blockquote><p>$(c_{r},c_{g},c_{b}) ⨂ (k_{r},k_{g},k_{b}) = (c_{r}k_{r},c_{g}k_{g},c_{b}k_{b})$<br>(r,g,b)⨂(0.5,0.75,0.25) = (0.5r,0.75g,0.25b)<br>常用于光照方程,比如上述式子可以表示：光线照射物体时，反射50%红光，75%绿光，25%蓝光</p></blockquote></li></ul><h2 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h2><ul><li><p>alpha值：用于表示物体的不透明度</p><blockquote><p>alpha == 0 完全透明；alpha == 1 完全不透明</p></blockquote></li><li><p>r,g,b,a各用32位浮点型，所以这种表达方式共128位</p></li></ul><h2 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h2><ul><li><p>r,g,b,a分别用8位表示，每个分量又256种强度。</p></li><li><p>32位于128位互相转换</p><blockquote><p>32-&gt;128: 各分量除以256，转换为float<br>128-&gt;32: 各分量乘以256, 转换为int</p></blockquote></li><li><p>通常，许多颜色运算（例如，在像素着色器中）使用的都是128位颜色值；通过这一方式，我们可以有足够多的二进制位来保证计算的精确度，减少算术错误的累积。不过，最终的像素颜色通常是存储在后台缓冲区的32位颜色值中；目前的物理显示设备还不能充分利用更高的分辨率颜色。</p></li></ul><h1 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h1><p><img src="5-7.jpg" alt></p><blockquote><p>内存到阶段的箭头表示阶段从内存种读数据<br>内存到阶段的箭头表示阶段在内存种写数据</p></blockquote><h1 id="输入装配阶段-Input-Assembler-Stage"><a href="#输入装配阶段-Input-Assembler-Stage" class="headerlink" title="输入装配阶段(Input Assembler Stage)"></a>输入装配阶段(Input Assembler Stage)</h1><p>输入装配（Input Assembler，简称IA）阶段从内存读取几何数据（顶点和索引）并将这些数据组合为几何图元（例如，三角形、直线）。</p><blockquote><p>索引规定了顶点的组织形式，解释了该以何种方式组成图元。</p></blockquote><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><ul><li>Direct3D中的顶点由空间位置和各种附加属性组成。比如添加法线向量实现光照，添加纹理坐标实现纹理等等</li></ul><h2 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h2><ul><li>顶点缓冲区:在连续内存中存储了的一个顶点列表</li><li>图元拓扑:用来指定如何组织顶点缓冲区的顶点。例如每两个组成一条直线，每三个组成一个三角形</li></ul><h3 id="基本图元"><a href="#基本图元" class="headerlink" title="基本图元"></a>基本图元</h3><p><img src="5-8.png" alt></p><blockquote><p>(a)为点列表  D3D11_PRIMITIVE_TOPOLOGY_POINTLIST<br>(b)为线带 D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP<br>(c)为线列表 D3D11_PRIMITIVE_TOPOLOGY_LINELIST<br>(d)为三角形带 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 三角形带不会造成顶点的重复存储  </p></blockquote><p><img src="5-9.png" alt></p><blockquote><p>(a)为三角形列表 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST</p></blockquote><h3 id="带邻接信息的图元"><a href="#带邻接信息的图元" class="headerlink" title="带邻接信息的图元"></a>带邻接信息的图元</h3><ul><li>如上图(b)主要用于某些几何着色器的的算法 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ<blockquote><p>邻接图元顶点只能作为几何着色器的输入数据且不会被绘制出来</p></blockquote></li></ul><h3 id="控制点面片列表"><a href="#控制点面片列表" class="headerlink" title="控制点面片列表"></a>控制点面片列表</h3><ul><li>见13章  D3D11_PRIMITIVE_TOPOLOGY_N_CONTRIL_POINT_PATCHLIST<blockquote><p>用于图形渲染管线的细分阶段</p></blockquote></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>问题：通过三角形构造其他图形的时候，如果使用三角形列表，将会造成大量的顶点的重复。</p></li><li><p>产生影响: 1.增加内存需求量。2.增加图形硬件的处理负担。</p></li><li><p>方法一：使用三角形带。但是顶点必须按照带状组织，不灵活。</p></li><li><p>方法二：引入索引。</p><pre><code class="lang-cpp">//create a quadVertex v[4] = {v0, v1, v2, v3}; UINT indexList[6] = {0, 1, 2,    //Triangle0   0, 2, 3}; // Triangle 1 };</code></pre><blockquote><p>当顶点列表中的唯一顶点得到处理之后，显卡可以使用索引列表把顶点放在一起构成三角形。我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为：<br>1．索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。<br>2．通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p></blockquote></li></ul><h1 id="顶点着色器阶段-vertex-shader-Stage"><a href="#顶点着色器阶段-vertex-shader-Stage" class="headerlink" title="顶点着色器阶段(vertex shader Stage)"></a>顶点着色器阶段(vertex shader Stage)</h1><p>顶点着色器将IA阶段的输出的顶点实现相关效果再输出（例如变换，光照，置换贴图映射等）。此外此阶段还可以访问内存种的纹理和其他数据（变换矩阵和场景灯光）。可以概念性地认为在硬件上执行了如下代码：</p><pre><code class="lang-cpp">for(UINT i = 0; i &lt; numVertices; ++i)    outputVertex[i] = VertexShader(inputVertex[i]);</code></pre><h2 id="局部空间和世界空间"><a href="#局部空间和世界空间" class="headerlink" title="局部空间和世界空间"></a>局部空间和世界空间</h2><ul><li>世界变换:局部空间-&gt;世界空间</li></ul><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><ul><li>观察变换:世界空间-&gt;观察空间</li></ul><h2 id="齐次裁剪控件"><a href="#齐次裁剪控件" class="headerlink" title="齐次裁剪控件"></a>齐次裁剪控件</h2><p><a href="https://gameinstitute.qq.com/community/detail/117556" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/117556</a></p><h2 id="规范化设备坐标-NDC"><a href="#规范化设备坐标-NDC" class="headerlink" title="规范化设备坐标(NDC)"></a>规范化设备坐标(NDC)</h2><ul><li>将坐标都映射到[-1,1]，目的是消除设备差异性</li></ul><h1 id="曲面细分阶段"><a href="#曲面细分阶段" class="headerlink" title="曲面细分阶段"></a>曲面细分阶段</h1><ul><li>可选阶段,详见13章</li></ul><h1 id="几何着色器阶段"><a href="#几何着色器阶段" class="headerlink" title="几何着色器阶段"></a>几何着色器阶段</h1><ul><li>接收完整的图元数据</li><li>用于创建和销毁几何体<blockquote><p>根据接收到的图元数据来扩展图元或根据某些条件来拒绝输出某些图元数据<br>常用于将一个点扩展为一个四边形，或者将一条线扩展为一个四边形</p></blockquote></li><li>顶点位置在离开几何着色器之前，必须被变换到齐次裁剪空间。</li></ul><h1 id="裁剪阶段"><a href="#裁剪阶段" class="headerlink" title="裁剪阶段"></a>裁剪阶段</h1><ul><li>完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。</li><li>三角形被裁剪后会变成四边形，这需要重新划分三角形</li><li>Sutherland-Hodgeman裁剪法:</li></ul><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><ul><li>齐次裁剪空间-&gt;规范化设备空间-&gt;后台缓冲区的视口区域（此时x,y以像素为单位）</li><li>z值还要被深度缓存使用。</li></ul><h2 id="背面消隐"><a href="#背面消隐" class="headerlink" title="背面消隐"></a>背面消隐</h2><h3 id="判断三角形正反面"><a href="#判断三角形正反面" class="headerlink" title="判断三角形正反面"></a>判断三角形正反面</h3><ul><li>设三角形的定点排列为$v_{0},v_{1},v_{2}$</li><li>可以计算出三角形的法线，方法如下:<blockquote><p>$\vec{e_{0}} = v_{1} - v_{0}$<br>$\vec{e_{1}} = v_{2} - v_{1}$<br>$\vec{n} = \frac{\vec{e_{0}} × \vec{e_{1}}}{|| \vec{e_{0}} × \vec{e_{1}} ||}$</p></blockquote></li><li>带有法线向量的面为正面，而另一个面为背面<blockquote><p>当观察者看到三角形的正面时，我们说三角形是朝前的；当观察者看到三角形的背面时， 我们说三角形是朝后的。<br>因为按照我们选择的约定（即，我们计算三角形法线的方式），按顺时针方向环绕的三角形（相对于观察者）是朝前的，而按逆时针方向环绕的三角形（相对于观察者）是朝后的。</p></blockquote></li><li>D3D 顺时针</li></ul><h3 id="背面消隐-backface-culling"><a href="#背面消隐-backface-culling" class="headerlink" title="背面消隐(backface culling)"></a>背面消隐(backface culling)</h3><ul><li>背面消隐（backface culling）是指让管线放弃对朝后的三角形的处理。这可以将所要处理的三角形的数量降低到原数量的一半。</li><li>以下为2D和3D场景消隐前后的表现<br><img src="backfaceCulling2D.png" alt><br><img src="backfaceCulling3D.png" alt></li></ul><h2 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h2><ul><li>一条3D线被投影到投影窗口上（在屏幕空间中投影是一条2D线）。我们看到，在3D线上取等距离的点，在2D屏幕空间上的投影点却不是等距离的。所以，我们在3D空间中执行线性插值，在屏幕空间需要执行非线性插值。</li></ul><h1 id="像素着色器阶段"><a href="#像素着色器阶段" class="headerlink" title="像素着色器阶段"></a>像素着色器阶段</h1><ul><li>像素着色器（Pixel shader）是由我们编写的在GPU上执行的程序。像素着色器会处理每个像素片段（pixel fragment），它的输入是插值后的顶点属性，由此计算出一个颜色。像素着色器可以非常简单地输出一个颜色，也可以很复杂，例如实现逐像素光照、反射和阴影等效果。</li></ul><h1 id="输出合并阶段"><a href="#输出合并阶段" class="headerlink" title="输出合并阶段"></a>输出合并阶段</h1><ul><li>当像素片段由像素着色器生成之后，它们会被传送到渲染管线的输出合并（output<br>merger，简称OM）阶段。在该阶段中，某些像素片段会被丢弃（例如，未能通过深度测试或模板测试）。未丢弃的像素片段会被写入后台缓冲区。混合（blending）工作是在该阶段中完成的，一个像素可以与后台缓冲区中的当前像素进行混合，并以混合后的值作为该像素的最终颜色。某些特殊效果，比如透明度，就是通过混合来实现的；我们会在第9章专门讲解混合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之JSON学习</title>
      <link href="/2019/08/07/CG/UE4/JSON/"/>
      <url>/2019/08/07/CG/UE4/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>JSON格式</li><li>解析JSON文件</li><li>修改JSON文件</li></ul><h1 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/29119549" target="_blank" rel="noopener">十分钟搞定JSON和JSON对象</a></li></ul><p>想要使用JSO相关工具，必须在<strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;,         &quot;Json&quot;,         &quot;JsonUtilities&quot;    });</code></pre><h1 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h1><ul><li>我们在 \Content\Res\Data.json中天下如下测试例子</li></ul><pre><code class="lang-json">/** Data.json **/[    {        &quot;1-1&quot;:&quot;1-1&quot;,        &quot;1-2&quot;:&quot;1-2&quot;    },    {        &quot;2-1&quot;:&quot;2-1&quot;    },    {        &quot;3-1&quot;:        [            {                &quot;1&quot;:&quot;3-1-1&quot;            },            {                &quot;2&quot;:&quot;3-1-2&quot;            }        ]    }]</code></pre><ul><li>我们要首先得将他以字符串的形式读入<blockquote><p>FPaths::GameContentDir() 能获取 */Content/ 的位置<br>FFileHelper::LoadFileToString() Load a text file to an FString.</p></blockquote></li></ul><pre><code class="lang-cpp">bool MyJsonHandle::LoadStringFromFile(FString &amp; RelativePathName, FString &amp; FileName, FString &amp; ResultString){    if (!FileName.IsEmpty())    {        FString AbsloutePathName = FPaths::GameContentDir() + RelativePathName + FileName;        if (FPaths::FileExists(AbsloutePathName))        {            if (FFileHelper::LoadFileToString(ResultString, *AbsloutePathName))            {                return true;            }        }    }    return false;}`</code></pre><ul><li>接下来我们来解析我们所获取到的FString</li></ul><pre><code class="lang-cpp">/** MyJsonHandle.cpp **/bool MyJsonHandle::RecordDataJsonRead(){    FString result;    //这是我们上面自定义的函数    LoadStringFromFile(RelativePathName, DataFileName, result);    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse;    TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(result);    if (FJsonSerializer::Deserialize(JsonReader, JsonParse))    { //这样解析后的节点全部存在JsonParse中        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-1&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-2&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[1]-&gt;AsObject()-&gt;GetStringField(FString(&quot;2-1&quot;)));        //如果对象是嵌套的，则需要再声明一次TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt;来获取        TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse3 = JsonParse[2]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;3-1&quot;));        if (JsonParse3.IsValidIndex(0))        {            for (int cnt = 1; cnt &lt;= JsonParse3.Num(); ++cnt)            {                UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse3[cnt-1]-&gt;AsObject()-&gt;GetStringField(FString::FromInt(cnt)));            }        }        else        {            UE_LOG(LogTemp, Warning, TEXT(&quot;error JsonParse3&quot;));        }        return true;    }    return false;}</code></pre><h1 id="修改JSON文件"><a href="#修改JSON文件" class="headerlink" title="修改JSON文件"></a>修改JSON文件</h1><h2 id="设置单个属性"><a href="#设置单个属性" class="headerlink" title="设置单个属性"></a>设置单个属性</h2><ul><li>通过下面的代码生成一个<pre><code class="lang-cpp">/*** A Json Object is a structure holding an unordered set of name/value pairs.* In a Json file, it is represented by everything between curly braces {}.*/TSharedPtr&lt;FJsonObject&gt; Object1 = MakeShareable(new FJsonObject);Object1-&gt;SetStringField(&quot;1-1&quot;, &quot;1--1&quot;);Object1-&gt;SetStringField(&quot;1-2&quot;, &quot;1--2&quot;);TSharedPtr&lt;FJsonValueObject&gt; CultureValue = MakeShareable(new FJsonValueObject(CultureObject));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4学习</title>
      <link href="/2019/08/07/Menu/UE4Menu/"/>
      <url>/2019/08/07/Menu/UE4Menu/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&amp;_bid=167&amp;_wv=3&amp;ADUIN=1076613110&amp;ADSESSION=1556776713&amp;ADTAG=CLIENT.QQ.5611_.0&amp;ADPUBNO=26886&amp;taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><p><a href="https://sanctorum003.github.io/2019/08/02/HUD/" target="_blank" rel="noopener">虚幻4之Slate学习一 —— HUD</a><br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a><br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a><br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a><br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/CG/UE4/DelegateAndMacro/"/>
      <url>/2019/08/06/CG/UE4/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><div class="table-container"><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table></div><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="lang-CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="lang-cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="lang-cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="lang-cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="lang-cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="lang-cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="lang-cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li>事件原型<pre><code class="lang-cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="lang-cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li>FReply 告诉引擎如何处理事件<blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li>FReply::Handled() 告诉引擎事件处理完<blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p></li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/public:    //注意SOverlay::FOverlaySlot 是内部类    SOverlay::FOverlaySlot* MySlot;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>我们尝试编写图片的点击效果，来使用委托和宏。SImage默认不带这个效果。</li><li>首先我们创建一个继承于SlateWidget的C++类命名为MyImage</li><li>创建一个委托，用于与SLATE_EVENT绑定。相当于自定义一个需要单击会触发函数的函数原型</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/DECLARE_DELEGATE_RetVal(FReply,FImageOnClicked)</code></pre><ul><li>创建一个SLATE_EVENT,将之前创建的委托与该SLATE_EVENT绑定</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/SLATE_BEGIN_ARGS(SMyHUDWidget){}SLATE_EVENT(FImageOnClicked, ImageOnClicked)SLATE_END_ARGS()</code></pre><ul><li>然后在原来的SMyHUDWidget将SImage换成SMyImage并且可以调用ImageOnClicked()</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            /**              * TSharedPtr&lt;SMyImage&gt; MyImage;            **/            SAssignNew(MyImage, SMyImage)            //.ImageOnClicked()        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        .Expose(MySlot)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    //删除原来语句    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><ul><li>在SMyImage中添加图片</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/#include &quot;SMyImage.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SImage.h&quot;#include &quot;Public/UI/MySlateWidgetStyle.h&quot;#include &quot;Public/UI/MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyImage::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>此时效果如下<br><img src="MyImage.png" alt></p><ul><li>接着我们需要创建一个回调函数用于ImageOnClicked()，传入后event对应FImageOnClicked就绑定该函数了</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::ImageClicked(){    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, &quot;Suceess&quot;);    return FReply::Handled();}</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **//**    * TSharedPtr&lt;SMyImage&gt; MyImage;**/SAssignNew(MyImage, SMyImage).ImageOnClicked(this, &amp;SMyHUDWidget::ImageClicked)</code></pre><ul><li>但是这时候会发现，单击并没有什么效果。这是因为程序并不知道要根据单击触发。</li><li>我们需要在MyImage中重写鼠标相关函数</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/public:    FImageOnClicked ImageOnClick;    virtual FReply OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual FReply OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual void OnMouseLeave(const FPointerEvent&amp; MouseEvent) override;    bool BIsMouseButtonDown = false;</code></pre><ul><li>我们这时候需要在鼠标按下时调用委托，使用我们必须事先获取到这个委托，<em>FImageOnClicked ImageOnClick</em>就是用来声明该委托。</li><li>在构造中,通过InArgs._*可以来获取SLATE_BEGIN_ARGS(SMyHUDWidget)和SLATE_END_ARGS()之间的属性。</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/void SMyImage::Construct(const FArguments&amp; InArgs){    ImageOnClick = InArgs._ImageOnClicked;    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}</code></pre><ul><li>这样我们就可以重写鼠标事件，让其在点击时调用相关委托</li></ul><pre><code class="lang-cpp">FReply SMyImage::OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = true;    return FReply::Handled();}FReply SMyImage::OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    if (BIsMouseButtonDown == true)    {        BIsMouseButtonDown = false;        ImageOnClick.Execute();    }    return FReply::Handled();}void SMyImage::OnMouseLeave(const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = false;}</code></pre><ul><li>到此就完成了，点击图片时会显示<strong>SUCCEESS</strong><br><img src="Success.png" alt><blockquote><p>如果不成功可以尝试将播放模式设成模拟<br><img src="Simulation.png" alt></p></blockquote></li></ul><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/CG/UE4/SlateWidget/"/>
      <url>/2019/08/04/CG/UE4/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="lang-cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="lang-cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/CG/UE4/WidgetStyle/"/>
      <url>/2019/08/03/CG/UE4/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="lang-cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="lang-cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="lang-cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="lang-cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="lang-cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="lang-cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/CG/UE4/HUD/"/>
      <url>/2019/08/02/CG/UE4/HUD/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li><li>设置光标的相关属性</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="lang-cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="lang-cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="lang-cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将控件从视口删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将视口中的全部控件删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="设置光标"><a href="#设置光标" class="headerlink" title="设置光标"></a>设置光标</h1><ul><li>这里光标是默认的，我们需要让光标一直显示，不然对后面会有影像。</li><li>我们创建继承于PlayerController的MyController类。</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/AMyController::AMyController(){    /** Whether the mouse cursor should be displayed. */    bShowMouseCursor = true;}</code></pre><ul><li>我们还可以设置光标的移动范围</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/void AMyController::BeginPlay(){    /** Data structure used to setup an input mode that allows only the UI to respond to user input. */    FInputModeUIOnly InputMode;    /** Sets the mouse locking behavior of the viewport */    InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::LockAlways);    SetInputMode(InputMode);}</code></pre><ul><li>在Gamemode中应用，这样光标一直显示，且不能移出视口</li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;#include &quot;Public\MyController.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();    PlayerControllerClass = AMyController::StaticClass();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码</p><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/Algorithm/KMP/"/>
      <url>/2019/08/01/Algorithm/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p><p>3) 求当next数组当前位置<strong>j</strong></p><pre><code class="lang-cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>1) next[1]=0</p><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p><p>规则2：右移一位，最左边添-1，最右边自然溢出</p><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
