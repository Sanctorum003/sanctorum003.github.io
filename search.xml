<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图形学整理</title>
      <link href="/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html" target="_blank" rel="noopener">细说图形学渲染管线</a></p><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><h2 id="Broad-Phase"><a href="#Broad-Phase" class="headerlink" title="Broad-Phase"></a>Broad-Phase</h2><p><a href="https://zhuanlan.zhihu.com/p/113415779" target="_blank" rel="noopener">游戏物理引擎(二) 碰撞检测之Broad-Phase</a></p><ul><li><p>Broad-Phase使用某种Bounding Volume来表示刚体的碰撞信息,然后用空间划分的方式来保存这些Bounding Volume,就可以再较短的时间内筛选出可能互相碰撞的刚体对.</p></li><li><p>AABB包围盒</p></li></ul><h3 id="Uniform-Grid"><a href="#Uniform-Grid" class="headerlink" title="Uniform Grid"></a>Uniform Grid</h3><ul><li>将空间划分成等大方块</li></ul><h3 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h3><ul><li>每次只沿某一个轴划分 二叉树like</li></ul><h3 id="Oct-Tree"><a href="#Oct-Tree" class="headerlink" title="Oct-Tree"></a>Oct-Tree</h3><ul><li>三维均匀切分,设置每一块的终止条件</li></ul><h3 id="BSP-Tree"><a href="#BSP-Tree" class="headerlink" title="BSP-Tree"></a>BSP-Tree</h3><ul><li>每次取一个方向（非横平竖直）将空间分为两部分 （会很麻烦）</li></ul><h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><ul><li><p>以object为单位划分空间</p></li><li><p>二叉树，两个子节点分别存两部分物体的AABB</p></li><li><p>一个物体只可能出现在一个包围盒中</p></li><li><p>如何划分很有讲究，不好的划分会使包围盒重合，降低效率</p><blockquote><p>可以用topk算法快速找中位物体划分</p></blockquote></li></ul><h2 id="Narrow-Phase"><a href="#Narrow-Phase" class="headerlink" title="Narrow-Phase"></a>Narrow-Phase</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/127844705" target="_blank" rel="noopener">游戏物理引擎(三) 碰撞检测之Narrow-Phase</a></li></ul><h3 id="Separating-Axis-Theorem-SAT-算法"><a href="#Separating-Axis-Theorem-SAT-算法" class="headerlink" title="Separating Axis Theorem(SAT)算法"></a>Separating Axis Theorem(SAT)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/176667175" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（一） - SAT</a></li></ul><h3 id="Gilbert-Johnson-Keerthi-GJK-算法"><a href="#Gilbert-Johnson-Keerthi-GJK-算法" class="headerlink" title="Gilbert-Johnson-Keerthi (GJK)算法"></a>Gilbert-Johnson-Keerthi (GJK)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（上）</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（下）</a></li></ul><h1 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a>DrawCall</h1><p><a href="https://zhuanlan.zhihu.com/p/358687016" target="_blank" rel="noopener">Unity:浅谈对Drawcall的理解</a></p><ul><li>渲染分为三个阶段:应用阶段、几何阶段、光栅化阶段</li><li>Drawllcall就是应用阶段收集完模型的顶点材质以及其他数据后,CPU去通知GPU去对所传递的图元进行渲染。</li></ul><h2 id="为啥要减少drawcall呢？"><a href="#为啥要减少drawcall呢？" class="headerlink" title="为啥要减少drawcall呢？"></a>为啥要减少drawcall呢？</h2><ul><li>传输数据消耗较大，GPU的计算能力又非常优秀，那么存在一种情况:Cpu传递的drawcall指令只渲染一小部分，GPU飞快的渲染完了，而下一条drawcall的指令还没有完成传输过程。此类的指令过多就造成了卡顿。所以提高drawcall传输效率就非常有必要了</li></ul><h2 id="减少drawcall的方法"><a href="#减少drawcall的方法" class="headerlink" title="减少drawcall的方法"></a>减少drawcall的方法</h2><ul><li>主要的方法就是合批（Batch），合批又分为静态合批，动态合批两个不同的操作</li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>mipmap（多级渐远纹理）<blockquote><p>它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一,每提升一个Level，对相邻的四个元素进行插值。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p></blockquote></li></ul><h1 id="前向渲染和延迟渲染"><a href="#前向渲染和延迟渲染" class="headerlink" title="前向渲染和延迟渲染"></a>前向渲染和延迟渲染</h1><h1 id="齐次坐标和透视除法"><a href="#齐次坐标和透视除法" class="headerlink" title="齐次坐标和透视除法"></a>齐次坐标和透视除法</h1><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul><li><p>目的：为了解决欧式几何空间中两条支线是不能相交的，但透视空间两条支线是可以相交的。</p></li><li><p>齐次坐标就是用N+1维来代表N维坐标，通过添加一个额外的分量w，</p></li></ul><blockquote><p>如果(x,y,z)是个点，则变为(x,y,z,1);<br>如果(x,y,z)是个向量，则变为(x,y,z,0);</p></blockquote><h2 id="透视除法"><a href="#透视除法" class="headerlink" title="透视除法"></a>透视除法</h2><ul><li>透视除法不在vs中进行，vs转换得到的是裁剪空间，透视除法在光栅化之前进行</li><li>透视除法将齐次坐标的每一个分量除以w，得到NDC</li><li>透视除法可以将齐次坐标转换成欧式坐标</li></ul><h1 id="欧拉角和万向结死锁"><a href="#欧拉角和万向结死锁" class="headerlink" title="欧拉角和万向结死锁"></a>欧拉角和万向结死锁</h1><p><a href="https://zhuanlan.zhihu.com/p/42519819" target="_blank" rel="noopener">3D游戏世界里的万向节锁</a></p><ul><li>万向结死锁就是一个物体在一个3D世界里面随着旋转顺序和旋转角度的改变，导致物体只能在一个固定的平面旋转，无法旋转到你预想的角度。由于物体的旋转，物体的坐标轴方向也发生了改变，导致其中2条坐标轴发生了重合。当你围绕着重合的坐标轴旋转时，物体的旋转方向始终在一个平面上旋转。</li></ul><h1 id="画线算法"><a href="#画线算法" class="headerlink" title="画线算法"></a>画线算法</h1><ul><li>光栅直线的特点<blockquote><p>X的值每次增长1 </p></blockquote></li></ul><blockquote><p>Y的值会在保持不变和增长1之间选择</p></blockquote><h2 id="DDA"><a href="#DDA" class="headerlink" title="DDA"></a>DDA</h2><h2 id="Bresenham"><a href="#Bresenham" class="headerlink" title="Bresenham"></a>Bresenham</h2><h1 id="点到平面计算距离"><a href="#点到平面计算距离" class="headerlink" title="点到平面计算距离"></a>点到平面计算距离</h1><p><img src="点到直线距离.png" alt></p><ul><li>设点为P，根据屏幕方程得到平面法向量N,取平面上一点Q,连接PQ,得到向量QP,设两条向量的夹角为Alpha,则cos(Alpha)可求，然后根据三角函数，距离可求</li></ul><h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>$\left[\begin{matrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{matrix} \right]$</p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li>绕x轴</li></ul><p>$\left[\begin{matrix}<br>    1 &amp; 0 &amp; 0 &amp; 0\\<br>    0 &amp; cos\theta  &amp; -sin\theta &amp; 0\\<br>    0 &amp; sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕y轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; 0 &amp; sin\theta &amp; 0\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\<br>    -sin\theta &amp; 0 &amp; cos\theta  &amp; 0 \\<br>        0 &amp; 0 &amp; 0 &amp; 1   \\<br>\end{matrix} \right]$</p><ul><li>绕z轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; -sin\theta &amp; 0 &amp; 0\\<br>    sin\theta &amp; cos\theta  &amp; 0 &amp; 0\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕任意轴<blockquote><p>太复杂了</p></blockquote></li></ul><blockquote><p>绕任意轴都可以轴上面三个组合得到</p></blockquote><h1 id="正交矩阵的逆矩阵"><a href="#正交矩阵的逆矩阵" class="headerlink" title="正交矩阵的逆矩阵"></a>正交矩阵的逆矩阵</h1><ul><li>转置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 智能指针</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/150555165" target="_blank" rel="noopener">现代 C++：一文读懂智能指针</a></p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h2><p>头文件：<code>#include &lt;memory&gt;</code></p><h2 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h2><pre><code class="lang-cpp">std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</code></pre><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h3 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h3><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>Aliasing constructor<blockquote><p>简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p></blockquote></li></ul><pre><code class="lang-cpp">// shared_ptr constructor example#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;using Vec = std::vector&lt;int&gt;;std::shared_ptr&lt;int&gt; GetSPtr() {    auto elts = {0, 1, 2, 3, 4};    std::shared_ptr&lt;Vec&gt; pvec = std::make_shared&lt;Vec&gt;(elts); //use_count == 1    std::shared_ptr&lt;int&gt; t(pvec, &amp;(*pvec)[2]);  //use_count == 2    pvec.reset(); // use_count == 1    return t;}int main() {    std::shared_ptr&lt;int&gt; sptr = GetSPtr();// use_count == 1 ,t,pvec都销毁,sptr引用    sptr.reset();// use_count == 1    cout&lt;&lt;*sptr.get()&lt;&lt;endl;  // =2  指向的是&amp;(*pvec)[2],并且延长了pvec指向vector&lt;int&gt;的生命周期    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理</title>
      <link href="/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vector实现原理"><a href="#vector实现原理" class="headerlink" title="vector实现原理"></a>vector实现原理</h1><p><a href="https://zhuanlan.zhihu.com/p/358113531" target="_blank" rel="noopener">(新手向)谈谈C++中的萃取</a><br><a href="https://blog.csdn.net/ncepu_Chen/article/details/114947710" target="_blank" rel="noopener">侯捷C++课程笔记03: STL标准库与泛型编程</a></p><ul><li>容器<code>vector</code>的代码如下:</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc= alloc&gt;class vector {public:    typedef T value_type;    typedef value_type* iterator;    typedef value_type&amp; reference;    typedef size_t size_type;protected:    iterator start;    iterator finish;    iterator end_of_storage;public:    iterator begin() { return start; }    iterator end() { return finish; }    size_type size() const { return size_type(end() - begin()); }    size_type capacity() const { return size_type(end_of_storage - begin()); }    bool empty() const { return begin() == end(); }    reference operator[](size_type n) { return *(begin() + n); }    reference front() { return *begin(); }    reference back() { return *(end() - 1); }};</code></pre><p><img src="https://img-blog.csdnimg.cn/20210321014124690.png" alt></p><p>容器<code>vector</code>的迭代器<code>start</code>指向第一个元素,迭代器<code>finish</code>指向最后一个元素的下一个元素,这两个迭代器对应begin()和end()的返回值,维持了<strong>前闭后开</strong>的特性.</p><p><code>vector</code><strong>对使用者是连续的</strong>,因此重载了<code>[]</code>运算符.</p><p><code>vector</code><strong>的实现也是连续的</strong>,因此使用指针类型做迭代器(即迭代器<code>vector&lt;T&gt;::iterator</code>的实际类型是原生指针<code>T*</code>).</p><h2 id="内存满了怎么办（push-back）"><a href="#内存满了怎么办（push-back）" class="headerlink" title="内存满了怎么办（push_back）"></a>内存满了怎么办（push_back）</h2><ul><li><code>vector::push_back</code>方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用<code>insert_aux</code>函数先扩容两倍再插入元素.</li></ul><pre><code class="lang-cpp">void push_back(const T &amp;x) {    if (finish != end_of_storage) { // 尚有备用空间,则直接插入,并调整finish迭代器        construct(finish, x);                ++finish;                        } else                             // 已无备用空间则调用 insert_aux 先扩容再插入元素        insert_aux(end(), x);}</code></pre><ul><li><code>insert_aux</code>被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_ux(iterator position, const T &amp;x) {    if (finish != end_of_storage) {     // 尚有备用空间,则将插入点后元素后移一位并插入元素，因为这个函数还会被其他函数调用，比如insert之类的所以还是要检查        construct(finish, *(finish - 1));   // 以vector最后一个元素值为新节点的初值        ++finish;        T x_copy = x;        copy_backward(position, finish - 2, finish - 1);        *position = x_copy;    } else {        // 已无备用空间,则先扩容,再插入        const size_type old_size = size();        const size_type len = old_size != 0 ?: 2 * old_size:1;  // 扩容后长度为原长度的两倍        iterator new_start = data_allocator::allocate(len);        iterator new_finish = new_start;        try {            new_finish = uninitialized_copy(start, position, new_start);    // 拷贝插入点前的元素            construct(new_finish, x);                                       // 插入新元素并调整水位            ++new_finish;            new_finish = uninitialized_copy(position, finish, new_finish);  // 拷贝插入点后的元素()，还是比如说insert函数，这种情况就要把后面的元素进行拷贝        }        catch (...) {            // 插入失败则回滚,释放内存并抛出错误            destroy(new_start, new_finish) :            data_allocator::deallocate(new_start, len);            throw;        }        // 释放原容器所占内存        destroy(begin(), end());        deallocate();        // 调整迭代器        start = new_start;        finish = new_finish;        end_of_storage = new_start + len;    }};</code></pre><h1 id="map实现原理"><a href="#map实现原理" class="headerlink" title="map实现原理"></a>map实现原理</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 RTTI</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/</url>
      
        <content type="html"><![CDATA[<h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><p>typeid、type_info 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Flyable                       // 能飞的{public:    virtual void takeoff() = 0;     // 起飞    virtual void land() = 0;        // 降落};class Bird : public Flyable         // 鸟{public:    void foraging() {...}           // 觅食    virtual void takeoff() {...}    virtual void land() {...}    virtual ~Bird(){}};class Plane : public Flyable        // 飞机{public:    void carry() {...}              // 运输    virtual void takeoff() {...}    virtual void land() {...}};class type_info{public:    const char* name() const;    bool operator == (const type_info &amp; rhs) const;    bool operator != (const type_info &amp; rhs) const;    int before(const type_info &amp; rhs) const;    virtual ~type_info();private:    ...};void doSomething(Flyable *obj)                 // 做些事情{    obj-&gt;takeoff();    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;        // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）    if(typeid(*obj) == typeid(Bird))            // 判断对象类型    {        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化        bird-&gt;foraging();    }    obj-&gt;land();}int main(){    Bird *b = new Bird();    doSomething(b);    delete b;    b = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 只在堆上或栈上生成对象的类</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h1><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p></blockquote><h2 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h2><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h2 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h2><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 delete this</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/</url>
      
        <content type="html"><![CDATA[<h1 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h1><blockquote><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p></blockquote><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 内存分配和管理</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h1><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h1 id="malloc与free"><a href="#malloc与free" class="headerlink" title="malloc与free"></a>malloc与free</h1><p>用于分配、释放内存</p><p>malloc、free 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">char *str = (char*) malloc(100);assert(str != nullptr);</code></pre><p>释放内存后指针置空</p><pre><code class="lang-cpp">free(p); p = nullptr;</code></pre><h1 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h1><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><p>new、delete 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">int main(){    T* t = new T();     // 先内存分配 ，再构造函数    delete t;           // 先析构函数，再内存释放    return 0;}</code></pre><h1 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h1><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><pre><code class="lang-cpp">new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list }</code></pre><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 虚函数</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li><p>析构函数： 父类的后执行，子类的先执行</p></li><li><p>附加</p><blockquote><p>默认构造函数（无参构造函数），有参构造函数，拷贝构造函数，级别依次递增。当我们提供了后面的，前面的编译器就不会提供了。</p></blockquote></li></ul><h2 id="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"><a href="#构造函数不能定义为虚函数，析构函数一般需要定义为虚函数" class="headerlink" title="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"></a>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</h2><ul><li><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></li></ul><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><pre><code class="lang-cpp">virtual int A() = 0;</code></pre><h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文<strong>虚继承</strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p></blockquote><h1 id="虚函数指针与虚函数表"><a href="#虚函数指针与虚函数表" class="headerlink" title="虚函数指针与虚函数表"></a>虚函数指针与虚函数表</h1><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><blockquote><p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p></blockquote><h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1><p>原因:虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。<br>目的：令某个类做出声明，承诺愿意共享它的基类<br>形式:</p><pre><code class="lang-cpp">//关键字public virtual的顺序随意class A:public virtual B;class C:virtual public B;</code></pre><ul><li><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></li><li><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></li></ul><p><a href="https://blog.csdn.net/longlovefilm/article/details/80558879" target="_blank" rel="noopener">C++ 虚继承实现原理（虚基类表指针与虚基类表</a></p><h2 id="虚继承与虚函数"><a href="#虚继承与虚函数" class="headerlink" title="虚继承与虚函数"></a>虚继承与虚函数</h2><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h1 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h1><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h1 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h1><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式整理</title>
      <link href="/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/342769966" target="_blank" rel="noopener"></a></p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 宏</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li><li>不做类型检查，在预编译阶段制作一对一替换</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 引用</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul><li>左值和右值<ul><li>辣鸡的C++ PRIMER解释<ul><li>左值(lvalue) : 是那些求值结果为对象或者函数的表达式，一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象。</li><li>右值(rvalue) : 是指一种表达式,其结果是值而非值所在的位置。 </li></ul></li><li>参考博客:<a href="https://blog.csdn.net/xuwqiang1994/article/details/79924310" target="_blank" rel="noopener">https://blog.csdn.net/xuwqiang1994/article/details/79924310</a><ul><li>左值(lvalue) : lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。</li><li>右值(rvalue) : rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是不在内存中占有确定位置的表达式。</li></ul></li><li>参考博客:<a href="https://blog.csdn.net/qq_24964575/article/details/52202989" target="_blank" rel="noopener">https://blog.csdn.net/qq_24964575/article/details/52202989</a><ul><li>左值可以当作右值使用,右值不能当左值用.</li><li>左值可以出现在=的任何一方,</li><li>出现在=右方的左值,是把左值当作右值使用,这是非常正常的.</li><li>右值,不能当作左值使用.</li><li>能够(单独)出现在=左方的是左值(实际是左右值,左值总是可以当作右值使用)</li><li>只能够出现在=右方的,是右值(纯粹的右值),不能当作左值使用.</li><li>左值代表地址单元,右值代表数据本身.</li><li>地址单元里的数据,是左值变量的右值的含义.</li><li>右值包括,纯数据,比如常数100,字符串常量”12345”等</li><li>以及地址单元中存储的数据.比如x ,这是左值当作右值使用代表的意义.</li><li>以及一些常变量(有确切地址的常量,可以象变量一样有个名字,其实就是变量,只是右值化了,不能当左值使用了)的含义.</li><li>左值代表存储器的一个单元.</li><li>这是一个物理概念,不仅仅是个地址(地址不过是个编号,是个数值而已),是个实实在在的东西.</li><li>右值代表数据,一个数值而已.</li></ul></li><li>参考博客:<a href="https://www.zhihu.com/question/382300648" target="_blank" rel="noopener">https://www.zhihu.com/question/382300648</a><ul><li>取地址符取到的是一个地址，没有实际存储在哪，所以是右值</li><li>如果是寄存器变量也没有地址，所以是右值</li></ul></li></ul></li></ul><blockquote><p>使用decltype时,左值返回引用类型，右值不返回引用类型。</p></blockquote><ul><li>对于自增自减（++i,i++）<ul><li>++i将对象本身作为左值返回</li><li>i++将对象原始值作为右值返回</li></ul></li></ul><h1 id="右值引用-c"><a href="#右值引用-c" class="headerlink" title="右值引用(c++)"></a>右值引用(c++)</h1><ul><li>定义 &amp;&amp;</li><li><p>右值引用只能引用到右值，不能引用到左值(const 例外)</p><blockquote><p>附加 <a href="https://www.zhihu.com/question/310966840" target="_blank" rel="noopener">为什么C++里const左值引用可以引用右值，这样做的考虑是什么？</a></p></blockquote></li><li><p>左值持久</p></li><li><p>右值短暂</p><ul><li>字面常量、临时对象</li><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul></li><li><p>引用右值的变量则是左值，不能再被右值引用</p></li></ul><pre><code class="lang-cpp">int &amp;&amp;rr1 = 42;//trueint &amp;&amp;rr2 = rr1;//error</code></pre><ul><li>move函数：获得绑定在左值上的右值引用<ul><li>调用move后，原变量除赋值和销毁外，不能再使用他</li></ul></li></ul><h2 id="左值引用作用"><a href="#左值引用作用" class="headerlink" title="左值引用作用"></a>左值引用作用</h2><ul><li>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul></li></ul><h1 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h1><p><a href="https://blog.csdn.net/zhangxiao93/article/details/74974546" target="_blank" rel="noopener">C++引用折叠</a></p><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li><li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 成员初始化列表</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><p>形式</p><pre><code class="lang-cpp">class test{public:    test(int _a,int _b):a(_a),b(_b);private:    int a;    int b;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 面向对象 -- 封装、继承、多态</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="https://gitee.com/huihut/interview/raw/master/images/面向对象基本特征.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><blockquote><p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p></blockquote><h3 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h3><p>函数重载</p><pre><code class="lang-cpp">class A{public:    void do(int a);    void do(int a, int b);};</code></pre><h3 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h3><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li></ul><p>动态多态使用</p><pre><code class="lang-cpp">class Shape                     // 形状类{public:    virtual double calcArea()    {        ...    }    virtual ~Shape();};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};class Rect : public Shape       // 矩形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    Shape * shape2 = new Rect(5.0, 6.0);    shape1-&gt;calcArea();         // 调用圆形类里面的方法    shape2-&gt;calcArea();         // 调用矩形类里面的方法    delete shape1;    shape1 = nullptr;    delete shape2;    shape2 = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 initializer_list初始化</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="含有可变（数量）形参的函数"><a href="#含有可变（数量）形参的函数" class="headerlink" title="含有可变（数量）形参的函数"></a>含有可变（数量）形参的函数</h1><ul><li><p><a href="https://blog.csdn.net/Clark_Sev/article/details/89500808?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">使用方法</a> </p></li><li><p>initializer_list 标准库类型</p><ul><li>成员永远是常量 </li><li>传递参数的时候用花括号括起来</li></ul></li><li><p>可变参模板</p><ul><li>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</li></ul></li></ul><p>initializer_list 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;template &lt;class T&gt;struct S {    std::vector&lt;T&gt; v;    S(std::initializer_list&lt;T&gt; l) : v(l) {         std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list\n&quot;;    }    void append(std::initializer_list&lt;T&gt; l) {        v.insert(v.end(), l.begin(), l.end());    }    std::pair&lt;const T*, std::size_t&gt; c_arr() const {        return {&amp;v[0], v.size()};  // 在 return 语句中复制列表初始化                                   // 这不使用 std::initializer_list    }};template &lt;typename T&gt;void templated_fn(T) {}int main(){    S&lt;int&gt; s = {1, 2, 3, 4, 5}; // 复制初始化    s.append({6, 7, 8});      // 函数调用中的列表初始化    std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\n&quot;;    for (auto n : s.v)        std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    std::cout &lt;&lt; &quot;Range-for over brace-init-list: \n&quot;;    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    auto al = {10, 11, 12};   // auto 的特殊规则    std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#39;\n&#39;;//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，                             // 它无类型，故 T 无法推导    templated_fn&lt;std::initializer_list&lt;int&gt;&gt;({1, 2, 3}); // OK    templated_fn&lt;std::vector&lt;int&gt;&gt;({1, 2, 3});           // 也 OK}</code></pre><ul><li>省略符形参<ul><li>应该只用在c和c++通用的类型，不适用于大多数类类型</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4面经</title>
      <link href="/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ai寻路怎么确保不跟其他ai撞等"><a href="#ai寻路怎么确保不跟其他ai撞等" class="headerlink" title="ai寻路怎么确保不跟其他ai撞等"></a>ai寻路怎么确保不跟其他ai撞等</h1><h1 id="抛物线模拟实现"><a href="#抛物线模拟实现" class="headerlink" title="抛物线模拟实现"></a>抛物线模拟实现</h1><h1 id="AI系统"><a href="#AI系统" class="headerlink" title="AI系统"></a>AI系统</h1><h2 id="UE4-NavMesh原理"><a href="#UE4-NavMesh原理" class="headerlink" title="UE4 NavMesh原理"></a>UE4 NavMesh原理</h2><ul><li><p>参考文章</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/74537236" target="_blank" rel="noopener">UE4 Navmesh寻路（一）Recast基础</a><br><a href="https://zhuanlan.zhihu.com/p/78873379" target="_blank" rel="noopener">UE4 Navmesh寻路（二）Detour寻路</a></p></blockquote></li><li><p>目前生成Navmesh数据主要有两种方式：多边形裁剪和体素化。</p><ul><li>多边形裁剪是直接对地形的多边形网格数据进行裁剪及合并，从而生成导航网格。方法比较直观，但难度更高，目前havok引擎使用了此方法。</li><li>体素化是对地形多边形网格进行栅格化，然后用这些“格子”重新生成导航网格，方法更复杂，但难度更低，Recast使用了此方案，而UE4使用了Recast。</li></ul></li></ul><h3 id="Recast"><a href="#Recast" class="headerlink" title="Recast"></a>Recast</h3><ul><li>Recast:将场景网格模型生成用于寻路的导航网格</li><li>Detour：利用导航网格进行寻路</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库整理</title>
      <link href="/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树-B-树-B-树-红黑树"><a href="#AVL树-B-树-B-树-红黑树" class="headerlink" title="AVL树/B-树/B+树/红黑树"></a>AVL树/B-树/B+树/红黑树</h1>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 decltype</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/</url>
      
        <content type="html"><![CDATA[<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><ul><li>decltype 用于选择并返回操作数的数据类型</li></ul><blockquote><p>只推断类型，不计算表达式的值</p><p>decltype能返回包括顶层const和引用在内的类型</p></blockquote><pre><code class="lang-cpp">const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; // x is const intdecltype(cj) y = x; // y is const int&amp;,并初始化绑定xdecltype(cj) z;     // wrong 引用必须初始化</code></pre><ul><li>decltype与引用</li></ul><pre><code class="lang-cpp">int i = 42,*p=&amp;i,&amp;r=i;decltype(r)  //int&amp;decltype(r+0) //intdecltype(*p) //int&amp;</code></pre><ul><li>decltype((variable))的结果(即带括号的表达式)永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用的时候才是引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 enum</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/</url>
      
        <content type="html"><![CDATA[<h1 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h1><pre><code class="lang-cpp">//限定作用域的枚举类型(c++11)enum class open_modes { input, output, append };//不限定作用域的枚举类型enum color { red, yellow, green };//不限定作用域的匿名枚举类型enum { floatPrec = 6, doublePrec = 10 };</code></pre><ul><li><p>匿名枚举类型用处</p><ul><li>在程序中需要<strong>数值的名字</strong>的时候使用<ul><li>宏定义的缺点:在预处理阶段只做简单替换不做安全检查</li><li>匿名的enum枚举:编译器会对其进行类型检查，若代码中其他地方有和该名字冲突的，会报错</li><li>静态变量: 作用域在本文件内,编译阶段检查，比匿名enum内存占用多<blockquote><p><a href="https://zhuanlan.zhihu.com/p/267401289" target="_blank" rel="noopener">c语言之枚举类型（enum）</a></p></blockquote></li></ul></li></ul></li><li><p>和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p></li><li>关键字是 enum class(等价enum struct)</li><li>限定作用域枚举类型，作用域外无法访问；不限定作用域的枚举类型，枚举成员的作用域和枚举类型本身的作用域一致</li></ul><pre><code class="lang-cpp">enum class /*struct*/ MyEnum { A = 0};        // 限定作用域的枚举enum class /*struct*/ MyEnum1 { A = 0 };    // 限定作用域的枚举可以有重复的名字，使用时也必须加上作用域enum MyEnum2 { B = 0 };                        // 不限定作用域的枚举enum MyEnum3 { B = 0 };                        // 不限定作用域的枚举不能有重复的名字enum {test = 0} t,t1;                        // 未命名的不限定作用域的枚举,只能在定义是就定义对象MyEnum::A;                                          //限定作用域的枚举要带上作用域B;                                                     //true</code></pre><ul><li><p>默认情况下，枚举值从0开始，依次加1，如果没有显示提供值，就在前一个枚举值的基础上加1。枚举成员是const的。</p></li><li><p>只要enum有名字，我们就能定义并初始化该类型的成员。想要初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。</p></li><li><p>一个不限定作用域的枚举类型的对象或枚举成员自动的转成整型</p></li><li><p>在C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。如果我们指定了潜在类型，则一旦超出范围将引发错误。对于限定作用域的枚举成员，其缺省为int类型</p></li><li><p>在C++11 新标准中，我们可以提前声明enum。enum的前置声明必须指定其成员的大小。</p><pre><code class="lang-cpp">enum test : long;    // 不限定作用域的，必须指定成员类型enum class test1;    // 限定作用域的枚举类型可以使用默认成员类型int</code></pre></li><li><p>int值不可以做以enmu为形参的函数的实参。对与不限定作用域的enum做形参时，enum的值提升成int或更大的整型（注意只会提升成对应整型，不会隐式转换为unsigned char之类），实际提升的结果由枚举类型的潜在类型决定。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 范围解析运算符</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><p>:: 使用</p><pre><code class="lang-cpp">int count = 11;         // 全局（::）的 countclass A {public:    static int count;   // 类 A 的 count（A::count）};int A::count = 21;void fun(){    int count = 31;     // 初始化局部的 count 为 31    count = 32;         // 设置局部的 count 的值为 32}int main() {    ::count = 12;       // 测试 1：设置全局的 count 的值为 12    A::count = 22;      // 测试 2：设置类 A 的 count 为 22    fun();                // 测试 3    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 friend友元</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h1><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><pre><code class="lang-cpp">//声明方式class CLASS_NAME{    friend //函数声明    friend //类声明    public:        //...    private:        //...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 using</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/</url>
      
        <content type="html"><![CDATA[<h1 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h1><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><pre><code class="lang-cpp">using namespace_name::name;</code></pre><h2 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><pre><code class="lang-cpp">class Derived : Base {public:    using Base::Base;    /* ... */};</code></pre><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><pre><code class="lang-cpp">Derived(parms) : Base(args) { }</code></pre><h2 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h2><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><pre><code class="lang-cpp">using namespace_name name;</code></pre><h2 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h2><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><p>using 使用</p><p>尽量少使用 <code>using 指示</code></p><pre><code class="lang-cpp">using namespace std;</code></pre><p>应该多使用 <code>using 声明</code></p><pre><code class="lang-cpp">int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl;</code></pre><p>或者</p><pre><code class="lang-cpp">using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl;</code></pre><h1 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using = (类型别名)"></a>using = (类型别名)</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using double = wages; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于复合类型的别名的声明语句要小心"><a href="#对于复合类型的别名的声明语句要小心" class="headerlink" title="对于复合类型的别名的声明语句要小心"></a>对于复合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 explicit关键字</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h1><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li></ul><ul><li>转换构造函数</li></ul><blockquote><p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</p></blockquote><pre><code class="lang-cpp">Sales_data(std::string s) : Sales_data(s,0,0){} // 可以隐式(stirng -&gt; Sales_data)Sales_data(std::istream &amp;is) : Sales_data(){read(is,*this)} // 可以隐式（cin(istream) -&gt; Sales_data）</code></pre><h2 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h2><ul><li>对其他类型也只会允许一步类型转换</li></ul><pre><code class="lang-cpp">Sales_data::combine(&quot;99999&quot;); //error char* -&gt; string -&gt; Sales_data</code></pre><ul><li>可以显式隐式混用</li></ul><pre><code class="lang-cpp">Sales_data::combine(string(&quot;99999&quot;));Sales_data::combine(Sales_data(&quot;9999999&quot;));</code></pre><h2 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h2><ul><li><p>关键字 <font color="red">explicit</font></p></li><li><p>只能在类内的单个形参的构造函数前使用</p></li><li><p>并且explicit声明的构造函数只能用于直接初始化而不能用于拷贝初始化</p></li></ul><pre><code class="lang-cpp">Sales_data item1(null_book); //trueSales_data item2 = null_book; //error</code></pre><ul><li>explicit 使得构造函数不能用于隐式变换，但仍可以显式变换</li></ul><pre><code class="lang-cpp">item.combine(Sales_data(null_book));item.combine(Static_cast&lt;Sales_data&gt;(cin));</code></pre><h1 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h1><ul><li>形式</li></ul><pre><code class="lang-cpp">operator type() const;</code></pre><p>-</p><ul><li>type表示某种类型</li><li><p>可以面向除void以外的任意类型进行定义,并且要求能作为返回类型</p><ul><li>所以type不能是数组和函数，但可以是指向数组和函数的指针或绑定它们的引用</li><li>没有返回类型，没有形参，必须是成员函数</li></ul></li><li><p>显式的类型转换运算符(c++11新特性)</p><blockquote><p>即显示的类型转换运算符(c++11新特性)(explicit operator)</p><ul><li>通常与explicit一样</li><li>如果当表达式被用作条件，则编译其会将显式的类型转换自动应用于它。<ul><li>if、while、for 的控制表达式；</li><li>内建逻辑运算符 !、&amp;&amp; 和 || 的操作数；</li><li>条件运算符 ?: 的首个操作数；</li><li>static_assert 声明中的谓词；</li><li>noexcept 说明符中的表达式；</li><li>explicit 说明符中的表达式。(C++20 起)</li></ul></li></ul></blockquote></li></ul><ul><li>无论什么时候在条件中使用流对象，都会为IO类型定义operator bool的隐式转换</li></ul><h1 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h1><pre><code class="lang-cpp">struct A{    A(int) { }    operator bool() const { return true; }};struct B{    explicit B(int) {}    explicit operator bool() const { return true; }};void doA(A a) {}void doB(B b) {}int main(){    A a1(1);        // OK：直接初始化    A a2 = 1;        // OK：复制初始化    A a3{ 1 };        // OK：直接列表初始化    A a4 = { 1 };        // OK：复制列表初始化    A a5 = (A)1;        // OK：允许 static_cast 的显式转换     doA(1);            // OK：允许从 int 到 A 的隐式转换    if (a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a6(a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a7 = a1;        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a8 = static_cast&lt;bool&gt;(a1);  // OK ：static_cast 进行直接初始化    B b1(1);        // OK：直接初始化    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化    B b3{ 1 };        // OK：直接列表初始化    B b4 = { 1 };        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化    B b5 = (B)1;        // OK：允许 static_cast 的显式转换    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换    bool b8 = static_cast&lt;bool&gt;(b1);  // OK：static_cast 进行直接初始化    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习  c实现c++类</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h1><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同(虚函数表见<a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a>)</li></ul><blockquote><p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经整理</title>
      <link href="/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><a href="https://www.zhihu.com/question/22393997" target="_blank" rel="noopener">复杂度证明</a></li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/solthx/RBTtree" target="_blank" rel="noopener">RBTtree</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li><p>进程是资源调度、分配的独立单位</p></li><li><p>这个还是看面经好了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 union联合体</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/</url>
      
        <content type="html"><![CDATA[<h1 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public（也可以有private和protected）</li><li>可以含有构造函数、析构函数(此处就是不加virtual的析构函数)</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><p>union 使用</p><pre><code class="lang-cpp">#include&lt;iostream&gt;union UnionTest {    UnionTest() : i(10) {};    int i;    double d;};static union {    int i;    double d;};int main() {    UnionTest u;    union {        int i;        double d;    };    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10    ::i = 20;    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20    i = 30;    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 struct和typedef struct</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/</url>
      
        <content type="html"><![CDATA[<h1 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h1><h2 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h2><pre><code class="lang-c">// ctypedef struct Student {    int age; } S;</code></pre><p>等价于</p><pre><code class="lang-c">// cstruct Student {     int age; };typedef struct Student S;</code></pre><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h2 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h2><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><pre><code class="lang-cpp">// cppstruct Student {     int age; };void f( Student me );       // 正确，&quot;struct&quot; 关键字可省略</code></pre><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><pre><code class="lang-cpp">typedef struct Student {     int age; } S;void Student() {}           // 正确，定义后 &quot;Student&quot; 只代表此函数//void S() {}               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名int main() {    Student();     struct Student me;      // 或者 &quot;S me&quot;;    return 0;}</code></pre><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using wages = double; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于符合符合类型的别名的声明语句要小心"><a href="#对于符合符合类型的别名的声明语句要小心" class="headerlink" title="对于符合符合类型的别名的声明语句要小心"></a>对于符合符合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 class和struct</title>
      <link href="/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/"/>
      <url>/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h1><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 extern C</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/</url>
      
        <content type="html"><![CDATA[<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><ul><li>extern “xxx”表示链接指示，用于c++调用其他语言编写的程序<blockquote><p>还要求c++编译器有权访问其他语言的编译器（包括c语言），并且兼容</p></blockquote></li></ul><blockquote><p>还可以链接其他语言的程序比如 extern “Ada”</p></blockquote><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><p>extern “C” 使用</p><pre><code class="lang-cpp">#ifdef __cplusplus//方式1extern &quot;C&quot; {#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus}#endif//方式2extern &quot;C&quot; size_t strlen(const char *);</code></pre><ul><li>当一个#include指示被放置在复合链接指示的花括号中，头文件中的所有普通函数声明都人未还是由链接指示的语言编写的。</li></ul><pre><code class="lang-cpp">extern &quot;C&quot; {    #include &lt;string.h&gt;}</code></pre><ul><li>链接指示可以嵌套</li></ul><h1 id="指向extern-“C”函数的指针"><a href="#指向extern-“C”函数的指针" class="headerlink" title="指向extern “C”函数的指针"></a>指向extern “C”函数的指针</h1><ul><li>使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示</li></ul><pre><code class="lang-cpp">//pf指向一个C函数，该函数接受一个int返回voidextern &quot;C&quot; void (*pf)(int);</code></pre><ul><li><font color="red">指向C函数的指针与指向C++函数的指针是不一样的类型</font>,不能用在初试化或赋值操作中</li></ul><pre><code class="lang-cpp">void (*pf1)(int); //指向c++函数void &quot;C&quot; void (*pf2)(int); //指向C函数pf1 = pf2;//error</code></pre><ul><li>链接指示对整个声明都有效<blockquote><p>链接指示不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效</p></blockquote></li></ul><pre><code class="lang-cpp">//f1是一个C函数，它的形参是一个指向C函数的指针extern &quot;C&quot; void fl(void(*)(int));</code></pre><ul><li>因为链接指示同时作用于声明语句中的所有函数，如果要给C++传入C函数指针，必须使用类型别名</li></ul><pre><code class="lang-cpp">//FC是一个指向C函数的指针extern &quot;C&quot; typedef void FC(int);//f2是一个C++函数，该函数的形参是指向C函数的指针void f2(FC *);</code></pre><ul><li>使用链接指示对函数进行定义，可以令C++函数在其他语言中调用<blockquote><p>但类型受到限制，比如c语言理解不了类</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; double calc(double dparm){    /*    ...    */}</code></pre><ul><li>链接指示对应的语言支持重置则<strong>可能</strong>可以重载<blockquote><p>c语言不支持重载，所以不能声明两个函数名相同的函数</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; void print(const char*);extern &quot;C&quot; void print(int);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 位域</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="不可移植性"><a href="#不可移植性" class="headerlink" title="不可移植性"></a>不可移植性</h1><ul><li><p>不可移植性：程序从一台机器转移到另一台机器时，通常需要重新编写该程序。</p><blockquote><p>比如算术类型的大小在不同机器上不一样</p></blockquote></li><li><p>相关概念</p><blockquote><p><a href>位域</a></p></blockquote></li></ul><blockquote><p><a href>Volatile</a></p><p><a href>链接指示:extern “C”</a></p></blockquote><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><pre><code class="lang-cpp">//位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，用于指定成员所占的二进制位数;Bit mode: 2;    // mode 占 2 位</code></pre><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，<font color="red">因为</font>带符号类型中的位域的行为将因具体实现而定</li><li><p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p></li><li><p>如果类内的连续定义的位域占用空间在同一个整数的相邻位，那么将会提供压缩，具体与机器相关</p></li><li><p>超过1位的位域通常使用内置的位运算符进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 数组 array vector</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-array-vector的区别"><a href="#数组-array-vector的区别" class="headerlink" title="数组 array vector的区别"></a>数组 array vector的区别</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/346838779" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/346838779</a></p></li><li><p>相同点：</p><ul><li>vector和array是容器；</li><li>三者均可以使用下表运算符对元素进行操作，即vector和array都针对下标运算符[]进行了重载；</li><li>三者在内存的方面都使用连续内存，即在vector和array的底层存储结构均使用数组 </li></ul></li></ul><ul><li>不同点：<ul><li>array 定义的时候必须定义数组的元素个数为常量表达式，而vector 可为变量表达式；</li><li>vector属于变长容器，即可以根据数据的插入删除重新构建容器容量；</li><li>但array和数组属于定长容量。vector和array在声明变量后，在生命周期完成后，会自动地释放其所占用的内存。对于数组，如果是采用new[]申请的内存空间，必须在使用delete[]完毕后手动释放其内存。</li><li>array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 sizeof()</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><ul><li>sizeof 运算符返回一条表达式或一个类型名字所占的字节数。<blockquote><p>满足右结合律<br>sizeof <em>p = sizeof(</em>p);</p></blockquote></li></ul><blockquote><p>返回值：size_t类型的常量表达式</p></blockquote><pre><code class="lang-cpp">//使用方法sizeof (type)sizeof expr //返回表达式结果类型的大小，不实际计算运算对象的值</code></pre><ul><li>不实际计算运算对象，即使对象是空指针也可以运行</li></ul><h2 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h2><ul><li>可以通过 作用域 符号来获取成员的大小</li></ul><pre><code class="lang-cpp">sizeof ClassName::ClassMember;//ClassName的ClassMember成员对应类型的大小</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对char或者类型为char的表达式，结果为1</li><li>对引用类型，结果为被引用对象所占空间的大小</li><li>对指针类型，结果为指针本身所占空间的大小</li><li>对解引用指针类型，结果为指向的对象所占空间的大小，指针不需要有效</li><li>对数组，结果为数组所占空间的大小，等价于数组中所有元素所占空间之和。sizeof不把数组转换为指针进行处理</li><li>对string和vector等，返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li></ul><h1 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h1><ul><li>这个宏会返回一个结构体成员相对于结构体开头的字节偏移量（<strong>经过结构对齐之后</strong>）<ul><li>type 结构体名称</li><li>结构体成员名称</li></ul></li><li>这个宏非常有用，由于结构体对齐的问题，整个结构体的大小并不是所有成员大小之和，往往要比他们的和大，（当然我们也可以执行结构体按一个字节进行对其），所以利用这个宏可以很好计算出每个结构体成员相对于结构体开头偏移的字节数。</li></ul><pre><code class="lang-cpp">#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;struct struct_test{    float fild1;    double fild2;    int fild3;    short fild4;    long long fild5;};int main(void){    printf(&quot;struct_test size is %lu \nfild1 offset %lu\nfild2 offset %lu \nfild3 offset %lu \nfild4 offset %lu \nfild5 offset %lu\n&quot;,                        sizeof(struct struct_test),                        offsetof(struct struct_test,fild1),                        offsetof(struct struct_test,fild2),                        offsetof(struct struct_test,fild3),                        offsetof(struct struct_test,fild4),                        offsetof(struct struct_test,fild5));    return 0;}/*struct_test size is 32 fild1 offset 0fild2 offset 8 fild3 offset 16 fild4 offset 20 fild5 offset 24*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 pragma pack(n)</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/</url>
      
        <content type="html"><![CDATA[<h1 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h1><p>设定结构体、联合体以及类成员变量以 n 字节方式对齐</p><h1 id="pragma-pack-n-使用"><a href="#pragma-pack-n-使用" class="headerlink" title="pragma pack(n) 使用"></a>pragma pack(n) 使用</h1><pre><code class="lang-cpp">#pragma pack(push)  // 保存对齐状态#pragma pack(4)     // 设定为 4 字节对齐struct test{    char m1;    double m4;    int m3;};#pragma pack(pop)   // 恢复对齐状态</code></pre><ul><li><p><a href="https://blog.csdn.net/aidem_brown/article/details/77540527" target="_blank" rel="noopener">补充</a></p><ul><li><h1 id="pragma-pack-n-作用：C编译器将按照n个字节对齐。"><a href="#pragma-pack-n-作用：C编译器将按照n个字节对齐。" class="headerlink" title="pragma pack (n)            作用：C编译器将按照n个字节对齐。"></a>pragma pack (n)            作用：C编译器将按照n个字节对齐。</h1></li><li><h1 id="pragma-pack-作用：取消自定义字节对齐方式。"><a href="#pragma-pack-作用：取消自定义字节对齐方式。" class="headerlink" title="pragma pack ()             作用：取消自定义字节对齐方式。"></a>pragma pack ()             作用：取消自定义字节对齐方式。</h1></li><li><h1 id="pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"><a href="#pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐" class="headerlink" title="pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"></a>pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐</h1></li><li><h1 id="pragma-pack-pop-作用：恢复对齐状态"><a href="#pragma-pack-pop-作用：恢复对齐状态" class="headerlink" title="pragma pack (pop)          作用：恢复对齐状态"></a>pragma pack (pop)          作用：恢复对齐状态</h1></li></ul></li><li><p>因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优，但是很多时候两者差别不大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 assert</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/</url>
      
        <content type="html"><![CDATA[<h1 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h1><ul><li><p>由预处理器管理，可以直接使用</p></li><li><p>断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。</assert.h></cassert></assert.h></p></li></ul><blockquote><p>无需std或using声明</p></blockquote><h1 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h1><ul><li>NDEBUG可以决定assert是否启用。但是注意要定义在assert声明之前。具体看以下连接</li></ul><blockquote><p><a href="https://www.zhihu.com/question/23075111" target="_blank" rel="noopener">https://www.zhihu.com/question/23075111</a>  </p></blockquote><ul><li>一些局部静态变量，可以用于调试</li></ul><p><img src="局部静态变量.png" alt></p><pre><code class="lang-cpp">//assert() 使用#define NDEBUG          // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL );    // assert 不可用</code></pre><h1 id="UE4-断言"><a href="#UE4-断言" class="headerlink" title="UE4 断言"></a>UE4 <a href="https://docs.unrealengine.com/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assertions/index.html" target="_blank" rel="noopener">断言</a></h1><ul><li>源码位置<blockquote><p>Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h</p></blockquote></li></ul><h2 id="check族"><a href="#check族" class="headerlink" title="check族"></a>check族</h2><ul><li><p>Check族系最接近基础 assert，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。</p></li><li><p>检查宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 以保留一个true值（通常为 1），使Check宏可在所有版本中运行。</p><blockquote><p>此法在以下情况中十分实用：怀疑Check宏中的代码正在修改值；发现了仅存在于在发布版本中且难以追踪的bug，但认为现有Check宏能找到这些bug。项目发布时应将 USE_CHECKS_IN_SHIPPING 设为默认值 0。</p></blockquote></li></ul><h2 id="verify族"><a href="#verify族" class="headerlink" title="verify族"></a>verify族</h2><ul><li><p>在大部分版本中，Verify族系的行为与Check族系相同。但即便在禁用Check宏的版本中，Verify宏也会计算其表达式的值。这意味着仅当该表达式需要独立于诊断检查之外运行时，才应使用Verify宏。</p></li><li><p>验证宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中完整运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 来保留一个true值（通常为 1），从而覆盖此行为。</p></li><li><p><strong>在所有其他情况下，Verify宏将计算其表达式，但不会停止执行或将文本输出到日志。</strong></p></li></ul><h2 id="ensure族"><a href="#ensure族" class="headerlink" title="ensure族"></a>ensure族</h2><ul><li><p>Ensure族系类似于Verify族系，但可在出现非致命错误时使用。若Ensure宏的表达式计算得出的值为false，引擎将通知崩溃报告器，但仍会继续运行。</p></li><li><p>为避免崩溃报告器收到太多通知，Ensure宏在每次引擎或编辑器会话中仅报告一次。若实际情况需要Ensure宏在每次表达式计算得值为false时都报告一次，则使用”Always”版本的宏。</p></li><li><p>Ensure宏在所有版本中计算其表达式的值，但仅在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中联系崩溃报告器。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 强制类型转换</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h1><blockquote><p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p></blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h2 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h2><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><p>bad_cast 使用</p><pre><code class="lang-cpp">try {      Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape);   }  catch (bad_cast b) {      cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what();  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 volatile</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile-ˈvɑː-lə-t̬əl"><a href="#volatile-ˈvɑː-lə-t̬əl" class="headerlink" title="volatile[ /ˈvɑː.lə.t̬əl/]"></a>volatile[ /ˈvɑː.lə.t̬əl/]</h1><pre><code class="lang-cpp">volatile int i = 10;</code></pre><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p><blockquote><p>volatile跟const类似可以跟指针，引用等组合</p></blockquote></li></ul><blockquote><p>带有volatile的成员函数只能被volatile的对象调用。</p></blockquote><ul><li>合成的拷贝对volatile对象无效<blockquote><p>如果没有定义复制构造函数，编译器会自动合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数会对成员逐个进行初始化，将新对象初始化为原对象的副本。</p></blockquote></li></ul><blockquote><p>合成的成员接受的形参类型是常量（非 volatile）引用，以此不能把一个非volatile引用绑定到一个volatile，因此需要自定义。</p></blockquote><pre><code class="lang-cpp">class Foo{public:    //从一个volatile对象进行拷贝    Foo(const volatile Foo&amp;);    //将一个volatile对象赋值给一个*非*Volatile对象    Foo&amp; operator=(volatile const Foo&amp;);    //将一个volatile对象赋值给一个volatile对象    //这个没问题volatile表示这个函数只能被volatile对象调用，而这是个符号重载，所以左值一定是volatile类型    Foo&amp; operator=(volatile const Foo&amp;) volatile;    //Foo类的其他部分//}</code></pre><ul><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">谈谈 C/C++ 中的 volatile</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 inline内联函数</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/</url>
      
        <content type="html"><![CDATA[<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>相当于把内联函数里面的内容写在调用内联函数处；//?</li><li>相当于不用执行进入函数的步骤，直接执行函数体；<blockquote><p>函数调用的时候，会在虚存中的栈区当前地址记录到帧指针寄存器，并生成该函数的上下文内容并执行相应的操作，调用结束后还会弹出该函数的数据，清理上下文信息。 </p></blockquote></li></ul><blockquote><p>感觉记得不准确，到时候重新看一下计算机系统中的函数调用过程</p><ul><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>inline 使用</p><pre><code class="lang-cpp">// 内联的声明可以不加inline// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) {/****/};// 类内定义，隐式内联class A {    int doA() { return 0; }         // 隐式内联}// 类外定义，需要显式内联class A {    int doA();}inline int A::doA() { return 0; }   // 需要显式内联</code></pre><h2 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h2><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h2><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>虚函数内联使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  using namespace std;class Base{public:    inline virtual void who()    {        cout &lt;&lt; &quot;I am Base\n&quot;;    }    virtual ~Base() {}};class Derived : public Base{public:    inline void who()  // 不写inline时隐式内联    {        cout &lt;&lt; &quot;I am Derived\n&quot;;    }};int main(){    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.who();    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr = new Derived();    ptr-&gt;who();    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr = nullptr;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 this指针</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h1><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针： //??<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 Static</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p></li></ul><blockquote><p>既可以是public也是private</p></blockquote><ul><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ul><blockquote><p>类的静态成员函数不包括this指针,所以静态成员函数不能设置为const</p><p><a href="https://blog.csdn.net/u010476094/article/details/38959265" target="_blank" rel="noopener">C++静态成员函数不能声明为const、volatile、virtual的原因 与 C++的对象模型</a></p></blockquote><ul><li>在类外定义静态成员，不用再重复声明static关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 const</title>
      <link href="/2021/04/08/C++/C++%E5%A4%8D%E4%B9%A0%20const/"/>
      <url>/2021/04/08/C++/C++%E5%A4%8D%E4%B9%A0%20const/</url>
      
        <content type="html"><![CDATA[<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><ul><li>定义：<font color="red">const用于定义一个变量，它的值不能被改变</font></li></ul><h2 id="const对象必须初始化"><a href="#const对象必须初始化" class="headerlink" title="const对象必须初始化"></a>const对象必须初始化</h2><ul><li><p>然而并不是所有的const对象都必须初始化</p></li><li><p>顶层const必须初始化，因为本身不能改变，不初始化根本没法用。而底层const(常量指针)可以不初始化</p><blockquote><p>参考:<a href="https://blog.csdn.net/qq_21034239/article/details/70492318" target="_blank" rel="noopener">https://blog.csdn.net/qq_21034239/article/details/70492318</a></p></blockquote></li><li><p>其实没有那么简单,const对象必须初始化值对bulit-in类型和POD类行有效</p><ul><li>built-in类型是内置类型包括算术类型和空类型(void)</li><li>注意的是指针和引用是符合类型<blockquote><p>参考:<a href="https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away" target="_blank" rel="noopener">https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away</a><br>(翻译:<a href="https://www.it1352.com/465052.html" target="_blank" rel="noopener">https://www.it1352.com/465052.html</a>)</p></blockquote></li></ul></li></ul><h2 id="const对象仅对当前文件有效"><a href="#const对象仅对当前文件有效" class="headerlink" title="const对象仅对当前文件有效"></a>const对象仅对当前文件有效</h2><ul><li><p>在编译时会进行预处理，将代码中所有带const限定符的变量用初始化的常亮替代。</p></li><li><p>const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同在不同文件中分别定义了独立的变量。</p></li><li><p>如果要在多个文件中共享const对象，在需要声明变量的时候前面加extern</p></li></ul><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ul><li>用于声明<ul><li>变量只能被定义一次，但可以被多次声明。</li></ul></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><a href="./">C/C++程序编译链接过程(还没写)</a></li></ul><h2 id="对const的引用"><a href="#对const的引用" class="headerlink" title="对const的引用"></a>对const的引用</h2><ul><li><p>别称<font color="red">常量引用</font></p></li><li><p>常量引用可以引用常量和非常量</p></li><li>非常量引用不能引用常量</li></ul><pre><code class="lang-cpp">const int a = 1;int d = 1;const int &amp;b = a;//trueconst int &amp;c = 1;//trueconst int &amp;d = d;//trueint &amp;e = a;//false;</code></pre><ul><li><font color="red">初始化常量引用的时候可以使用任意类型和任意表达式，只要可以转换成相应的引用类型。</font><blockquote><p>原因：因为在常量引用绑定初始值的时候，生成了一个临时变量。其事实上绑定的是临时变量。</p></blockquote></li></ul><blockquote><p>这样保证了const int&amp;绑定的是int型的表达式</p><p>还有值得注意的是一般情况下引用的类型必须与其所引用的对象的类型一致</p></blockquote><pre><code class="lang-cpp">double dval = 3.14;const int &amp;ri = dval;</code></pre><p>等价于</p><pre><code class="lang-cpp">double dval = 3.14;const int temp = dval;const int &amp;ri = temp;</code></pre><ul><li>根据上述也可以解释为什么非常量引用不能引用常量，因为这样初始化绑定的是临时量。<blockquote><p>非const变量引用const量，其实绑定了中间变量temp，因为是非const量所以可以改变这非const量，按引用来const量也应该改变，但其实改变的是中间量temp，const量不变，产生矛盾，c++把这种行为定义为非法。</p></blockquote></li></ul><h3 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h3><ul><li>const只约束当前绑定的对象的相关操作，而不管对象本身是不是常量。</li></ul><pre><code class="lang-cpp">int a  = 1;int &amp;b = a;const int &amp;c = a;b = 2;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2a = 3cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2c = 4cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;// error: assignment of read-only reference ‘c’</code></pre><h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><blockquote><p>对于指针常量和常量指针的定义C++ primer里定义的跟大多数教材不一样</p><h3 id="指针常量-pointer-to-const"><a href="#指针常量-pointer-to-const" class="headerlink" title="指针常量(pointer to const)"></a>指针常量(pointer to const)</h3><ul><li>从右往左读，它是一个指针，是一个指向常量类型的指针。说明不能改变他所指向对象的内容。但是可以改变它指向的对象。</li></ul></blockquote><pre><code class="lang-cpp">const int a = 1;const int b = 2;const int *c = &amp;a;*c = 1;//faslec = &amp;b;//true</code></pre><h3 id="常量指针-const-pointer"><a href="#常量指针-const-pointer" class="headerlink" title="常量指针(const pointer)"></a>常量指针(const pointer)</h3><ul><li>从右往左读，它是一个常量，说明指针的地址不能改变。但是可以改变它指向对象的内容。</li></ul><pre><code class="lang-cpp">int a = 1;int b = 2;int *const c = &amp;a; c= &amp;b;//falsec= 2;//true</code></pre><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><ul><li>顶层const说明指针本身是个常量-常量指针(const pointer)</li><li>底层const说明指针指向的对象是个常量-指针常量(pointer to const)</li></ul><h3 id="const对拷贝的影响"><a href="#const对拷贝的影响" class="headerlink" title="const对拷贝的影响"></a>const对拷贝的影响</h3><ul><li>顶层const对拷贝无影响</li><li>底层const对拷贝有影像<blockquote><p>拷贝两者有相同的底层const的，或者被拷贝数据可以从非常量转变为常量,才无影响</p></blockquote></li></ul><pre><code class="lang-cpp">int main(){   // 顶层const对拷贝无影响    {        // const int -&gt; int  yes        const int b = 1;        int a = b;        // int -&gt; const int yes        int c = 1;        const int d = c;    }     // &amp;int(int*) -&gt; int *const/const int*/const int *const    int a = 1;    int *const b = &amp;a; //ok    const int *c = &amp;a; //ok    const int *const d = &amp;a; //ok    // &amp;(const int) -&gt; int *const/const int*/const int *const    const int e = 1;    int *const f = &amp;e; //error 没有相同的底层const    const int *g = &amp;e; //ok    const int *const h = &amp;e; //ok  &amp;e可以转换成const int *const    //(int cont*) -&gt; int *const/const int*/const int *const    int i = 1;    int *const  j= &amp;i;    int *const  k = j; //ok    const int*  l = j; //ok    const int *const m = j; //ok    return 0;}</code></pre><ul><li>总结(我自己有点绕晕了,总结一下)<blockquote><p>1) 对于非指针类型之间的拷贝,没有限制 const int &lt;-&gt; int</p></blockquote></li></ul><blockquote><p>2) 对于指针之间的拷贝。右值没有底层const,总合法;右值有底层const,则看左值有没有底层const,有则合法,没有则不合法。   </p><ul><li>常量对象不能赋值给非常量引用,常量对象不能赋值给非常量指针</li></ul><p>3) 对于指针和非指针之间，类型不同不合法;</p></blockquote><h2 id="constexpr和常量表达式-c-11"><a href="#constexpr和常量表达式-c-11" class="headerlink" title="constexpr和常量表达式[c++11]"></a>constexpr和常量表达式[c++11]</h2><ul><li>常量表达式(const expression)是指不会改变并且在编译过程就能得到计算结果的表达式<blockquote><p>数据类型是常量并且初始值是常量或字面值或两者混合的是常量表达式。</p></blockquote></li></ul><pre><code class="lang-cpp">const int a = 1; //trueconst int b = a+1; //trueint c = 1; //falseconst int d = get_d(); //false，该值在编译时才能获得，所以不是常量表达式</code></pre><h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><ul><li>constexpr定义的变量必须要用常量表达式初始化</li><li>constexpr是顶层const，即其本身为常量</li><li>对于字面量<blockquote><p>算术类型，引用和指针，字面值常量类（包括枚举类型），枚举都是字面值<br>自定义类，IO库，string类等不算字面值</p></blockquote></li></ul><h3 id="constexpr-指针"><a href="#constexpr-指针" class="headerlink" title="constexpr 指针"></a>constexpr 指针</h3><ul><li>constexpr指针只能指向地址固定的变量，比如全局变量，staitc变量</li></ul><pre><code class="lang-cpp">constexpr int *p1; //顶层constconst int *p2;  //底层constint *const p3;  //顶层constconstexpr const int *p4;//&lt;=&gt;const int *const p5;</code></pre><h2 id="const补充"><a href="#const补充" class="headerlink" title="const补充"></a>const补充</h2><p><a href="https://interview.huihut.com/#/?id=cc" target="_blank" rel="noopener">const 使用</a></p><pre><code class="lang-cpp">// 类class A{private:    const int a;                // 常对象成员，只能在初始化列表赋值public:    // 构造函数    A() : a(0) { };    A(int x) : a(x) { };        // 初始化列表    // const可用于对重载函数的区分    int getValue();             // 普通成员函数    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值};void function(){    // 对象    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量    const A a;                  // 常对象，只能调用常成员函数    const A *p = &amp;a;            // 指针变量，指向常对象    const A &amp;q = a;             // 指向常对象的引用    // 指针    char greeting[] = &quot;Hello&quot;;    char* p1 = greeting;                // 指针变量，指向字符数组变量    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量}// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char* Var);         // 参数指针所指内容为常量void function3(char* const Var);         // 参数指针为常量void function4(const int&amp; Var);          // 引用参数在函数内为常量// 函数返回值const int function5();      // 返回一个常数const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++整理</title>
      <link href="/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/"/>
      <url>/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="析构函数为什么最好是虚函数"><a href="#析构函数为什么最好是虚函数" class="headerlink" title="析构函数为什么最好是虚函数"></a><span id="destructor">析构函数为什么最好是虚函数</span></h2><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li><p>析构函数： 父类的后执行，子类的先执行</p></li><li><p>附加</p><blockquote><p>默认构造函数（无参构造函数），有参构造函数，拷贝构造函数，级别依次递增。当我们提供了后面的，前面的编译器就不会提供了。</p></blockquote></li></ul><h2 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/103384358" target="_blank" rel="noopener">C++ 类在内存中的存储方式(一)</a></li></ul><h2 id="new-delete-与new-delete之间的差别，以及具体实现"><a href="#new-delete-与new-delete之间的差别，以及具体实现" class="headerlink" title="new[]/delete[]与new/delete之间的差别，以及具体实现"></a>new[]/delete[]与new/delete之间的差别，以及具体实现</h2><ul><li><a href="https://wetest.qq.com/lab/view/318.html" target="_blank" rel="noopener">c++ new delete 常踩的坑</a></li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul><li><p>引用必须被初始化，指针不必。</p></li><li><p>引用初始化以后不能被改变，指针可以改变所指的对象。</p></li><li><p>不存在指向空值的引用，但是存在指向空值的指针。</p></li></ul><h2 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h2><blockquote><p>不同的对象调用同一个函数，表现出不同的状态，称为多态。</p></blockquote><ul><li><p>一是增加程序的灵活性</p><blockquote><p>不同继承自父类的子类，对同一函数可以有不同的表现</p></blockquote></li><li><p>二是增加程序的可扩展性</p><blockquote><p>新增子类，只需修改需要重写的函数</p></blockquote></li></ul><h2 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new/delete和malloc/free的区别"></a>new/delete和malloc/free的区别</h2><ul><li><a href="https://blog.csdn.net/nyist_zxp/article/details/80810742" target="_blank" rel="noopener">C++ new和malloc的区别</a></li></ul><h2 id="define的底层实现"><a href="#define的底层实现" class="headerlink" title="#define的底层实现"></a>#define的底层实现</h2><ul><li><h1 id="define是一条预处理命令，它的作用就是定义宏。"><a href="#define是一条预处理命令，它的作用就是定义宏。" class="headerlink" title="define是一条预处理命令，它的作用就是定义宏。"></a>define是一条预处理命令，它的作用就是定义宏。</h1></li><li><p>宏并不是函数,宏并不是语句,宏并不是类型定义。</p></li><li><p>预处理时进行宏展开，把宏名替换成文本，这个文本可以是字符串，代码等。</p></li></ul><h2 id="const-int-p和int-const-p的区别"><a href="#const-int-p和int-const-p的区别" class="headerlink" title="const int p和int const p的区别"></a>const int <em>p和int</em> const p的区别</h2><ul><li><p>对于const和指针结合的变量，要从右往左看</p></li><li><p>int* const p 是常量指针，指的是p本身是个常量，p的值不能边，但p指向的内容可以改变，这是个顶层cosnt</p></li><li><p>const int *p 是指针常量，指的是指向常量的指针，p的值能改变，p指向的内容不能改变，这个个底层const</p></li></ul><h2 id="c-的编译过程"><a href="#c-的编译过程" class="headerlink" title="c++的编译过程"></a>c++的编译过程</h2><ul><li>预处理、编译、汇编、链接<blockquote><p><a href="https://www.cnblogs.com/ericling/articles/11736681.html" target="_blank" rel="noopener">C/C++完整编译过程详解</a></p></blockquote></li></ul><h2 id="python为什么效率低"><a href="#python为什么效率低" class="headerlink" title="python为什么效率低"></a>python为什么效率低</h2><ul><li>动态语言：运行时可以改变程序结构</li><li>解释运行：先转换为字节码再解释字节码</li><li>一切都是对象：需要维护引用计数<!-- * GIL：全局解释器锁 --></li><li>垃圾回收：自动垃圾回收中断当前程序</li></ul><h2 id="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"><a href="#定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector" class="headerlink" title="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"></a>定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector</h2><ul><li>不能 不是POD类型 ，memcpy只能进行浅拷贝 </li></ul><h2 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h2><ul><li><p>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</p><blockquote><p><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></p></blockquote></li><li><p><a href="#destructor">析构函数为什么最好是虚函数</a></p></li></ul><h2 id="调试的时候打断点的原理"><a href="#调试的时候打断点的原理" class="headerlink" title="调试的时候打断点的原理"></a>调试的时候打断点的原理</h2><p><a href="https://zhuanlan.zhihu.com/p/34003929" target="_blank" rel="noopener">调试程序时，设置断点的原理是什么？</a></p><h2 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h2><ul><li><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></li></ul><h2 id="vector-list区别和相关内容"><a href="#vector-list区别和相关内容" class="headerlink" title="vector,list区别和相关内容"></a>vector,list区别和相关内容</h2><p><a href="https://zhuanlan.zhihu.com/p/270527588" target="_blank" rel="noopener">C++ vector和list的区别</a></p><h2 id="emplace-back和push-back有什么区别"><a href="#emplace-back和push-back有什么区别" class="headerlink" title="emplace_back和push_back有什么区别"></a>emplace_back和push_back有什么区别</h2><p><a href="https://zhuanlan.zhihu.com/p/183861524" target="_blank" rel="noopener">C++姿势点: push_back和emplace_back</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 11.旋转数组的最小数字</title>
      <link href="/2021/03/01/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2021/03/01/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </li></ul><blockquote><p>输入：[3,4,5,1,2]<br>输出：1</p><p>输入：[2,2,2,0,1]<br>输出：0</p></blockquote><h1 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h1><ul><li>时间复杂度:O(N)</li><li>空间复杂度:o(1)</li></ul><h1 id="方法二：二分"><a href="#方法二：二分" class="headerlink" title="方法二：二分"></a>方法二：二分</h1>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer刷题笔记"><a href="#剑指Offer刷题笔记" class="headerlink" title="剑指Offer刷题笔记"></a>剑指Offer刷题笔记</h1><ul><li>2021年2月末，为准备研三的秋招，开始算法题的康复运动<blockquote><p>(“&hearts;” 表示刷的时候做出了最优解)</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>#</th><th>Title</th><th>Solution</th><th>Tag</th><th>Difficulty</th><th>最优时间复杂度&amp;&amp;空间复杂度</th><th>最优解</th></tr></thead><tbody><tr><td>剑指 Offer 03</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></td><td><a href="https://sanctorum003.github.io/2021/02/26/LeetCode/[%E5%89%91%E6%8C%87Offer]%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>数组 &amp;&amp; 哈希表</td><td>Easy</td><td>O(N) &amp;&amp; O(1)</td><td></td></tr><tr><td>剑指 Offer 09</td><td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></td><td><a href="https://sanctorum003.github.io/2021/02/28/LeetCode/[%E5%89%91%E6%8C%87Offer]%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">C++</a></td><td>栈 &amp;&amp; 设计</td><td>Hard</td><td></td><td></td></tr><tr><td>剑指 Offer 11</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></td><td><a href="https://sanctorum003.github.io/2021/03/01/LeetCode/[%E5%89%91%E6%8C%87Offer]%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>二分查找</td><td>Easy(Hard)</td><td>O(lgN) &amp;&amp; O(1)</td><td></td></tr><tr><td>303</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Easy</td><td>建立O(N) &amp; 调用O(1)</td><td></td></tr><tr><td>304</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">二维区域和检索 - 矩阵不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td>&hearts;</td></tr><tr><td>338</td><td><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特网计数</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td></td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a></td><td><a href>c++</a></td><td>Medium</td><td>DP &amp;&amp; 二分</td><td>O(NlogN) &amp;&amp; O(N)</td><td></td></tr><tr><td>354</td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">俄罗斯套娃信封问题</a></td><td><a href>c++</a></td><td>Hard</td><td>DP &amp;&amp; 二分</td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 09.用两个栈实现队列</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 06.从尾到头打印链表</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><h1 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h1><ul><li>正序输出 + 翻转数组</li></ul><h1 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h1><ul><li>正序输入栈 + 从栈输入Vector</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><pre><code class="lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head) {        if(!head) return {};        vector&lt;int&gt; t = reversePrint(head-&gt;next);        t.push_back(head-&gt;val);        return t;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 07.重建二叉树</title>
      <link href="/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></li></ul><h1 id="分治（不带index辅助）"><a href="#分治（不带index辅助）" class="headerlink" title="分治（不带index辅助）"></a>分治（不带index辅助）</h1><ul><li><p>这个自己写的，空间复杂度较高</p><pre><code class="lang-cpp">/*** Definition for a binary tree node.* struct TreeNode {*     int val;*     TreeNode *left;*     TreeNode *right;*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}* };*/class Solution {public:  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {      if(preorder.empty() || inorder.empty()) return NULL;      //1. find root                              3      //2. split into left &amp; right                9 | 3 | 15 20 7      //3. 分治      int rootVal = preorder[0];      TreeNode* root = new TreeNode(rootVal);      vector&lt;int&gt;::iterator inorderRootPos;      inorderRootPos = find(inorder.begin(),inorder.end(),rootVal);      vector&lt;int&gt; inorderLeft(inorder.begin(),inorderRootPos);//注意范围      vector&lt;int&gt; inorderRight(inorderRootPos+1,inorder.end());      // //  inorder  L ROOT R      // //  preorder Root L R      int leftElemtNum = inorderRootPos-inorder.begin();      vector&lt;int&gt; preorderLeft(preorder.begin()+1,preorder.begin()+leftElemtNum+1);      vector&lt;int&gt; preorderRight(preorder.begin()+leftElemtNum+1,preorder.end());      TreeNode* LeftChild = buildTree(preorderLeft,inorderLeft);      TreeNode* RightChild = buildTree(preorderRight,inorderRight);      root-&gt;left = LeftChild;      root-&gt;right = RightChild;      return root;  }};</code></pre></li><li>时间复杂度:O(N)</li><li>空间复杂度:O(N+h)=O(N) [h为构造的树的高度,这里还有多次的创建数组的空间]</li></ul><h1 id="分治（利用index优化空间复杂度）"><a href="#分治（利用index优化空间复杂度）" class="headerlink" title="分治（利用index优化空间复杂度）"></a>分治（利用index优化空间复杂度）</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Tree </tag>
            
            <tag> Divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 05.替换空格</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2005.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2005.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a></li></ul><h1 id="建立新字符串"><a href="#建立新字符串" class="headerlink" title="建立新字符串"></a>建立新字符串</h1><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(n)</li></ul><h1 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h1><ul><li>利用string::resize()</li></ul><pre><code class="lang-cpp">class Solution {public:    string replaceSpace(string s) {        int len = s.size();        int cnt = 0;        for(const auto&amp; e : s)        {            if(e == &#39; &#39;)                cnt++;        }        s.resize(len+cnt*2);        int i = len-1;        int j = s.size()-1;        while(i &lt; j)        {            if(s[i] != &#39; &#39;)                s[j--] = s[i--];            else            {                s[j--] = &#39;0&#39;;                s[j--] = &#39;2&#39;;                s[j--] = &#39;%&#39;;                i--;            }        }        return s;    }};</code></pre><ul><li>时间复杂度:O(2n)</li><li>空间复杂度:O(t)[t为s中字符的数量]</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> string </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 04.二维数组中的查找</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2004.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2004.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></li></ul><h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><ul><li>时间复杂度:O(MN)</li><li>空间复杂度:O(1)</li></ul><h1 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h1><ul><li>解题思路推荐看这个:<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</a></li></ul><pre><code class="lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {        int i = matrix.size()-1,j = 0;        while(i &gt;= 0 &amp;&amp; j&lt; matrix[0].size())        {            if(matrix[i][j] &gt; target)                i--;            else if(matrix[i][j] &lt; target)                j++;            else                 return true;        }        return false;    }};</code></pre><ul><li>时间复杂度:O(m+n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Array </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 03.数组中重复的数字</title>
      <link href="/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/02/26/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></li></ul><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><pre><code class="lang-cpp">class Solution {public:    int findRepeatNumber(vector&lt;int&gt;&amp; nums) {        map&lt;int,int&gt; m;        for(const auto&amp; n : nums)        {            if(m[n] == 0) m[n]++;            else return n;        }        return -1;    }};</code></pre><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h1 id="方法二：原地置换"><a href="#方法二：原地置换" class="headerlink" title="方法二：原地置换"></a>方法二：原地置换</h1><pre><code class="lang-cpp">class Solution {public:    void swap(int&amp; a,int&amp; b)    {        a = a^b;        b = a^b;        a = a^b;    }    int findRepeatNumber(vector&lt;int&gt;&amp; nums) {        int i = 0;        while(i &lt; nums.size())        {             if(i != nums[i])            {                if(nums[i] == nums[nums[i]]) return nums[i];                   swap(nums[i],nums[nums[i]]);            }            else                ++i;        }        return -1;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> HashMap </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集总结</title>
      <link href="/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h1><pre><code class="lang-cpp">const int N=30005;int fa[N],s[N],h[N];void Init(int n){    for(int i=1;i&lt;=n;++i)        fa[i]=i,ran[i]=0;    //刚开始每个人都是自己的老大，每个人都没有手下}int Find(int x){    return x==fa[x]?x:fa[x]=Find(fa[x]);}void Merge(int x,int y){    int fx=Find(x);    int fy=Find(y);    if(fx==fy)  return;    if(ran[fx]&lt;ran[fy])        fa[fx]=fy;    else    {        fa[fy]=fx;        if(ran[fx]==ran[fy])            ran[fx]++;    }}</code></pre><ul><li>模板引用来源:<a href="https://www.cnblogs.com/StungYep/p/12254027.html" target="_blank" rel="noopener">https://www.cnblogs.com/StungYep/p/12254027.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5.最长回文子串</title>
      <link href="/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的关键点：初始条件和状态转换方程。<br>设：s[l][r]表示字符串中下标L到R的位置<br>则有如下转态转换方程<br>    s[l][r] = s[l+1][r-1] &amp;&amp; (s[l] == s[r])<br>那初始状态呢<br>    s[l][l] = ture<br>    s[l][l+1] = (s[l] == s[l+1])</p><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        vector&lt;vector&lt;bool&gt;&gt; v(s.size(),vector&lt;bool&gt;(s.size(),false));        string res;        for(int i = 0; i &lt; v.size();++i)        {            for(int j = i; j &lt; v.size();++j)            {                if(i == j)                    v[i][j] = true;                else if(j-i == 1)                    v[i][j] = s[i] == s[j] ? true : false;            }        }        //这里需要注意一点的是从后往前遍历，因为v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);会优先用到数组尾部的数据        for(int i = v.size()-1; i &gt;= 0;--i)        {            for(int j = i; j &lt; v.size();++j)            {                if(j-i &gt; 1)                    v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);                if(v[i][j] == true &amp;&amp; j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);              }        }        return res;    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3.无重复字符的最长子串</title>
      <link href="/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_longest-substring-without-repeating-characters.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>子串和子序列的区别<ul><li>子串是是连续的</li><li>子序列可以不是连续的<ul><li>比如”pwwkew”中,”pwke”是最长子序列,”wke”是最长子串</li></ul></li></ul></li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>通过两个指针$i$,$j$，维护一个区间，保证这个区间的子串中无重复元素。</li><li>每次迭代的时候$j$向后移动，判断当前j指针的元素在上一次迭代的区间中是否存在。<ul><li>不存在，$i$不动</li><li>存在，$i = find_pos(nums[j]) + 1$</li></ul></li><li>每次迭代时更新最长无重复的子串长度。</li></ul><p>对于在元素中查询方式有以下三种方法。</p><h3 id="朴素循环"><a href="#朴素循环" class="headerlink" title="朴素循环"></a>朴素循环</h3><ul><li><p>在判断是否有重复元素时遍历一遍区间内的元素</p><pre><code class="lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {      if(s.size() == 0)  return 0;      int i = 0;      int j = 0;      int res = 0;      do      {          for(int k =  i; k &lt;j ; ++k)          {              if(s[k] == s[j])              {                  i = k+1;                  break;              }          }          res = max(res,j-i+1);           ++j;      }while(i &lt; s.size() &amp;&amp; j &lt; s.size());      return res;  }};</code></pre></li><li>时间复杂度:$O(n^{2})$</li><li>空间复杂度:$O(1)$</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="eg.png" alt></p><ul><li>这里需要注意判断元素所对应的下标是否还在当前滑动窗口范围内</li></ul><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        unordered_map&lt;char,int&gt; m;        int i =0;        int j = 0;        int res = 0;        do        {            if( m.find(s[j])!= m.end() &amp;&amp; m[s[j]] &gt;= i ) //这里主要要求找到的值要大于等于i            {                i = m[s[j]]+1;                m[s[j]] = j;            }            else             {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:unordered_map:O(n)</li><li>空间复杂度:O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        int m[128]; //利用ascii来存储下标        fill(m,m+128,-1);        int i =0;        int j = 0;        int res = 0;        do        {            if(m[s[j]] &gt;= i)  //这里主要要求找到的值要大于等于i            {                              i = m[s[j]] + 1;                m[s[j]] = j;            }            else            {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> DoublePointer </tag>
            
            <tag> String </tag>
            
            <tag> SlidingWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_two-sum.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>数组无序</li><li>返回<strong>下标</strong></li></ul></li></ul><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><ul><li><p>二重循环</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; v;      for(int i = 0; i &lt; nums.size();++i)          for(int j = i+1; j &lt; nums.size();++j)              if(nums[i] + nums[j] == target)              {                  v.push_back(i);                  v.push_back(j);              }      return v;  }};</code></pre></li><li><p>时间复杂度:O($n^{2}$)</p></li><li>空间复杂度 O(1)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>排序($nlog(n)$)之后使用双指针($O(n)$)找出所求的值</li><li>所求的是原数组中的下标，所以排序前复制一份。之后利用找到的值来找到下标</li><li><p>需要注意从原数组找下标时，下标大小和数值重复的问题。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; tmp = nums;      sort(tmp.begin(),tmp.end());      int i = 0;      int j = tmp.size()-1;      while(i &lt; j)      {          if(tmp[i] + tmp[j] &gt; target) --j;          else if(tmp[i] + tmp[j] &lt; target) ++i;          else break;      }      bool bi = false;      bool bj = false;      for(int k = 0; k &lt; nums.size();++k)      {          if(!bi &amp;&amp; nums[k] == tmp[i] )          {              i=k;              bi = true;              continue;          }          if(!bj &amp;&amp; nums[k] == tmp[j])          {              j = k;              bj = true;              continue;          }      }      if(i &gt; j)          swap(i,j);      return {i,j};  }};</code></pre></li><li><p>时间复杂度: $O(nlog(n) + n + n) = O(nlog(n))$</p></li><li>空间复杂度: $O(n)$</li></ul><h2 id="两遍哈希"><a href="#两遍哈希" class="headerlink" title="两遍哈希"></a>两遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。<ul><li>这里会注意到一点，可能数组中的值会重复，导致一个值关联多个下标，而实际代码中的结果会使得最后一个重复值关联相应下标。</li><li>但是这并不会影响结果。如此考虑，因为<strong>结果唯一</strong>，所以结果要取重复值，则数组中该结果对应的重复值有且仅有2个，不然不满足结果唯一。</li><li>所以在查找的时候，用的是原数组进行迭代，所以重复的第一个值要找的就是重复的后一个值，所以上述正好满足我们的要求</li></ul></li><li><p>利用原数组进行查找 target - nums[i] 是否在map中,map::find为O(log(n))，其基于红黑树。unordered_map::find()为O(1),其基于哈希表</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)          m[nums[i]] = i;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)              return {i,m[target-nums[i]]};      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(n)</li></ul><h2 id="一遍哈希"><a href="#一遍哈希" class="headerlink" title="一遍哈希"></a>一遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。</li><li><p>在这里直接循环原数组，查找map中否有target - nums[i]。没有的话加入map中。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end())          {              return {m[target-nums[i]],i};          }          else          {              m[nums[i]] = i;          }      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Marching</title>
      <link href="/2020/01/10/CG/Render/Render-RayMarching/"/>
      <url>/2020/01/10/CG/Render/Render-RayMarching/</url>
      
        <content type="html"><![CDATA[<p><img src="raytrace.png" alt="from &quot;Ray tracing&quot; on Wikipedia"></p><ul><li>Ray Marching和Ray Tracing有一些相似之处。看上图，可以看出来他们都说从摄像机的位置开始,遍历屏幕上的所有像素，通过从摄像机穿过像素的射线来计算出该点像素的颜色。</li><li>对于Ray Marching来说，通过使用SDF函数来判断是否碰撞到物体。SDF函数就是signed distance function，比如说对于球体。  </li></ul><script type="math/tex; mode=display">SDF(P)=||\vec{p}-\vec{c}||-r \left\{\begin{aligned}< & 0, 在球体内部 \\= & 0, 在球体边上 \\> & 0, 在球体外部\end{aligned}\right.</script><ul><li>上述就是一个球体的SDF函数,而求得的SDF函数的值就是点P到球体的最短距离。</li></ul><script type="math/tex; mode=display">p = eye + depth * raydirection</script><ul><li>对于测试点P的depth来说,增加SPF(p)的大小肯定是不会发生碰撞的。然后考虑到如果该射线最终能撞到物体,那么depth肯定是一个固定值,而如果不撞到其他物体的话,那么depth = + $\infty$。所以需要设置p的最小值(初试值),最大值(超过这个值认为没有hit),depth的最小值(小于这个值认为ray marching结束),ray marching步长(超过这个值认为ray marching结束)</li></ul><p><img src="spheretrace.jpg" alt="From GPU Gems 2: Chapter 8."></p><ul><li>可以拿上图举例,从点P0开始,计算场景中所有SDF的值,并取最小值,那么depth加上这个值肯定不会发生碰撞。</li></ul><script type="math/tex; mode=display">SDF(p) = min(SDF_{1}(p),SDF_{2}(p),...)</script><pre><code class="lang-cpp">//Shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){    float tp1 = CircleSDF(vec3(0,0,0),1.f,tp);    float tp2 = CircleSDF(vec3(1,1,0),1.f,tp);    return min(tp1,tp2);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    //因为屏幕的原点在中心,而fragCoord的原点在左上角，进行变换    dir.xy = fragCoord - size/2.f;    //通过fov来设置视野范围       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    //注意一定要标准化    return normalize(dir);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &lt; MAX_DIS - E)    {        fragColor = vec4(1,0.75,0.79,1.f);        return;    }      fragColor = vec4(0.f,0.f,0.f,1.f); }</code></pre><h1 id="表面法线"><a href="#表面法线" class="headerlink" title="表面法线"></a>表面法线</h1><ul><li>梯度的值 == 法线的值</li></ul><script type="math/tex; mode=display">∇f=( \frac{​∂f}{​∂x},\frac{​∂f}{​∂y},\frac{​∂f}{​∂z})</script><ul><li>上面的式子可以用下面的式子来近似<blockquote><p>But no need to break out the calculus chops here. Instead of taking the real derivative of the function, we’ll do an approximation by sampling points around the point on the surface, much like how you learned to calculate slope in a function as over rise-over-run before you learned how to do derivatives.</p></blockquote></li></ul><script type="math/tex; mode=display">\vec{n} = \left[ \begin{matrix}​f(x+ε,y,z)−f(x−ε,y,z) \\​f(x,y+ε,z)−f(x,y−ε,z) \\​f(x,y,z+ε)−f(x,y,z−ε) \\\end{matrix} \right]​​</script><pre><code class="lang-cpp">//shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){     return CircleSDF(vec3(0,0,0),1.f,tp);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    dir.xy = fragCoord - size/2.f;       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    return normalize(dir);}vec3 estimateNormal(vec3 p,float EPSILON) {    return normalize(vec3(        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))    ));}vec3 GetColor(vec3 p){    return estimateNormal(p,0.01f);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &gt; MAX_DIS - E)    {        fragColor = vec4(0.f,0.f,0.f,1.f);        return;    }    fragColor = vec4(GetColor(eye + depth * dir),1.f);}</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/" target="_blank" rel="noopener">http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a><br><a href="https://zhuanlan.zhihu.com/p/36759481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36759481</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-CoordinateSystems</title>
      <link href="/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/"/>
      <url>/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Transformations</title>
      <link href="/2019/12/04/CG/Opengl/LearnOpengl-Transformations/"/>
      <url>/2019/12/04/CG/Opengl/LearnOpengl-Transformations/</url>
      
        <content type="html"><![CDATA[<ul><li>单位向量 $\hat{n}$</li></ul><h1 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h1><ul><li>它允许我们在3D向量上进行位移</li><li>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ul><li>用于避免万向结死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Textures</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Textures/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Textures/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h1><ul><li><p>纹理坐标中,左下角位(0,0),右上角位(1,1)<br><img src="tex_coords.png" alt></p></li><li><p>使用纹理坐标获取纹理颜色叫做<strong>采样(Sampling)</strong></p></li></ul><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><ul><li>原文讲的够好了<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></li></ul><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><ul><li><p>产生原因:纹理坐标可以取任意浮点值，所以纹理元素与纹理坐标无法一一对应</p></li><li><p>纹理元素(Texel)</p></li></ul><blockquote><p>而纹素是纹理图片空间的基本单元，可以看成是纹理的组成“像素”</p></blockquote><ul><li>纹理过滤（Texture Filtering)</li></ul><blockquote><p>一个像素一般不会正好对应于一个纹元（texel)。所以像素的颜色无法直接得到，需要经过一定的运算，这个过程就是纹理过滤。<br>参考网址：<a href="https://zhuanlan.zhihu.com/p/91208143" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91208143</a></p></blockquote><ul><li>有两种常见的纹理过滤的方式:GL_NEAREST和GL_LINEAR</li></ul><blockquote><p>邻近过滤:选择中心点最接近纹理坐标的那个像素<br>线性过滤:基于纹理坐标附近的纹理像素，计算出一个插值。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。<br>具体项目可见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a>  </p></blockquote><ul><li>如何设置过滤方式</li></ul><pre><code class="lang-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><blockquote><p>GL_TEXTURE_MAG_FILTTER:纹理元素的数量 &lt; 图元像素的数量。比如texture为256*256，图元为512*512。相当于纹理元素被放大，一个纹理元素的颜色决定多个图元像素的颜色</p><p>GL_TEXTURE_MIN_FILTER 纹理元素的数量 &gt; 图元像素的数量。比如texture为512*512,图元为256*256。相当于纹理被缩小，一个图元像素的颜色由多个纹理像素决定。</p></blockquote><h1 id="多级渐远纹理-Mipmap"><a href="#多级渐远纹理-Mipmap" class="headerlink" title="多级渐远纹理(Mipmap)"></a>多级渐远纹理(Mipmap)</h1><ul><li><p>产生原因:我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段(像素)，OpenGL从高分辨率纹理中为这些片段（像素）获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段（像素）只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p></li><li><p>多级渐远纹理：简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一</p></li><li><p>距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 </p></li><li><p>Mipmap的例子如下<br><img src="mipmaps.png" alt></p></li><li><p>可以在GL_TEXTURE_MIN_FILTER中使用多级渐远纹理过滤选项，但是在GL_TEXTURE_MAG_FILTER中无法使用，纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p></li></ul><h1 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><pre><code class="lang-cpp">int width, height, nrChannels;//地址、宽度、高度、颜色通道的个数、期望通道数（得到的data中的数据的通道数目）unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</code></pre><h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><pre><code class="lang-cpp">unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    //用于生成2D纹理    // 参数一：设置纹理目标，一般为GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D    // 参数二：Mipmap级别,手动设置每个的话这里设0    // 参数三：纹理存储格式    // 参数四：宽度    // 参数五：长度    // 0    // 参数六：image的的存储格式    // 参数七：图像数据    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    //为当前绑定的纹理自动生成所有需要的多级渐远纹理。    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}//释放图像的内存stbi_image_free(data);</code></pre><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><ul><li>在定点数组中添加纹理坐标</li><li>在VS中声明纹理坐标属性</li><li>利用glVertexAttribPointer给定点数组中的纹理坐标解释，并启用该定点属性</li><li>在PS中获取VS中的纹理坐标，声明sampler2D变量</li><li>glActiveTexture激活对应的纹理单元</li><li>利用texture(ourTexture, TexCoord)使用之前设置的纹理参数对相应的颜色值进行采样</li></ul><h1 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h1><ul><li>uniform sampler2D MySampler存放纹理的位置称为纹理单元。</li><li>opengl有GL_TEXTURE0 - GL_TEXTURE15总共16个纹理单元。</li><li>使用方式如下</li></ul><pre><code class="lang-cpp">// 设置着色器采样器使用哪个纹理单元ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置</code></pre><pre><code class="lang-cpp">//激活纹理单元glActiveTexture(GL_TEXTURE0);//绑定时会自动使用当前激活的纹理单元 glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);</code></pre><ul><li>纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</li></ul><h1 id="图片翻转问题"><a href="#图片翻转问题" class="headerlink" title="图片翻转问题"></a>图片翻转问题</h1><ul><li>纹理可能上下颠倒，这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。</li></ul><pre><code class="lang-cpp">//解决方法stbi_set_flip_vertically_on_load(true);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Shaders</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Shaders/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Shaders/</url>
      
        <content type="html"><![CDATA[<ul><li><p>很多都是概念性的东西，教程里整理的很好<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1</a></p></li><li><p>layout (location = 0)</p><blockquote><p>为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。</p></blockquote></li><li><p>如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）</p></li></ul><h1 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h1><ul><li>uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</li><li>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4Live_RenderProcess</title>
      <link href="/2019/10/08/CG/UE4/UE4Live-RenderProcess/"/>
      <url>/2019/10/08/CG/UE4/UE4Live-RenderProcess/</url>
      
        <content type="html"><![CDATA[<p>视频地址 <a href="https://www.bilibili.com/video/av35615021?t=3626" target="_blank" rel="noopener">https://www.bilibili.com/video/av35615021?t=3626</a><br>相关图片 <a href="https://blog.csdn.net/jli_family/article/details/86584208" target="_blank" rel="noopener">https://blog.csdn.net/jli_family/article/details/86584208</a></p><p><img src="UE4Live_RenderProcess.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloTriangle</title>
      <link href="/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/"/>
      <url>/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/</url>
      
        <content type="html"><![CDATA[<ul><li><p>通过opengl绘制图形，需要通过opengl的渲染管线，这一过程实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p></li><li><p>对于利用opengl画出一个三角形，归纳为以下步骤</p></li></ul><h1 id="build-and-compile-our-shader-program"><a href="#build-and-compile-our-shader-program" class="headerlink" title="build and compile our shader program"></a>build and compile our shader program</h1><p><img src="Opengl_ShaderCreate.png" alt></p><ul><li>在OpenGL的渲染管线中，我们必须要配置VS和FS(PS)两个着色器,可以选择配置GS。</li></ul><pre><code class="lang-cpp">//创建着色器的方式/***  * 创建一个指定类型的着色器，返回指向这个着色器的在显存地址的引用***/int MyShader = glCreateShader(TYPE_OF_SHADER);</code></pre><ul><li>着色器程序运行的着色器语言，在opengl中使用的是GLSL。所以我们需要编写GLSL,并且将其绑定到我们创建的着色器上</li></ul><pre><code class="lang-cpp">/***  * MyShaderSource中写入待绑定的GLSL程序***/const char *MyShaderSource = &quot;#version 330 core\n&quot;    &quot;out vec4 FragColor;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;    &quot;}\n\0&quot;;/***  * 将GLSL程序与Shader进行绑定  * Shader显存地址/程序数量/字符串(数组)/字符串数组长度***/glShaderSource(MyShader, 1, &amp;MyShaderSource, NULL);</code></pre><ul><li>进行着色器编译并显示Debug信息</li></ul><pre><code class="lang-cpp">glCompileShader(vertexShader);// check for shader compile errorsint success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success){    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}</code></pre><ul><li>到这里我们的着色器就编译好了，接下来我们需要将编译好的着色器链接成一个着色器对象。这个着色器对象就是我们将数据渲染到屏幕所使用的的渲染管线。</li></ul><pre><code class="lang-cpp">unsigned int shaderProgram;shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) {    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGTRAM::LINK_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}/***  * 在之后可以调用glUseProgram(shaderProgram)来使用这个我们已经链接好的着色器程序对象。***///别忘了垃圾回收，这两个这时候已经没用了glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h1 id="set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes"><a href="#set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes" class="headerlink" title="set up vertex data (and buffer(s)) and configure vertex attributes"></a>set up vertex data (and buffer(s)) and configure vertex attributes</h1><ul><li>我们要画图形的话，需要几样的东西，首先是需要在内存中准备顶点，然后传输到显存中。</li></ul><h2 id="VBO-vertex-buffer-objects-顶点缓冲对象"><a href="#VBO-vertex-buffer-objects-顶点缓冲对象" class="headerlink" title="VBO(vertex buffer objects):顶点缓冲对象"></a>VBO(vertex buffer objects):顶点缓冲对象</h2><pre><code class="lang-cpp">unsigned int VBO;//这里用&amp;，是因为直接改变VBO指向内存单元的数据，执行完后VBO保存一个显存地址glGenBuffers(1, &amp;VBO);//这一步将显存地址与GL_ARRAY_BUFFER绑定，这样之后所有对GL_ARRAY_BUFFER，其实就是在操作VBO所指的显存区域。glBindBuffer(GL_ARRAY_BUFFER, VBO);//这一步是用于将内存中的数据传输到显存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><ul><li>上述代码用于创建一个叫做VBO缓冲对象的东西，这个用于存储将来从内存传输过来的定点数据。</li></ul><h2 id="解释显存中的缓存数据"><a href="#解释显存中的缓存数据" class="headerlink" title="解释显存中的缓存数据"></a>解释显存中的缓存数据</h2><ul><li>在显存中的数据，我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。</li></ul><pre><code class="lang-cpp">//该函数用于让OpenGL知道该如何解析顶点数据//第一个参数表示该数据希望传输到VS的哪一个参数。比如//  layout (location = 0) in vec3 aPos;//  layout (location = 1) in vec3 bPos;//第一个参数设为0则该数据传入aPos,1则传入bPos//第二个参数表示该定点属性的大小，这里是3//第三个参数表示大小为3，每个部分的类型为float//第四个参数表示是否要标准化设备坐标(Normalized Device Coordinates, NDC)//第五个参数表示每个顶点属性的总大小,对于紧密排列的数据可以用0代替//第六感参数表示位置数据在缓冲中起始位置的偏移量(Offset)，比如sizeof(float)，则偏移一个float值，3*sizeof(float)，则偏移一个定点glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</code></pre><ul><li>接下来我们应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</li></ul><pre><code class="lang-cpp">glEnableVertexAttribArray(0);</code></pre><h2 id="VAO-Vertex-Array-Objec-顶点数组对象"><a href="#VAO-Vertex-Array-Objec-顶点数组对象" class="headerlink" title="VAO(Vertex Array Objec):顶点数组对象"></a>VAO(Vertex Array Objec):顶点数组对象</h2><ul><li>一个顶点数组对象会储存以下这些内容：<blockquote><p>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</p></blockquote></li></ul><blockquote><p>通过glVertexAttribPointer设置的顶点属性配置。</p><p>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</p></blockquote><ul><li>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</li><li>也就是说我们对VBO的所有配置都会保存在我们所绑定的VAO中，如果之后想要使用这一配置，只需要重新绑定它就行了。</li></ul><pre><code class="lang-cpp">//VAO绑定unsigned int VAO;glGenVertexArrays(1, &amp;VAO);glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO解绑glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO使用glBindVertexArray(VAO);</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code class="lang-cpp">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..// 1. bind Vertex Array ObjectglBindVertexArray(VAO);// 2. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. then set our vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);  //glBindVertexArray(0);...// ..:: Drawing code (in render loop) ::..// 4. draw the objectglUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();</code></pre><h1 id="render-loop"><a href="#render-loop" class="headerlink" title="render loop"></a>render loop</h1><ul><li>如何使用我们所自定义的着色器和配置好的定点属性呢?</li></ul><pre><code class="lang-cpp">// draw our first triangleglUseProgram(shaderProgram);glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organizedglDrawArrays(GL_TRIANGLES, 0, 3);// glBindVertexArray(0); // no need to unbind it every time</code></pre><ul><li>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象</li><li>在glBindVertexArray函数调用之后，会使用VAO中所保存的顶点数据配置</li><li>glDrawArray函数用于绘制图元，第一个函数是图元类型，第二个参数指定了顶点数组的起始索引，第三是顶点个数。绘制glVertexAttribPointer绑定后的第几个位置开始的几个定点。注意这里是定点的偏移，比如这里上下文中大小为 3*sizeof(float)</li><li>需要区分在glVertexAttribPointer中的offset和这里的索引</li></ul><h1 id="EBO-Element-Buffer-Object-引缓冲对象"><a href="#EBO-Element-Buffer-Object-引缓冲对象" class="headerlink" title="EBO(Element Buffer Object):引缓冲对象"></a>EBO(Element Buffer Object):引缓冲对象</h1><ul><li>用于指定定点的绘制顺序</li></ul><pre><code class="lang-cpp">unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</code></pre><pre><code class="lang-cpp">//这里改用这glDrawElements来画三角形glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><ul><li>注意VAO也会保存EBO的数组配置信息，glDrawElements会使用我们绑定的EBO中的索引顺序,所以要注意解绑VAO的顺序</li></ul><h1 id="绘制最终流程"><a href="#绘制最终流程" class="headerlink" title="绘制最终流程"></a>绘制最终流程</h1><pre><code class="lang-cpp">// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染编程 - 资源操作</title>
      <link href="/2019/10/07/CG/UE4/UE4Render-ResourceOperation/"/>
      <url>/2019/10/07/CG/UE4/UE4Render-ResourceOperation/</url>
      
        <content type="html"><![CDATA[<h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><ul><li>Compute Shader<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-</a><br><a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Compute_Shader</a></li></ul><h1 id="UAV"><a href="#UAV" class="headerlink" title="UAV"></a>UAV</h1><ul><li>Unordered Access view<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在shader文件中添加第二个颜色变量</title>
      <link href="/2019/10/06/CG/UE4/UE4Render-addParams/"/>
      <url>/2019/10/06/CG/UE4/UE4Render-addParams/</url>
      
        <content type="html"><![CDATA[<h1 id="在shader文件中添加第二个颜色变量"><a href="#在shader文件中添加第二个颜色变量" class="headerlink" title="在shader文件中添加第二个颜色变量"></a>在shader文件中添加第二个颜色变量</h1><p><a href="https://zhuanlan.zhihu.com/p/36635394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36635394</a><br><a href="https://zhuanlan.zhihu.com/p/36695496" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36695496</a><br>在看了shader编程的第二第三章后,觉的似懂非懂。再上面添加点东西,便于很深入的理解</p><h2 id="MyShader-usf"><a href="#MyShader-usf" class="headerlink" title="MyShader.usf"></a>MyShader.usf</h2><ul><li>我们从目标要求开始,这里我想要使得输出颜色变为两个颜色的和，比如可以让颜色变成R+G,R+B等等</li><li>这里我们现在usf文件中做如下添加和修改</li></ul><pre><code class="lang-cpp">// MyShader.usf#include &quot;/Engine/Public/Platform.ush&quot;float4 SimpleColor;// 增加一个颜色采样的变量float4 SimpleColor2;void MainVS( in float4 InPosition : ATTRIBUTE0, out float4 OutPosition : SV_POSITION ){ // screenspace position from vb    OutPosition = InPosition;}void MainPS(    out float4 OutColor : SV_Target0    ){    // 输出颜色变为两种颜色的叠加    OutColor = (SimpleColor + SimpleColor2);}</code></pre><h2 id="MyShaderTest-h"><a href="#MyShaderTest-h" class="headerlink" title="MyShaderTest.h"></a>MyShaderTest.h</h2><ul><li>因为添加了一个颜色变量，我们得将相关数据传进去。首先想到的是在蓝图中增加一个引脚</li></ul><pre><code class="lang-cpp">// MyShaderTest.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UObject/ObjectMacros.h&quot;#include &quot;Classes/Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;MyShaderTest.generated.h&quot;UCLASS(MinimalAPI, meta = (ScriptName = &quot;TestShaderLibrary&quot;))class UTestShaderBlueprintLibrary : public UBlueprintFunctionLibrary{    GENERATED_UCLASS_BODY()        UFUNCTION(BlueprintCallable, Category = &quot;ShaderTestPlugin&quot;, meta = (WorldContext = &quot;WorldContextObject&quot;))        // 在这里增加一个FLinearColor的形参就是增加一个引脚        static void DrawTestShaderRenderTarget(class UTextureRenderTarget2D* OutputRenderTarget, AActor* AC, FLinearColor MyColor,FLinearColor MyColor2);};</code></pre><h2 id="MyShaderTest-cpp"><a href="#MyShaderTest-cpp" class="headerlink" title="MyShaderTest.cpp"></a>MyShaderTest.cpp</h2><h3 id="DrawTestShaderRenderTarget"><a href="#DrawTestShaderRenderTarget" class="headerlink" title="DrawTestShaderRenderTarget"></a>DrawTestShaderRenderTarget</h3><ul><li>为此我们需要进入cpp文件中,添加相应的形参。这个函数是在逻辑线程中调用。</li><li>ENQUEUE_RENDER_COMMAND向渲染线程压入一个渲染命令， 调用DrawTestShaderRenderTarget_RenderThread</li><li>我们需要在lambda表达式中增加我们需要传的变量给渲染线程。<blockquote><p>DrawTestShaderRenderTarget中主要是对数据的获取和传递,一般不需要修改东西，只需要增加你要传递的各类数据。</p></blockquote></li></ul><pre><code class="lang-cpp">// MyShaderTest.cppvoid UTestShaderBlueprintLibrary::DrawTestShaderRenderTarget(    UTextureRenderTarget2D* OutputRenderTarget,    AActor* Ac,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInGameThread());    if (!OutputRenderTarget)    {        return;    }    FTextureRenderTargetResource* TextureRenderTargetResource = OutputRenderTarget-&gt;GameThread_GetRenderTargetResource();    UWorld* World = Ac-&gt;GetWorld();    ERHIFeatureLevel::Type FeatureLevel = World-&gt;Scene-&gt;GetFeatureLevel();    FName TextureRenderTargetName = OutputRenderTarget-&gt;GetFName();    ENQUEUE_RENDER_COMMAND(CaptureCommand)(        [TextureRenderTargetResource, FeatureLevel, MyColor,MyColor2, TextureRenderTargetName](FRHICommandListImmediate&amp; RHICmdList)    {        DrawTestShaderRenderTarget_RenderThread(RHICmdList, TextureRenderTargetResource, FeatureLevel, TextureRenderTargetName, MyColor,MyColor2);    }    );}</code></pre><h3 id="FMyShaderTest"><a href="#FMyShaderTest" class="headerlink" title="FMyShaderTest"></a>FMyShaderTest</h3><ul><li>因为给DrawTestShaderRenderTarget_RenderThread添加了一个数据，所以需要修改其函数，但是这个比较复杂我们先看简单的。</li><li>渲染管线中VS和PS是一定要自己配置的,所以创建自定义的VS和PS,需要从FGlobalShader继承。然后需要使用</li></ul><pre><code class="lang-cpp">IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><p>这个语句来使相关类和Vertex Shader或Pixel Shader文件绑定，这样渲染管线中将会使用我们自定义的定点着色器和像素着色器</p><ul><li>因为在VS和PS中有些配置是一样的,所以我们可以先从FGlobalShader派生一个FMyShaderTest的类,然后再从FMyShaderTest派生出我们的FShaderTestVS和FShaderTestPS。</li></ul><pre><code class="lang-cpp">// MyShaderTest.cppclass FMyShaderTest : public FGlobalShader{public:    FMyShaderTest() {}    FMyShaderTest(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FGlobalShader(Initializer)    {        SimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));        SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));    }    static bool ShouldCache(EShaderPlatform Platform)    {        return true;    }    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters)    {        //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);          return true;    }    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)    {        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);        OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);    }    void SetParameters(        FRHICommandListImmediate&amp; RHICmdList,        const FLinearColor &amp;MyColor,        const FLinearColor &amp;MyColor2    )    {        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);    }    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }private:    FShaderParameter SimpleColorVal;    FShaderParameter SimpleColorVal2;};</code></pre><p>其中</p><pre><code class="lang-cpp">// MyShaderTest.cppSimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));// MyShader.usffloat4 SimpleColor;float4 SimpleColor2;</code></pre><ul><li>这是将FMyShaderTest中的私有变量与MyShader.usf中变量进行绑定。</li><li><p>但是我们注意到我们还没有将颜色输入到FMyShaderTest中的私有变量。因此我们需要写一个函数用于把我们的颜色信息传到shader里。。</p><pre><code class="lang-cpp">// MyShaderTest.cppvoid SetParameters(  FRHICommandListImmediate&amp; RHICmdList,  const FLinearColor &amp;MyColor,  const FLinearColor &amp;MyColor2){  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);}</code></pre></li><li><p>因为这些参数在PS中使用到，所以此处使用GetPixelShader()参数</p></li></ul><pre><code class="lang-cpp">    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }</code></pre><ul><li>虚幻序列化，用于读取磁盘上的渲染数据，这里需要将我们所需要的SimpleColorVal，SimpleColorVal2;</li></ul><pre><code class="lang-cpp">static bool ShouldCache(EShaderPlatform Platform){    return true;}static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters){    //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);      return true;}static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment){    FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);    OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);}</code></pre><ul><li>剩下这些可以暂时不用管。<h3 id="VS-和-PS"><a href="#VS-和-PS" class="headerlink" title="VS 和 PS"></a>VS 和 PS</h3></li></ul><pre><code class="lang-cpp">class FShaderTestVS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestVS, Global);public:    FShaderTestVS() {}    FShaderTestVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};class FShaderTestPS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestPS, Global);public:    FShaderTestPS() {}    FShaderTestPS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><ul><li>这里从FMyShaderTest派生两个类分别利用IMPLEMENT_SHADER_TYPE宏指定为VS和PS</li></ul><pre><code class="lang-cpp">DECLARE_SHADER_TYPE(FShaderTestVS, Global);</code></pre><ul><li>该宏用于把该Shader加入全局shadermap中，在运行前会将shadermap中的所以shader进行编译。</li></ul><h3 id="DrawTestShaderRenderTarget-RenderThread"><a href="#DrawTestShaderRenderTarget-RenderThread" class="headerlink" title="DrawTestShaderRenderTarget_RenderThread"></a>DrawTestShaderRenderTarget_RenderThread</h3><pre><code class="lang-cpp">static void DrawTestShaderRenderTarget_RenderThread(    FRHICommandListImmediate&amp; RHICmdList,    FTextureRenderTargetResource* OutputRenderTargetResource,    ERHIFeatureLevel::Type FeatureLevel,    FName TextureRenderTargetName,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInRenderingThread());#if WANTS_DRAW_MESH_EVENTS      FString EventName;    TextureRenderTargetName.ToString(EventName);    SCOPED_DRAW_EVENTF(RHICmdList, SceneCapture, TEXT(&quot;ShaderTest %s&quot;), *EventName);#else      SCOPED_DRAW_EVENT(RHICmdList, DrawUVDisplacementToRenderTarget_RenderThread);#endif      //设置渲染目标      SetRenderTarget(        RHICmdList,        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        FTextureRHIRef(),        ESimpleRenderTargetMode::EUninitializedColorAndDepth,        FExclusiveDepthStencil::DepthNop_StencilNop    );    //设置视口      //FIntPoint DrawTargetResolution(OutputRenderTargetResource-&gt;GetSizeX(), OutputRenderTargetResource-&gt;GetSizeY());      //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      TShaderMap&lt;FGlobalShaderType&gt;* GlobalShaderMap = GetGlobalShaderMap(FeatureLevel);    TShaderMapRef&lt;FShaderTestVS&gt; VertexShader(GlobalShaderMap);    TShaderMapRef&lt;FShaderTestPS&gt; PixelShader(GlobalShaderMap);    // Set the graphic pipeline state.      FGraphicsPipelineStateInitializer GraphicsPSOInit;    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);    GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI();    GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI();    GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI();    GraphicsPSOInit.PrimitiveType = PT_TriangleList;    GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();    GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader);    GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader);    SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);    //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      PixelShader-&gt;SetParameters(RHICmdList, MyColor,MyColor2);    // Draw grid.      //uint32 PrimitiveCount = 2;      //RHICmdList.DrawPrimitive(PT_TriangleList, 0, PrimitiveCount, 1);      FVector4 Vertices[4];    Vertices[0].Set(-1.0f, 1.0f, 0, 1.0f);    Vertices[1].Set(1.0f, 1.0f, 0, 1.0f);    Vertices[2].Set(-1.0f, -1.0f, 0, 1.0f);    Vertices[3].Set(1.0f, -1.0f, 0, 1.0f);    static const uint16 Indices[6] =    {        0, 1, 2,        2, 1, 3    };    //DrawPrimitiveUP(RHICmdList, PT_TriangleStrip, 2, Vertices, sizeof(Vertices[0]));      DrawIndexedPrimitiveUP(        RHICmdList,        PT_TriangleList,        0,        ARRAY_COUNT(Vertices),        2,        Indices,        sizeof(Indices[0]),        Vertices,        sizeof(Vertices[0])    );    // Resolve render target.      RHICmdList.CopyToResolveTarget(        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        OutputRenderTargetResource-&gt;TextureRHI,        false, FResolveParams());}</code></pre><ul><li>这是渲染线程中执行的函数</li><li>这里只要在形参中添加MyColor2，以及SetParameters中添加MyColor2</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloWindow</title>
      <link href="/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/"/>
      <url>/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/</url>
      
        <content type="html"><![CDATA[<ul><li><p>glfwMakeContextCurrent(window)</p><blockquote><p>用于在当前线程上载入window的上下文。</p></blockquote></li><li><p>需要在使用opengl函数前加载glad用于定于函数地址</p><pre><code class="lang-cpp">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){  std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;  return -1;}</code></pre><p>疑问:必须在glfwMakeContextCurrent(window)之后才能初始化GLAD,为什么？</p><blockquote><p>我做了一些尝试,glViewport的操作,如果不初始化GLAD,将无法使用。而要初始化GLAD,要在当前线程载入window上下文—190921 </p></blockquote></li></ul><ul><li><p>glViewport()<br>最终显示的内容由glViewport和glfwCreateWindow的参数共同决定：不会超过glfwCreateWindow的大小,小于的话会由部分不加载出来</p><blockquote><p>如果glfwCreateWindow:800*600,glViewport:1600*600,最终 800*600<br>如果glfwCreateWindow:800*600,glViewport:400*300,最终 400*300</p></blockquote></li><li><p>glfwSetFramebufferSizeCallback()<br>这是一个回调绑定函数,他会相应窗口变化，并传递宽高给回调函数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第三章:变换</title>
      <link href="/2019/09/09/CG/DirextX/D3DTransform/"/>
      <url>/2019/09/09/CG/DirextX/D3DTransform/</url>
      
        <content type="html"><![CDATA[<h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>满足以下性质为线性变换<blockquote><p>1.$\tau(u+v) = \tau(u) + \tau(v)$<br>2.$\tau(ku) = k\tau(u)$<br>其中u,v为任意三维向量，k为标量 </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第四章:渲染管线</title>
      <link href="/2019/09/09/CG/DirextX/D3DInit/"/>
      <url>/2019/09/09/CG/DirextX/D3DInit/</url>
      
        <content type="html"><![CDATA[<h1 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h1><ul><li>我们必须使用特定的函数活其他的COM接口方法来获取指向COM接口的指针,而不能用<strong>new</strong>  </li><li>释放用其基类IUnkown的Release,而不能用<strong>delete</strong>  </li><li>COM接口都以<strong>I</strong>为前缀,例如ID3D11Texture2D  </li></ul><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><ul><li>2D纹理是一种数据元素矩阵，可以用于存储图像数据，每个元素存储一个像素颜色。也可以存储纹理法线  </li><li>纹理只支持特定格式的数据类型。有DXGI_FORMAT枚举类型描述  </li><li>存在一种弱类型（typeless），预先分配空间，但不解释类型。</li></ul><h1 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h1><ul><li><strong>离屏</strong>(off-screen) =&gt; <strong>后台缓冲区</strong>(back buffer)</li><li><strong>前台缓冲区</strong>(front buffer)</li><li>前后缓冲区互换的行为为<strong>呈现</strong>(presenting)<blockquote><p>这一操作只是交换两者指针指向的位置，所以速度很快<br><img src="SwapBuffer.png" alt></p></blockquote></li><li>前后缓冲区组成一个<strong>交换链</strong>(swap chain)</li></ul><h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><ul><li>深度缓冲区与后台缓冲区大小一样</li><li>D3D11 判断前后遮挡使用 深度缓存(depth buffering)或Z缓存(z-buffering)</li></ul><h1 id="纹理资源视图"><a href="#纹理资源视图" class="headerlink" title="纹理资源视图"></a>纹理资源视图</h1><ul><li><p>纹理可以被绑定到渲染管线（rendering pipeline）的不同阶段（stage）。  </p><blockquote><p>将纹理作为渲染目标（即，Direct3D渲染到纹理,在渲染结果暂存在纹理中），使用标志D3D11_BIND_RENDER_TARGET<br>着色器资源（即，在着色器中对纹理进行采样），使用标志D3D10_BIND_SHADER_RESOURCE</p></blockquote></li><li><p>纹理不能直接绑定到渲染管线，只能把与资源关联的资源视图绑定到不同的管线阶段  </p></li><li>Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图</strong>（resource view），渲染目标视图（ID3D11RenderTargetView）和着色器资源视图（ID3D11ShaderResourceView） </li><li>创建资源时一定要指定绑定标志值，不然将无法创建资源视图 <h2 id="资源视图的作用"><a href="#资源视图的作用" class="headerlink" title="资源视图的作用"></a>资源视图的作用</h2></li><li>（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</li><li>（2）如果在创建资源时指定的是弱类型（typeless）格式，那么在为它创建资源视图时就必须指定明确的资源类型。对于弱类型格式，纹理元素可能会在一个管线阶段中视为浮点数，而在另一个管线阶段中视为整数。</li></ul><h1 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h1><ul><li>超级采样（supersampling）:比如4x ssaa,将屏幕分别率提高4倍，然后每4个像素采样后取平均值。相当于深度缓存和后台缓存都扩大4倍。</li><li>多重采样（multisampling）:比如4x msaa,只在三角形的边缘进行处理。且每一个像素分为4个子像素。深度缓存和后台缓存也会扩大4倍。</li></ul><h1 id="特征等级"><a href="#特征等级" class="headerlink" title="特征等级"></a>特征等级</h1><ul><li>特征等级定义了一系列支持不同d3d功能的相应的等级，用意即如果一个用户的硬件不支持某一特征等级，程序可以选择较低的等级。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://enjoyphysics.cn/Article1513" target="_blank" rel="noopener">https://enjoyphysics.cn/Article1513</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染模块</title>
      <link href="/2019/09/05/CG/UE4/UE4RenderModule/"/>
      <url>/2019/09/05/CG/UE4/UE4RenderModule/</url>
      
        <content type="html"><![CDATA[<p>原文:<a href="https://zhuanlan.zhihu.com/p/72509370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72509370</a></p><h1 id="UE4场景和场景管理-Scene-、SceneManager"><a href="#UE4场景和场景管理-Scene-、SceneManager" class="headerlink" title="UE4场景和场景管理(Scene 、SceneManager)"></a>UE4场景和场景管理(Scene 、SceneManager)</h1><h2 id="Scene与UWorld和FScene"><a href="#Scene与UWorld和FScene" class="headerlink" title="Scene与UWorld和FScene"></a>Scene与UWorld和FScene</h2><ul><li>UE4 Scene有UWorld和FScene组成  </li><li>UWorld用于游戏线程，包括用户的主动行为，如物体的创建和删除。</li><li>FScene用于渲染线程，包括物体的被动行为。</li><li>UWorld和FScene一一对应</li></ul><h2 id="UWorld和ULevel和ULevelStraming"><a href="#UWorld和ULevel和ULevelStraming" class="headerlink" title="UWorld和ULevel和ULevelStraming"></a>UWorld和ULevel和ULevelStraming</h2><ul><li>UWorld由持久关卡(ULevel)和子关卡组成。子关卡可以动态加卸载，也被称为流关卡(ULevelStreaming)</li><li>流关卡(ULevelStreaming)加载和卸载由UWorldComposition负责。由基于视点距离和流关卡卡包围盒的简单的加载策略实现</li><li>具体物体放置在关卡活流关卡中，而不是在UWorld中</li></ul><h2 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h2><ul><li>FScene不具备复杂的场景管理功能</li><li>FScene有以下结构<blockquote><p>数组:用于管理各种可渲染对象和灯光<br>Octree:用于灯光和可渲染对象的快速查找<br>DrawList:用于Cache各个渲染指令</p></blockquote></li></ul><h1 id="SceneObject"><a href="#SceneObject" class="headerlink" title="SceneObject"></a>SceneObject</h1><ul><li>将具体物体放入场景(即关卡和流关卡)中的时候，各个独立物体是由AActor及其子类的对象实例来建模表达</li><li>AActor和其子类不直接持有渲染数据，具体的渲染相关的数据均在UActorComponent及其子类的实例中。</li><li>渲染相关的主要Component类结构层次如下<br><img src="ComponentClassLevel.jpg" alt></li></ul><h1 id="UE4渲染API封装"><a href="#UE4渲染API封装" class="headerlink" title="UE4渲染API封装"></a>UE4渲染API封装</h1><ul><li>UE4中的渲染API封装是个独立的模块(Module)，他们把它命名为RHI（Render Hardware Interface）</li><li>RHI的转发实现在RHICommandList.h文件里，除了基本的条件判断，大都是直接 转调渲染API实现的RHI子模块里的渲染指令。</li></ul><h1 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h1><ul><li>UE4对材质系统的封装可以理解为RenderPipeline输入的所有数据中除了几何体数据之外的所有其它数据。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li>材质分为材质模块(UMaterial)和材质实例(UMaterialInstance),两者继承自UMaterialInterface</li><li>UMaterial材质模板带有可编辑的节点图并可据此生成对应的Shader组合</li><li>UMaterialInstance材质实例则只需要引用UMaterial对应的Shader且只能修改材质模板暴露出来的材质参数。</li></ul><h2 id="FMaterialResource"><a href="#FMaterialResource" class="headerlink" title="FMaterialResource"></a>FMaterialResource</h2><ul><li>没关UMaterial中含有多个FMaterialResource，其继承自FMateriale。其负责为各个渲染API和材质所支持的各种质量等级生成对应的Shader组合</li></ul><h2 id="FMaterialRenderProxy"><a href="#FMaterialRenderProxy" class="headerlink" title="FMaterialRenderProxy"></a>FMaterialRenderProxy</h2><ul><li>FMaterialRenderProxy是FMaterial用于渲染线程的代理,它可以透过FMaterail和UMaterialInterface访问到Shader、渲染状态，光照模型等所有用户设置好的材质参数。</li></ul><hr><ul><li>UE4的材质中光照模型是不可定制的，除非修改源码</li></ul><h1 id="UE4中Shader生成"><a href="#UE4中Shader生成" class="headerlink" title="UE4中Shader生成"></a>UE4中Shader生成</h1><ul><li>UE4的shader基类为FShader,其有两个主要的子类FGlobalShader和FMaterialShader</li><li>FGlobalShader:全局Shader,会自动注册到全局ShaderCache中</li><li>FMaterialShader:用于材质(编辑器）的Shader，所有的后处理、UI、用于模型渲染的Shader都是它的子类。 </li><li>UE4 Shader生成分两部分<blockquote><p>第一部分是把材质编辑器中的节点图编译成HLSL代码，这一部分是通过FHLSLMaterialTranslator来完成的。<br>第二部分是把HLSL生成多平台的Shader代码，如Windows上的HLSL,Android上的GLSL,IOS上的MetalShader。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第五章:渲染管线</title>
      <link href="/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉"><a href="#三维视觉" class="headerlink" title="三维视觉"></a>三维视觉</h1><ul><li>渲染管线:在给定一个3D场景的几何描述及一架已确定位置和方向的虚拟摄像机时，根据虚拟摄像机的视角生成2D图像的一系列步骤<blockquote><p>渲染管线由许多步骤组成，每个步骤称为一个阶段</p></blockquote></li></ul><p><img src="5-1.jpg" alt></p><ul><li>线性透视（linear perspective）:在2d画布上两条平行的线不断向远处延伸，最终会相交到一点。这个点是零点（vanishing point）<br><img src="5-2.jpg" alt></li><li>景深现象（depth phenomenon）:物体的大小会随着深度的增加而减小<br><img src="5-3.jpg" alt></li><li>物体重叠（object overlap）:一个不透明的物体会挡住它后面的其他物体的一部分（或全部）<br><img src="5-4.jpg" alt></li><li>光照（lighting）和阴影（shading）:表现物体立体感和体积感<br><img src="5-5.jpg" alt><blockquote><p>阴影具有两个关键作用：一是告诉我们场景中的光源位置，二是告诉我们飞船距离地面的高度。<br><img src="5-6.jpg" alt></p></blockquote></li></ul><h1 id="模型的表现形式"><a href="#模型的表现形式" class="headerlink" title="模型的表现形式"></a>模型的表现形式</h1><ul><li>三角形是构成物体模型的基本单位</li></ul><h1 id="基本计算机颜色"><a href="#基本计算机颜色" class="headerlink" title="基本计算机颜色"></a>基本计算机颜色</h1><h2 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h2><ul><li><p>0.5(1, 1,1) = (0.5, 0.5, 0.5)</p><blockquote><p>将白色乘以0.5，得到一个中等强度的灰色</p></blockquote></li><li><p>分量乘法（componentwise multiplication）。</p><blockquote><p>$(c_{r},c_{g},c_{b}) ⨂ (k_{r},k_{g},k_{b}) = (c_{r}k_{r},c_{g}k_{g},c_{b}k_{b})$<br>(r,g,b)⨂(0.5,0.75,0.25) = (0.5r,0.75g,0.25b)<br>常用于光照方程,比如上述式子可以表示：光线照射物体时，反射50%红光，75%绿光，25%蓝光</p></blockquote></li></ul><h2 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h2><ul><li><p>alpha值：用于表示物体的不透明度</p><blockquote><p>alpha == 0 完全透明；alpha == 1 完全不透明</p></blockquote></li><li><p>r,g,b,a各用32位浮点型，所以这种表达方式共128位</p></li></ul><h2 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h2><ul><li><p>r,g,b,a分别用8位表示，每个分量又256种强度。</p></li><li><p>32位于128位互相转换</p><blockquote><p>32-&gt;128: 各分量除以256，转换为float<br>128-&gt;32: 各分量乘以256, 转换为int</p></blockquote></li><li><p>通常，许多颜色运算（例如，在像素着色器中）使用的都是128位颜色值；通过这一方式，我们可以有足够多的二进制位来保证计算的精确度，减少算术错误的累积。不过，最终的像素颜色通常是存储在后台缓冲区的32位颜色值中；目前的物理显示设备还不能充分利用更高的分辨率颜色。</p></li></ul><h1 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h1><p><img src="5-7.jpg" alt></p><blockquote><p>内存到阶段的箭头表示阶段从内存种读数据<br>内存到阶段的箭头表示阶段在内存种写数据</p></blockquote><h1 id="输入装配阶段-Input-Assembler-Stage"><a href="#输入装配阶段-Input-Assembler-Stage" class="headerlink" title="输入装配阶段(Input Assembler Stage)"></a>输入装配阶段(Input Assembler Stage)</h1><p>输入装配（Input Assembler，简称IA）阶段从内存读取几何数据（顶点和索引）并将这些数据组合为几何图元（例如，三角形、直线）。</p><blockquote><p>索引规定了顶点的组织形式，解释了该以何种方式组成图元。</p></blockquote><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><ul><li>Direct3D中的顶点由空间位置和各种附加属性组成。比如添加法线向量实现光照，添加纹理坐标实现纹理等等</li></ul><h2 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h2><ul><li>顶点缓冲区:在连续内存中存储了的一个顶点列表</li><li>图元拓扑:用来指定如何组织顶点缓冲区的顶点。例如每两个组成一条直线，每三个组成一个三角形</li></ul><h3 id="基本图元"><a href="#基本图元" class="headerlink" title="基本图元"></a>基本图元</h3><p><img src="5-8.png" alt></p><blockquote><p>(a)为点列表  D3D11_PRIMITIVE_TOPOLOGY_POINTLIST<br>(b)为线带 D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP<br>(c)为线列表 D3D11_PRIMITIVE_TOPOLOGY_LINELIST<br>(d)为三角形带 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 三角形带不会造成顶点的重复存储  </p></blockquote><p><img src="5-9.png" alt></p><blockquote><p>(a)为三角形列表 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST</p></blockquote><h3 id="带邻接信息的图元"><a href="#带邻接信息的图元" class="headerlink" title="带邻接信息的图元"></a>带邻接信息的图元</h3><ul><li>如上图(b)主要用于某些几何着色器的的算法 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ<blockquote><p>邻接图元顶点只能作为几何着色器的输入数据且不会被绘制出来</p></blockquote></li></ul><h3 id="控制点面片列表"><a href="#控制点面片列表" class="headerlink" title="控制点面片列表"></a>控制点面片列表</h3><ul><li>见13章  D3D11_PRIMITIVE_TOPOLOGY_N_CONTRIL_POINT_PATCHLIST<blockquote><p>用于图形渲染管线的细分阶段</p></blockquote></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>问题：通过三角形构造其他图形的时候，如果使用三角形列表，将会造成大量的顶点的重复。</p></li><li><p>产生影响: 1.增加内存需求量。2.增加图形硬件的处理负担。</p></li><li><p>方法一：使用三角形带。但是顶点必须按照带状组织，不灵活。</p></li><li><p>方法二：引入索引。</p><pre><code class="lang-cpp">//create a quadVertex v[4] = {v0, v1, v2, v3}; UINT indexList[6] = {0, 1, 2,    //Triangle0   0, 2, 3}; // Triangle 1 };</code></pre><blockquote><p>当顶点列表中的唯一顶点得到处理之后，显卡可以使用索引列表把顶点放在一起构成三角形。我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为：<br>1．索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。<br>2．通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p></blockquote></li></ul><h1 id="顶点着色器阶段-vertex-shader-Stage"><a href="#顶点着色器阶段-vertex-shader-Stage" class="headerlink" title="顶点着色器阶段(vertex shader Stage)"></a>顶点着色器阶段(vertex shader Stage)</h1><p>顶点着色器将IA阶段的输出的顶点实现相关效果再输出（例如变换，光照，置换贴图映射等）。此外此阶段还可以访问内存种的纹理和其他数据（变换矩阵和场景灯光）。可以概念性地认为在硬件上执行了如下代码：</p><pre><code class="lang-cpp">for(UINT i = 0; i &lt; numVertices; ++i)    outputVertex[i] = VertexShader(inputVertex[i]);</code></pre><h2 id="局部空间和世界空间"><a href="#局部空间和世界空间" class="headerlink" title="局部空间和世界空间"></a>局部空间和世界空间</h2><ul><li>世界变换:局部空间-&gt;世界空间</li></ul><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><ul><li>观察变换:世界空间-&gt;观察空间</li></ul><h2 id="齐次裁剪控件"><a href="#齐次裁剪控件" class="headerlink" title="齐次裁剪控件"></a>齐次裁剪控件</h2><p><a href="https://gameinstitute.qq.com/community/detail/117556" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/117556</a></p><h2 id="规范化设备坐标-NDC"><a href="#规范化设备坐标-NDC" class="headerlink" title="规范化设备坐标(NDC)"></a>规范化设备坐标(NDC)</h2><ul><li>将坐标都映射到[-1,1]，目的是消除设备差异性</li></ul><h1 id="曲面细分阶段"><a href="#曲面细分阶段" class="headerlink" title="曲面细分阶段"></a>曲面细分阶段</h1><ul><li>可选阶段,详见13章</li></ul><h1 id="几何着色器阶段"><a href="#几何着色器阶段" class="headerlink" title="几何着色器阶段"></a>几何着色器阶段</h1><ul><li>接收完整的图元数据</li><li>用于创建和销毁几何体<blockquote><p>根据接收到的图元数据来扩展图元或根据某些条件来拒绝输出某些图元数据<br>常用于将一个点扩展为一个四边形，或者将一条线扩展为一个四边形</p></blockquote></li><li>顶点位置在离开几何着色器之前，必须被变换到齐次裁剪空间。</li></ul><h1 id="裁剪阶段"><a href="#裁剪阶段" class="headerlink" title="裁剪阶段"></a>裁剪阶段</h1><ul><li>完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。</li><li>三角形被裁剪后会变成四边形，这需要重新划分三角形</li><li>Sutherland-Hodgeman裁剪法:</li></ul><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><ul><li>齐次裁剪空间-&gt;规范化设备空间-&gt;后台缓冲区的视口区域（此时x,y以像素为单位）</li><li>z值还要被深度缓存使用。</li></ul><h2 id="背面消隐"><a href="#背面消隐" class="headerlink" title="背面消隐"></a>背面消隐</h2><h3 id="判断三角形正反面"><a href="#判断三角形正反面" class="headerlink" title="判断三角形正反面"></a>判断三角形正反面</h3><ul><li>设三角形的定点排列为$v_{0},v_{1},v_{2}$</li><li>可以计算出三角形的法线，方法如下:<blockquote><p>$\vec{e_{0}} = v_{1} - v_{0}$<br>$\vec{e_{1}} = v_{2} - v_{1}$<br>$\vec{n} = \frac{\vec{e_{0}} × \vec{e_{1}}}{|| \vec{e_{0}} × \vec{e_{1}} ||}$</p></blockquote></li><li>带有法线向量的面为正面，而另一个面为背面<blockquote><p>当观察者看到三角形的正面时，我们说三角形是朝前的；当观察者看到三角形的背面时， 我们说三角形是朝后的。<br>因为按照我们选择的约定（即，我们计算三角形法线的方式），按顺时针方向环绕的三角形（相对于观察者）是朝前的，而按逆时针方向环绕的三角形（相对于观察者）是朝后的。</p></blockquote></li><li>D3D 顺时针</li></ul><h3 id="背面消隐-backface-culling"><a href="#背面消隐-backface-culling" class="headerlink" title="背面消隐(backface culling)"></a>背面消隐(backface culling)</h3><ul><li>背面消隐（backface culling）是指让管线放弃对朝后的三角形的处理。这可以将所要处理的三角形的数量降低到原数量的一半。</li><li>以下为2D和3D场景消隐前后的表现<br><img src="backfaceCulling2D.png" alt><br><img src="backfaceCulling3D.png" alt></li></ul><h2 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h2><ul><li>一条3D线被投影到投影窗口上（在屏幕空间中投影是一条2D线）。我们看到，在3D线上取等距离的点，在2D屏幕空间上的投影点却不是等距离的。所以，我们在3D空间中执行线性插值，在屏幕空间需要执行非线性插值。</li></ul><h1 id="像素着色器阶段"><a href="#像素着色器阶段" class="headerlink" title="像素着色器阶段"></a>像素着色器阶段</h1><ul><li>像素着色器（Pixel shader）是由我们编写的在GPU上执行的程序。像素着色器会处理每个像素片段（pixel fragment），它的输入是插值后的顶点属性，由此计算出一个颜色。像素着色器可以非常简单地输出一个颜色，也可以很复杂，例如实现逐像素光照、反射和阴影等效果。</li></ul><h1 id="输出合并阶段"><a href="#输出合并阶段" class="headerlink" title="输出合并阶段"></a>输出合并阶段</h1><ul><li>当像素片段由像素着色器生成之后，它们会被传送到渲染管线的输出合并（output<br>merger，简称OM）阶段。在该阶段中，某些像素片段会被丢弃（例如，未能通过深度测试或模板测试）。未丢弃的像素片段会被写入后台缓冲区。混合（blending）工作是在该阶段中完成的，一个像素可以与后台缓冲区中的当前像素进行混合，并以混合后的值作为该像素的最终颜色。某些特殊效果，比如透明度，就是通过混合来实现的；我们会在第9章专门讲解混合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之JSON学习</title>
      <link href="/2019/08/07/CG/UE4/JSON/"/>
      <url>/2019/08/07/CG/UE4/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>JSON格式</li><li>解析JSON文件</li><li>修改JSON文件</li></ul><h1 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/29119549" target="_blank" rel="noopener">十分钟搞定JSON和JSON对象</a></li></ul><p>想要使用JSO相关工具，必须在<strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;,         &quot;Json&quot;,         &quot;JsonUtilities&quot;    });</code></pre><h1 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h1><ul><li>我们在 \Content\Res\Data.json中天下如下测试例子</li></ul><pre><code class="lang-json">/** Data.json **/[    {        &quot;1-1&quot;:&quot;1-1&quot;,        &quot;1-2&quot;:&quot;1-2&quot;    },    {        &quot;2-1&quot;:&quot;2-1&quot;    },    {        &quot;3-1&quot;:        [            {                &quot;1&quot;:&quot;3-1-1&quot;            },            {                &quot;2&quot;:&quot;3-1-2&quot;            }        ]    }]</code></pre><ul><li>我们要首先得将他以字符串的形式读入<blockquote><p>FPaths::GameContentDir() 能获取 */Content/ 的位置<br>FFileHelper::LoadFileToString() Load a text file to an FString.</p></blockquote></li></ul><pre><code class="lang-cpp">bool MyJsonHandle::LoadStringFromFile(FString &amp; RelativePathName, FString &amp; FileName, FString &amp; ResultString){    if (!FileName.IsEmpty())    {        FString AbsloutePathName = FPaths::GameContentDir() + RelativePathName + FileName;        if (FPaths::FileExists(AbsloutePathName))        {            if (FFileHelper::LoadFileToString(ResultString, *AbsloutePathName))            {                return true;            }        }    }    return false;}`</code></pre><ul><li>接下来我们来解析我们所获取到的FString</li></ul><pre><code class="lang-cpp">/** MyJsonHandle.cpp **/bool MyJsonHandle::RecordDataJsonRead(){    FString result;    //这是我们上面自定义的函数    LoadStringFromFile(RelativePathName, DataFileName, result);    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse;    TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(result);    if (FJsonSerializer::Deserialize(JsonReader, JsonParse))    { //这样解析后的节点全部存在JsonParse中        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-1&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-2&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[1]-&gt;AsObject()-&gt;GetStringField(FString(&quot;2-1&quot;)));        //如果对象是嵌套的，则需要再声明一次TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt;来获取        TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse3 = JsonParse[2]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;3-1&quot;));        if (JsonParse3.IsValidIndex(0))        {            for (int cnt = 1; cnt &lt;= JsonParse3.Num(); ++cnt)            {                UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse3[cnt-1]-&gt;AsObject()-&gt;GetStringField(FString::FromInt(cnt)));            }        }        else        {            UE_LOG(LogTemp, Warning, TEXT(&quot;error JsonParse3&quot;));        }        return true;    }    return false;}</code></pre><h1 id="修改JSON文件"><a href="#修改JSON文件" class="headerlink" title="修改JSON文件"></a>修改JSON文件</h1><h2 id="设置单个属性"><a href="#设置单个属性" class="headerlink" title="设置单个属性"></a>设置单个属性</h2><ul><li>通过下面的代码生成一个<pre><code class="lang-cpp">/*** A Json Object is a structure holding an unordered set of name/value pairs.* In a Json file, it is represented by everything between curly braces {}.*/TSharedPtr&lt;FJsonObject&gt; Object1 = MakeShareable(new FJsonObject);Object1-&gt;SetStringField(&quot;1-1&quot;, &quot;1--1&quot;);Object1-&gt;SetStringField(&quot;1-2&quot;, &quot;1--2&quot;);TSharedPtr&lt;FJsonValueObject&gt; CultureValue = MakeShareable(new FJsonValueObject(CultureObject));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4学习</title>
      <link href="/2019/08/07/Menu/UE4Menu/"/>
      <url>/2019/08/07/Menu/UE4Menu/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&amp;_bid=167&amp;_wv=3&amp;ADUIN=1076613110&amp;ADSESSION=1556776713&amp;ADTAG=CLIENT.QQ.5611_.0&amp;ADPUBNO=26886&amp;taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><p><a href="https://sanctorum003.github.io/2019/08/02/HUD/" target="_blank" rel="noopener">虚幻4之Slate学习一 —— HUD</a><br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a><br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a><br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a><br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/CG/UE4/DelegateAndMacro/"/>
      <url>/2019/08/06/CG/UE4/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><div class="table-container"><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table></div><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="lang-CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="lang-cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="lang-cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="lang-cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="lang-cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="lang-cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="lang-cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li>事件原型<pre><code class="lang-cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="lang-cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li>FReply 告诉引擎如何处理事件<blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li>FReply::Handled() 告诉引擎事件处理完<blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p></li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/public:    //注意SOverlay::FOverlaySlot 是内部类    SOverlay::FOverlaySlot* MySlot;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>我们尝试编写图片的点击效果，来使用委托和宏。SImage默认不带这个效果。</li><li>首先我们创建一个继承于SlateWidget的C++类命名为MyImage</li><li>创建一个委托，用于与SLATE_EVENT绑定。相当于自定义一个需要单击会触发函数的函数原型</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/DECLARE_DELEGATE_RetVal(FReply,FImageOnClicked)</code></pre><ul><li>创建一个SLATE_EVENT,将之前创建的委托与该SLATE_EVENT绑定</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/SLATE_BEGIN_ARGS(SMyHUDWidget){}SLATE_EVENT(FImageOnClicked, ImageOnClicked)SLATE_END_ARGS()</code></pre><ul><li>然后在原来的SMyHUDWidget将SImage换成SMyImage并且可以调用ImageOnClicked()</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            /**              * TSharedPtr&lt;SMyImage&gt; MyImage;            **/            SAssignNew(MyImage, SMyImage)            //.ImageOnClicked()        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        .Expose(MySlot)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    //删除原来语句    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><ul><li>在SMyImage中添加图片</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/#include &quot;SMyImage.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SImage.h&quot;#include &quot;Public/UI/MySlateWidgetStyle.h&quot;#include &quot;Public/UI/MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyImage::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>此时效果如下<br><img src="MyImage.png" alt></p><ul><li>接着我们需要创建一个回调函数用于ImageOnClicked()，传入后event对应FImageOnClicked就绑定该函数了</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::ImageClicked(){    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, &quot;Suceess&quot;);    return FReply::Handled();}</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **//**    * TSharedPtr&lt;SMyImage&gt; MyImage;**/SAssignNew(MyImage, SMyImage).ImageOnClicked(this, &amp;SMyHUDWidget::ImageClicked)</code></pre><ul><li>但是这时候会发现，单击并没有什么效果。这是因为程序并不知道要根据单击触发。</li><li>我们需要在MyImage中重写鼠标相关函数</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/public:    FImageOnClicked ImageOnClick;    virtual FReply OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual FReply OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual void OnMouseLeave(const FPointerEvent&amp; MouseEvent) override;    bool BIsMouseButtonDown = false;</code></pre><ul><li>我们这时候需要在鼠标按下时调用委托，使用我们必须事先获取到这个委托，<em>FImageOnClicked ImageOnClick</em>就是用来声明该委托。</li><li>在构造中,通过InArgs._*可以来获取SLATE_BEGIN_ARGS(SMyHUDWidget)和SLATE_END_ARGS()之间的属性。</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/void SMyImage::Construct(const FArguments&amp; InArgs){    ImageOnClick = InArgs._ImageOnClicked;    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}</code></pre><ul><li>这样我们就可以重写鼠标事件，让其在点击时调用相关委托</li></ul><pre><code class="lang-cpp">FReply SMyImage::OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = true;    return FReply::Handled();}FReply SMyImage::OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    if (BIsMouseButtonDown == true)    {        BIsMouseButtonDown = false;        ImageOnClick.Execute();    }    return FReply::Handled();}void SMyImage::OnMouseLeave(const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = false;}</code></pre><ul><li>到此就完成了，点击图片时会显示<strong>SUCCEESS</strong><br><img src="Success.png" alt><blockquote><p>如果不成功可以尝试将播放模式设成模拟<br><img src="Simulation.png" alt></p></blockquote></li></ul><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/CG/UE4/SlateWidget/"/>
      <url>/2019/08/04/CG/UE4/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="lang-cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="lang-cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/CG/UE4/WidgetStyle/"/>
      <url>/2019/08/03/CG/UE4/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="lang-cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="lang-cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="lang-cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="lang-cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="lang-cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="lang-cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/CG/UE4/HUD/"/>
      <url>/2019/08/02/CG/UE4/HUD/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li><li>设置光标的相关属性</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="lang-cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="lang-cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="lang-cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将控件从视口删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将视口中的全部控件删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="设置光标"><a href="#设置光标" class="headerlink" title="设置光标"></a>设置光标</h1><ul><li>这里光标是默认的，我们需要让光标一直显示，不然对后面会有影像。</li><li>我们创建继承于PlayerController的MyController类。</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/AMyController::AMyController(){    /** Whether the mouse cursor should be displayed. */    bShowMouseCursor = true;}</code></pre><ul><li>我们还可以设置光标的移动范围</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/void AMyController::BeginPlay(){    /** Data structure used to setup an input mode that allows only the UI to respond to user input. */    FInputModeUIOnly InputMode;    /** Sets the mouse locking behavior of the viewport */    InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::LockAlways);    SetInputMode(InputMode);}</code></pre><ul><li>在Gamemode中应用，这样光标一直显示，且不能移出视口</li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;#include &quot;Public\MyController.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();    PlayerControllerClass = AMyController::StaticClass();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码</p><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/Algorithm/KMP/"/>
      <url>/2019/08/01/Algorithm/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p><p>3) 求当next数组当前位置<strong>j</strong></p><pre><code class="lang-cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>1) next[1]=0</p><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p><p>规则2：右移一位，最左边添-1，最右边自然溢出</p><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
