<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vector深入探索</title>
      <link href="/2021/07/13/ComputerBasics/CPP/STL/vector/"/>
      <url>/2021/07/13/ComputerBasics/CPP/STL/vector/</url>
      
        <content type="html"><![CDATA[<ul><li>容器vector的代码如下:<ul><li>sizeof(vector<t>) = 12Byte(32位下3个4字节的指针)</t></li></ul></li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc= alloc&gt;class vector {public:    typedef T value_type;    typedef value_type* iterator;    typedef value_type&amp; reference;    typedef size_t size_type;protected:    iterator start;    iterator finish;    iterator end_of_storage;public:    iterator begin() { return start; }    iterator end() { return finish; }    size_type size() const { return size_type(end() - begin()); }    size_type capacity() const { return size_type(end_of_storage - begin()); }    bool empty() const { return begin() == end(); }    reference operator[](size_type n) { return *(begin() + n); }    reference front() { return *begin(); }    reference back() { return *(end() - 1); }};</code></pre><h1 id="vector的内存分布"><a href="#vector的内存分布" class="headerlink" title="vector的内存分布"></a>vector的内存分布</h1><p><img src="vector_memory.png" alt></p><ul><li>start指向第一个元素</li><li>finish指向最后一个元素的下一个元素</li><li>end_of_storage指向最大容量的内存块的下一个位置</li><li>size是当前大小</li><li>capacity是当前vector的最大容量</li></ul><hr><ul><li>vector对使用者是连续的,因此重载了[]运算符.</li><li>vector的实现也是连续的,因此使用指针类型做迭代器(即迭代器vector<t>::iterator的实际类型是原生指针T*).</t></li></ul><h1 id="vector的内存扩容"><a href="#vector的内存扩容" class="headerlink" title="vector的内存扩容"></a>vector的内存扩容</h1><ul><li>vector::push_back方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用insert_aux函数先扩容两倍再插入元素.<pre><code class="lang-cpp">void push_back(const T &amp;x) {  if (finish != end_of_storage) { // 尚有备用空间,则直接插入,并调整finish迭代器      construct(finish, x);        // 全局函数      ++finish;                    // 调整finsh位置  } else                             // 已无备用空间则调用 insert_aux 先扩容再插入元素      insert_aux(end(), x);}</code></pre></li><li><p>insert_aux被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</p><pre><code class="lang-cpp">template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_ux(iterator position, const T &amp;x) {   // 这里的重复检测工作是因为这个函数除了给push_back使用还会给其他函数使用(比如insert)  if (finish != end_of_storage) {     // 尚有备用空间,则将插入点后元素后移一位并插入元素       construct(finish, *(finish - 1));   // 以vector最后一个元素值为新节点的初值      ++finish;      T x_copy = x;      copy_backward(position, finish - 2, finish - 1);      *position = x_copy;  } else {      // 已无备用空间,则先扩容,再插入      const size_type old_size = size();      const size_type len = old_size != 0 ?: 2 * old_size:1;  // 分配原则:如果原大小为0,则分配1(个元素大小)                                                              //          如果原大小不为0,则分配原大小的2倍.                                                              //          前半段用来放置原数据,后半段准备用来放置新数据      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      try {          new_finish = uninitialized_copy(start, position, new_start);    // 拷贝插入点前的元素          construct(new_finish, x);                                       // 插入新元素并调整水位          ++new_finish;          new_finish = uninitialized_copy(position, finish, new_finish);  // 拷贝插入点后的元素,用于保证insert操作的准确性      }      catch (expection e) {          // 插入失败则回滚,释放内存并抛出错误          destroy(new_start, new_finish) :          data_allocator::deallocate(new_start, len);          throw;      }      // 释放原容器所占内存      destroy(begin(), end());      deallocate();      // 调整迭代器      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;  }};</code></pre></li></ul><h1 id="gcc2-9的vector源码"><a href="#gcc2-9的vector源码" class="headerlink" title="gcc2.9的vector源码"></a>gcc2.9的vector源码</h1><pre><code class="lang-cpp">//G++ 2.91.57，cygnus\cygwin-b20\include\g++\stl_vector.h 完整列表/* * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.  Hewlett-Packard Company makes no * representations about the suitability of this software for any * purpose.  It is provided &quot;as is&quot; without express or implied warranty. * * * Copyright (c) 1996 * Silicon Graphics Computer Systems, Inc. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.  Silicon Graphics makes no * representations about the suitability of this software for any * purpose.  It is provided &quot;as is&quot; without express or implied warranty. *//* NOTE: This is an internal header file, included by other STL headers. *   You should not attempt to use it directly. */#ifndef __SGI_STL_INTERNAL_VECTOR_H#define __SGI_STL_INTERNAL_VECTOR_H__STL_BEGIN_NAMESPACE #if defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)#pragma set woff 1174#endiftemplate &lt;class T, class Alloc = alloc&gt;  // 預設使用 alloc 為配置器class vector {public:  // 以下標示 (1),(2),(3),(4),(5)，代表 iterator_traits&lt;I&gt; 所服務的5個型別。  typedef T value_type;                // (1)  typedef value_type* pointer;             // (2)  typedef const value_type* const_pointer;  typedef const value_type* const_iterator;  typedef value_type&amp; reference;         // (3)  typedef const value_type&amp; const_reference;  typedef size_t size_type;  typedef ptrdiff_t difference_type;     // (4)  // 以下，由於vector 所維護的是一個連續線性空間，所以不論其元素型別為何，  // 原生指標都可以做為其迭代器而滿足所有需求。  typedef value_type* iterator;  /* 根據上述寫法，如果客端寫出這樣的碼：      vector&lt;Shape&gt;::iterator is;      is 的型別其實就是Shape*      而STL 內部運用 iterator_traits&lt;is&gt;::reference 時，獲得 Shape&amp;                 運用iterator_traits&lt;is&gt;::iterator_category 時，獲得                       random_access_iterator_tag        (5)      （此乃iterator_traits 針對原生指標的特化結果）  */#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  typedef reverse_iterator&lt;iterator&gt; reverse_iterator;#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */  typedef reverse_iterator&lt;const_iterator, value_type, const_reference,                            difference_type&gt;  const_reverse_iterator;  typedef reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;          reverse_iterator;#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */protected:  // 專屬之空間配置器，每次配置一個元素大小  typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  // vector採用簡單的線性連續空間。以兩個迭代器start和end分別指向頭尾，  // 並以迭代器end_of_storage指向容量尾端。容量可能比(尾-頭)還大，  // 多餘即備用空間。  iterator start;  iterator finish;  iterator end_of_storage;  void insert_aux(iterator position, const T&amp; x);  void deallocate() {    if (start)         data_allocator::deallocate(start, end_of_storage - start);  }  void fill_initialize(size_type n, const T&amp; value) {    start = allocate_and_fill(n, value);  // 配置空間並設初值    finish = start + n;                // 調整水位    end_of_storage = finish;             // 調整水位  }public:  iterator begin() { return start; }  const_iterator begin() const { return start; }  iterator end() { return finish; }  const_iterator end() const { return finish; }  reverse_iterator rbegin() { return reverse_iterator(end()); }  const_reverse_iterator rbegin() const {     return const_reverse_iterator(end());   }  reverse_iterator rend() { return reverse_iterator(begin()); }  const_reverse_iterator rend() const {     return const_reverse_iterator(begin());   }  size_type size() const { return size_type(end() - begin()); }  size_type max_size() const { return size_type(-1) / sizeof(T); }  size_type capacity() const { return size_type(end_of_storage - begin()); }  bool empty() const { return begin() == end(); }  reference operator[](size_type n) { return *(begin() + n); }  const_reference operator[](size_type n) const { return *(begin() + n); }  vector() : start(0), finish(0), end_of_storage(0) {}  // 以下建構式，允許指定大小 n 和初值 value  vector(size_type n, const T&amp; value) { fill_initialize(n, value); }  vector(int n, const T&amp; value) { fill_initialize(n, value); }  vector(long n, const T&amp; value) { fill_initialize(n, value); }  explicit vector(size_type n) { fill_initialize(n, T()); }  vector(const vector&lt;T, Alloc&gt;&amp; x) {    start = allocate_and_copy(x.end() - x.begin(), x.begin(), x.end());    finish = start + (x.end() - x.begin());    end_of_storage = finish;  }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  vector(InputIterator first, InputIterator last) :    start(0), finish(0), end_of_storage(0)  {    range_initialize(first, last, iterator_category(first));  }#else /* __STL_MEMBER_TEMPLATES */  vector(const_iterator first, const_iterator last) {    size_type n = 0;    distance(first, last, n);    start = allocate_and_copy(n, first, last);    finish = start + n;    end_of_storage = finish;  }#endif /* __STL_MEMBER_TEMPLATES */  ~vector() {     destroy(start, finish);  // 全域函式，建構/解構基本工具。    deallocate();   // 先前定義好的成員函式  }  vector&lt;T, Alloc&gt;&amp; operator=(const vector&lt;T, Alloc&gt;&amp; x);  void reserve(size_type n) {    if (capacity() &lt; n) {      const size_type old_size = size();      iterator tmp = allocate_and_copy(n, start, finish);      destroy(start, finish);      deallocate();      start = tmp;      finish = tmp + old_size;      end_of_storage = start + n;    }  }  // 取出第一個元素內容  reference front() { return *begin(); }  const_reference front() const { return *begin(); }  // 取出最後一個元素內容  reference back() { return *(end() - 1); }  const_reference back() const { return *(end() - 1); }  // 增加一個元素，做為最後元素  void push_back(const T&amp; x) {    if (finish != end_of_storage) {  // 還有備用空間      construct(finish, x);           // 直接在備用空間中建構元素。      ++finish;                              // 調整水位高度    }    else                                  // 已無備用空間      insert_aux(end(), x);              }  void swap(vector&lt;T, Alloc&gt;&amp; x) {    __STD::swap(start, x.start);    __STD::swap(finish, x.finish);    __STD::swap(end_of_storage, x.end_of_storage);  }  iterator insert(iterator position, const T&amp; x) {    size_type n = position - begin();    if (finish != end_of_storage &amp;&amp; position == end()) {      construct(finish, x);        // 全域函式，建構/解構基本工具。      ++finish;    }    else      insert_aux(position, x);    return begin() + n;  }  iterator insert(iterator position) { return insert(position, T()); }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  void insert(iterator position, InputIterator first, InputIterator last){    range_insert(position, first, last, iterator_category(first));  }#else /* __STL_MEMBER_TEMPLATES */  void insert(iterator position,              const_iterator first, const_iterator last);#endif /* __STL_MEMBER_TEMPLATES */  void insert (iterator pos, size_type n, const T&amp; x);  void insert (iterator pos, int n, const T&amp; x) {    insert(pos, (size_type) n, x);  }  void insert (iterator pos, long n, const T&amp; x) {    insert(pos, (size_type) n, x);  }  void pop_back() {    --finish;    destroy(finish);    // 全域函式，建構/解構基本工具。  }  // 將迭代器 position 所指之元素移除  iterator erase(iterator position) {    if (position + 1 != end()) // 如果 p 不是指向最後一個元素      // 將 p 之後的元素一一向前遞移      copy(position + 1, finish, position);     --finish;  // 調整水位    destroy(finish);    // 全域函式，建構/解構基本工具。    return position;  }  iterator erase(iterator first, iterator last) {    iterator i = copy(last, finish, first);    destroy(i, finish);    // 全域函式，建構/解構基本工具。    finish = finish - (last - first);    return first;  }  void resize(size_type new_size, const T&amp; x) {    if (new_size &lt; size())       erase(begin() + new_size, end());    else      insert(end(), new_size - size(), x);  }  void resize(size_type new_size) { resize(new_size, T()); }  // 清除全部元素。注意，並未釋放空間，以備可能未來還會新加入元素。  void clear() { erase(begin(), end()); }protected:  iterator allocate_and_fill(size_type n, const T&amp; x) {    iterator result = data_allocator::allocate(n); // 配置n個元素空間    __STL_TRY {      // 全域函式，記憶體低階工具，將result所指之未初始化空間設定初值為 x，n個      // 定義於 &lt;stl_uninitialized.h&gt;。      uninitialized_fill_n(result, n, x);        return result;    }     // &quot;commit or rollback&quot; 語意：若非全部成功，就一個不留。    __STL_UNWIND(data_allocator::deallocate(result, n));  }#ifdef __STL_MEMBER_TEMPLATES  template &lt;class ForwardIterator&gt;  iterator allocate_and_copy(size_type n,                             ForwardIterator first, ForwardIterator last) {    iterator result = data_allocator::allocate(n);    __STL_TRY {      uninitialized_copy(first, last, result);      return result;    }    __STL_UNWIND(data_allocator::deallocate(result, n));  }#else /* __STL_MEMBER_TEMPLATES */  iterator allocate_and_copy(size_type n,                             const_iterator first, const_iterator last) {    iterator result = data_allocator::allocate(n);    __STL_TRY {      uninitialized_copy(first, last, result);      return result;    }    __STL_UNWIND(data_allocator::deallocate(result, n));  }#endif /* __STL_MEMBER_TEMPLATES */#ifdef __STL_MEMBER_TEMPLATES  template &lt;class InputIterator&gt;  void range_initialize(InputIterator first, InputIterator last,                        input_iterator_tag) {    for ( ; first != last; ++first)      push_back(*first);  }  // This function is only called by the constructor.  We have to worry  //  about resource leaks, but not about maintaining invariants.  template &lt;class ForwardIterator&gt;  void range_initialize(ForwardIterator first, ForwardIterator last,                        forward_iterator_tag) {    size_type n = 0;    distance(first, last, n);    start = allocate_and_copy(n, first, last);    finish = start + n;    end_of_storage = finish;  }  template &lt;class InputIterator&gt;  void range_insert(iterator pos,                    InputIterator first, InputIterator last,                    input_iterator_tag);  template &lt;class ForwardIterator&gt;  void range_insert(iterator pos,                    ForwardIterator first, ForwardIterator last,                    forward_iterator_tag);#endif /* __STL_MEMBER_TEMPLATES */};template &lt;class T, class Alloc&gt;inline bool operator==(const vector&lt;T, Alloc&gt;&amp; x, const vector&lt;T, Alloc&gt;&amp; y) {  return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());}template &lt;class T, class Alloc&gt;inline bool operator&lt;(const vector&lt;T, Alloc&gt;&amp; x, const vector&lt;T, Alloc&gt;&amp; y) {  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDERtemplate &lt;class T, class Alloc&gt;inline void swap(vector&lt;T, Alloc&gt;&amp; x, vector&lt;T, Alloc&gt;&amp; y) {  x.swap(y);}#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */template &lt;class T, class Alloc&gt;vector&lt;T, Alloc&gt;&amp; vector&lt;T, Alloc&gt;::operator=(const vector&lt;T, Alloc&gt;&amp; x) {  if (&amp;x != this) {    // 判斷是否 self-assignment    if (x.size() &gt; capacity()) {        // 如果標的物比我本身的容量還大      iterator tmp = allocate_and_copy(x.end() - x.begin(),                                       x.begin(), x.end());      destroy(start, finish);    // 把整個舊的vector 摧毀      deallocate();            // 釋放舊空間      start = tmp;                // 設定指向新空間      end_of_storage = start + (x.end() - x.begin());    }    else if (size() &gt;= x.size()) {    // 如果標的物大小 &lt;= 我的大小      iterator i = copy(x.begin(), x.end(), begin());      destroy(i, finish);    }    else {      copy(x.begin(), x.begin() + size(), start);      uninitialized_copy(x.begin() + size(), x.end(), finish);    }    finish = start + x.size();  }  return *this;}template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) {  if (finish != end_of_storage) {  // 還有備用空間    // 在備用空間起始處建構一個元素，並以vector 最後一個元素值為其初值。        construct(finish, *(finish - 1));    // 調整水位。    ++finish;    // 以下做啥用？    T x_copy = x;    copy_backward(position, finish - 2, finish - 1);    *position = x_copy;  }  else {        // 已無備用空間    const size_type old_size = size();    const size_type len = old_size != 0 ? 2 * old_size : 1;    // 以上配置原則：如果原大小為0，則配置 1（個元素大小）；    // 如果原大小不為0，則配置原大小的兩倍，    // 前半段用來放置原資料，後半段準備用來放置新資料。    iterator new_start = data_allocator::allocate(len); // 實際配置    iterator new_finish = new_start;    __STL_TRY {      // 將原vector 的內容拷貝到新 vector。      new_finish = uninitialized_copy(start, position, new_start);      // 為新元素設定初值x      construct(new_finish, x);      // 調整水位。      ++new_finish;      // 將原vector 的備用空間中的內容也忠實拷貝過來（啥用途？）      new_finish = uninitialized_copy(position, finish, new_finish);    }#       ifdef  __STL_USE_EXCEPTIONS     catch(...) {      // &quot;commit or rollback&quot; 語意：若非全部成功，就一個不留。      destroy(new_start, new_finish);       data_allocator::deallocate(new_start, len);      throw;    }#       endif /* __STL_USE_EXCEPTIONS */    // 解構並釋放原 vector    destroy(begin(), end());    deallocate();    // 調整迭代器，指向新vector    start = new_start;    finish = new_finish;    end_of_storage = new_start + len;  }}// 從 position 開始，安插 n 個元素，元素初值為 xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n, const T&amp; x) {  if (n != 0) { // 當 n != 0  才進行以下所有動作    if (size_type(end_of_storage - finish) &gt;= n) {       // 備用空間大於等於「新增元素個數」      T x_copy = x;      // 以下計算安插點之後的現有元素個數      const size_type elems_after = finish - position;          iterator old_finish = finish;      if (elems_after &gt; n) {         // 「安插點之後的現有元素個數」大於「新增元素個數」        uninitialized_copy(finish - n, finish, finish);        finish += n;    // 將vector 尾端標記後移        copy_backward(position, old_finish - n, old_finish);        fill(position, position + n, x_copy);    // 從安插點開始填入新值      }      else {            // 「安插點之後的現有元素個數」小於等於「新增元素個數」        uninitialized_fill_n(finish, n - elems_after, x_copy);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        fill(position, old_finish, x_copy);      }    }    else {      // 備用空間小於「新增元素個數」（那就必須配置額外的記憶體）      // 首先決定新長度：舊長度的兩倍，或舊長度+新增元素個數。      const size_type old_size = size();              const size_type len = old_size + max(old_size, n);      // 以下配置新的vector 空間      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        // 以下首先將舊vector 的安插點之前的元素複製到新空間。        new_finish = uninitialized_copy(start, position, new_start);        // 以下再將新增元素（初值皆為 n）填入新空間。        new_finish = uninitialized_fill_n(new_finish, n, x);        // 以下再將舊vector 的安插點之後的元素複製到新空間。        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef  __STL_USE_EXCEPTIONS       catch(...) {        // 如有異常發生，實現 &quot;commit or rollback&quot; semantics.        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      // 以下清除並釋放舊的 vector       destroy(start, finish);      deallocate();      // 以下調整水位標記      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#ifdef __STL_MEMBER_TEMPLATEStemplate &lt;class T, class Alloc&gt; template &lt;class InputIterator&gt;void vector&lt;T, Alloc&gt;::range_insert(iterator pos,                                    InputIterator first, InputIterator last,                                    input_iterator_tag) {  for ( ; first != last; ++first) {    pos = insert(pos, *first);    ++pos;  }}template &lt;class T, class Alloc&gt; template &lt;class ForwardIterator&gt;void vector&lt;T, Alloc&gt;::range_insert(iterator position,                                    ForwardIterator first,                                    ForwardIterator last,                                    forward_iterator_tag) {  if (first != last) {    size_type n = 0;    distance(first, last, n);    if (size_type(end_of_storage - finish) &gt;= n) {      const size_type elems_after = finish - position;      iterator old_finish = finish;      if (elems_after &gt; n) {        uninitialized_copy(finish - n, finish, finish);        finish += n;        copy_backward(position, old_finish - n, old_finish);        copy(first, last, position);      }      else {        ForwardIterator mid = first;        advance(mid, elems_after);        uninitialized_copy(mid, last, finish);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        copy(first, mid, position);      }    }    else {      const size_type old_size = size();      const size_type len = old_size + max(old_size, n);      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        new_finish = uninitialized_copy(start, position, new_start);        new_finish = uninitialized_copy(first, last, new_finish);        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef __STL_USE_EXCEPTIONS      catch(...) {        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      destroy(start, finish);      deallocate();      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#else /* __STL_MEMBER_TEMPLATES */template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position,                               const_iterator first,                               const_iterator last) {  if (first != last) {    size_type n = 0;    distance(first, last, n);    if (size_type(end_of_storage - finish) &gt;= n) {      const size_type elems_after = finish - position;      iterator old_finish = finish;      if (elems_after &gt; n) {        uninitialized_copy(finish - n, finish, finish);        finish += n;        copy_backward(position, old_finish - n, old_finish);        copy(first, last, position);      }      else {        uninitialized_copy(first + elems_after, last, finish);        finish += n - elems_after;        uninitialized_copy(position, old_finish, finish);        finish += elems_after;        copy(first, first + elems_after, position);      }    }    else {      const size_type old_size = size();      const size_type len = old_size + max(old_size, n);      iterator new_start = data_allocator::allocate(len);      iterator new_finish = new_start;      __STL_TRY {        new_finish = uninitialized_copy(start, position, new_start);        new_finish = uninitialized_copy(first, last, new_finish);        new_finish = uninitialized_copy(position, finish, new_finish);      }#         ifdef __STL_USE_EXCEPTIONS      catch(...) {        destroy(new_start, new_finish);        data_allocator::deallocate(new_start, len);        throw;      }#         endif /* __STL_USE_EXCEPTIONS */      destroy(start, finish);      deallocate();      start = new_start;      finish = new_finish;      end_of_storage = new_start + len;    }  }}#endif /* __STL_MEMBER_TEMPLATES */#if defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)#pragma reset woff 1174#endif__STL_END_NAMESPACE #endif /* __SGI_STL_INTERNAL_VECTOR_H */// Local Variables:// mode:C++// End:</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator_Traits</title>
      <link href="/2021/07/12/ComputerBasics/CPP/STL/Iterator_Traits/"/>
      <url>/2021/07/12/ComputerBasics/CPP/STL/Iterator_Traits/</url>
      
        <content type="html"><![CDATA[<h1 id="Iterator需要遵循的原则"><a href="#Iterator需要遵循的原则" class="headerlink" title="Iterator需要遵循的原则"></a>Iterator需要遵循的原则</h1><ul><li>iterator是算法和容器之间的桥梁</li><li>iterator必须有能力回答algorithm的提问<ul><li>总共有5中iterator的相关类型: iterator_category,value_type,pointer,reference,difference_type</li></ul></li></ul><h1 id="iterator的相关类型"><a href="#iterator的相关类型" class="headerlink" title="iterator的相关类型"></a>iterator的相关类型</h1><p><img src="iterator_associated_types.jpg" alt></p><h1 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h1><ul><li>迭代器的5个关联类型在类中均有定义,但是指针类型的关联类型需要根据指针类别进行确定,为了使STL算法同时兼容迭代器和一般指针,就在迭代器(指针)和算法之间加一个中间层萃取器(traits).</li><li>迭代器萃取器iterator_traits的目的就是能够兼容迭代器和一般指针,获取其5个关联类型:iterator_category、value_type、difference_type、pointer和pointer.<ul><li>就是这个traits能够分别它所获得的iterator是(1)class iterator T或是(2)native pointer to T.</li><li>利用parital specialization可达到目标.</li></ul></li></ul><p><img src="iterator_traits.jpg" alt></p><hr><ul><li>在实现上,iterator_traits类使用模板的偏特化(范围上),对于一般的迭代器类型,直接取迭代器内部定义的关联类型;对于指针和常量指针进行偏特化,指定关联类型的值.<br>```cpp<br>// 针对一般的迭代器类型,直接取迭代器内定义的关联类型<br>template<class i><br>struct iterator_traits {<br>  typedef typename I::iterator_category     iterator_category;<br>  typedef typename I::value_type             value_type;<br>  typedef typename I::difference_type     difference_type;<br>  typedef typename I::pointer             pointer;<br>  typedef typename I::reference             reference;<br>};</class></li></ul><p>// 针对指针类型进行特化,指定关联类型的值<br>template<class t><br>struct iterator_traits<t *> {<br>    typedef random_access_iterator_tag         iterator_category;<br>    typedef T                                 value_type;<br>    typedef ptrdiff_t                         difference_type;<br>    typedef T*                                pointer;<br>    typedef T&amp;                                reference;<br>};</t></class></p><p>// 针对指针常量类型进行特化,指定关联类型的值<br>template<class t><br>struct iterator_traits<const t *> {<br>    typedef random_access_iterator_tag         iterator_category;<br>    typedef T                                 value_type;        // value_tye被用于声明变量,而声明一个无法被赋值的变量没什么用,<br>                                                            // 所以iterator的value type不应该加上const<br>    typedef ptrdiff_t                         difference_type;<br>    typedef const T*                        pointer;<br>    typedef const T&amp;                        reference;<br>};</const></class></p><pre><code>* 想要在算法内获取关联类型的值,只需像下面这样写:```cpptemplate&lt;typename T&gt;void algorithm(...) {    typename iterator_traits&lt;I&gt;::value_type v1;}</code></pre><h1 id="各种各样的traits"><a href="#各种各样的traits" class="headerlink" title="各种各样的traits"></a>各种各样的traits</h1><ul><li>type traits</li><li>iterator traits</li><li>char traits</li><li>allocator traits</li><li>pointer traits</li><li>array traits</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2021/07/05/Algorithm/String/"/>
      <url>/2021/07/05/Algorithm/String/</url>
      
        <content type="html"><![CDATA[<h1 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h1><h2 id="BF-暴力"><a href="#BF-暴力" class="headerlink" title="BF(暴力)"></a>BF(暴力)</h2><pre><code class="lang-cpp">* 遍历所有的字符串可能性,然后与模式串进行比较.class Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size();        int n = needle.size();        if(n==0) return 0;        for(int i = 0; i &lt;= m-n; ++i)        {            int j;            for(j = 0; j &lt; n; ++j)            {                if(haystack[i+j] != needle[j])                    break;            }            if(j == n) return i;        }        return -1;    }};</code></pre><ul><li>时间复杂度:O(MN)<ul><li>最坏情况:每次与模式串最后一个关键字不同,导致遍历了所有字符串可能性.</li></ul></li><li>空间复杂地:O(1)</li></ul><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul><li>参考:<a href="https://www.zhihu.com/question/21923021/answer/1032665486" target="_blank" rel="noopener">如何更好地理解和掌握 KMP 算法?</a></li><li>参考:<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/" target="_blank" rel="noopener">宫水三叶】简单题学 KMP 算法</a></li><li>王道数据结构</li></ul><hr><ul><li>KMP的关键点<ul><li>求next数组<ul><li>next[i]表示匹配串中前i个字符中前缀和后缀字符相同的最大个数.<ul><li>普通的next数组的方法为n^2</li><li>利用next[i-1]的值可以递推出next[i]的值<ul><li>如果next[i-1] = k,则子串中前k个字符和后k个字符相同,只需比较s[k]和s[i]的大小<ul><li>如果 s[k] == s[i],则next[i] = next[i-1]+1;</li><li>如果 s[k] != s[i],这时候需要看前缀的不匹配位置前的子串,通过将s[next[k-1]]和s[i]比较.不断重复该操作直到为0或者达到匹配.<ul><li>这一步相当于拿needle的前缀去匹配后缀,得到前缀和后缀中的最大子前缀和后缀相同的大小.(具体可以看王道)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>匹配过程和求next数组类似</li></ul></li></ul><pre><code class="lang-cpp">class Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size();        int n = needle.size();        if(n==0) return 0;        // 生成next数组        // 该next数组为非优化的,next[i]表示前i个字符的最大前后缀个数        vector&lt;int&gt; next(n,0);        next[0] = 0;        int j = 0;        for(int i = 1; i &lt; n; ++i)        {            while(j &gt; 0 &amp;&amp; needle[i] != needle[j])            {                //这一步相当于拿needle的前缀去匹配后缀,得到前缀和后缀中的最大子前缀和后缀相同的大小.                j = next[j-1];            }            if(needle[i] == needle[j])                ++j;            next[i] = j;        }        j = 0;        for(int i = 0; i &lt; m; ++i)        {            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j])                j = next[j-1];            if(haystack[i] == needle[j])                ++j;            if(j == n)                return i - n+1;        }        return -1;        return 0;    }};</code></pre><h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><ul><li>待补</li></ul><h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><ul><li>待补</li></ul><h2 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h2><ul><li>待补</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法</title>
      <link href="/2021/07/04/Algorithm/Graphy/"/>
      <url>/2021/07/04/Algorithm/Graphy/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h2><h2 id="djikstra"><a href="#djikstra" class="headerlink" title="djikstra"></a>djikstra</h2><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman_ford"></a>Bellman_ford</h2><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><h2 id="floyed"><a href="#floyed" class="headerlink" title="floyed"></a>floyed</h2><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><h2 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h2><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2021/07/04/Algorithm/Search/"/>
      <url>/2021/07/04/Algorithm/Search/</url>
      
        <content type="html"><![CDATA[<h1 id="线性结构查找"><a href="#线性结构查找" class="headerlink" title="线性结构查找"></a>线性结构查找</h1><ul><li>顺序查找</li><li>折半查找</li><li>分块查找</li></ul><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote><p>参考:学堂在线,邓俊辉,数据结构</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>持久性(一致性)结构：支持对历史版本的访问<br>T.serach(ver(版本号),key)</li></ul></blockquote><ul><li>蛮力实现:每个版本独立保存,各版本入口自成一个搜索结构.</li></ul><p><img src="Persistent_Structure_1.jpg" alt></p><blockquote><p>单次操作o(logh + logn),累计o(hn)时间和空间,累计空间复杂度是o(hn)是因为每次都要保存前一个版本的结点 // h = |history|</p></blockquote><ul><li>O(1)重构:对树形结构的拓扑而言,相邻版本之间的差异不能超过O(1)<ul><li>任何一次动态操作引发的结构变化量不超过O(1)<h2 id="红黑树概念"><a href="#红黑树概念" class="headerlink" title="红黑树概念"></a>红黑树概念</h2></li></ul></li><li>红黑树是由红、黑两类结点组成的BST(统一增设外部结点NULL,使之成为真二叉树)<blockquote><p>真二叉树:所有节点的度都要么为0，要么为2。</p><ul><li>1.树根:必为黑色</li><li>2.外部结点:均为黑色</li><li>3.其余结点:若为红、则只能有黑孩子(当前结点为红,其父亲结点和孩子结点都为黑)</li><li>4.外部结点到根:途中黑结点数据相等(黑深度)</li></ul></blockquote></li></ul><hr><ul><li>性质3.作用:红色结点经过提升变换后(将黑色结点提高到与黑父亲同一高度的位置,类似b树)之后,所有叶子结点都在同一层.<ul><li>提升后的红黑树就是4阶b树(2,4-树)</li></ul></li></ul><p><img src="RBTree_BTree.jpg" alt></p><h2 id="红黑树操作接口"><a href="#红黑树操作接口" class="headerlink" title="红黑树操作接口"></a>红黑树操作接口</h2><pre><code class="lang-cpp">template &lt;typename T&gt; calss RedBlack : public BST&lt;T&gt;{public:    //BST::Serach()的其余接口都可直接沿用    BinNodePosi(T) insert(const T&amp; e);//插入    bool remove(const T&amp; e );//删除protected:    void solveDoubleRed(BiNodePosi(T) x);//双红修正    void solveDoubleBlack(BiNodePosi(T) x);//双黑修正    int updateHeight(BinNOdePosi(T) x);//更新结点x的高度(黑高度)};</code></pre><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><pre><code class="lang-md">* 现拟插入关键码e //T中不含e* 按照BST的常规算法,插入之 // x = insert(e)必为末端结点    * 不妨设x的父亲p = x-&gt;parent存在 //否则,即平凡的首次插入* 将x染红(除非它是根)    * 此时条件1,2,4必然满足</code></pre><h3 id="情况1-插入结点为根结点"><a href="#情况1-插入结点为根结点" class="headerlink" title="情况1:插入结点为根结点"></a>情况1:插入结点为根结点</h3><ul><li>此时染为黑色</li></ul><h3 id="情况2-插入结点不为根结点"><a href="#情况2-插入结点不为根结点" class="headerlink" title="情况2:插入结点不为根结点"></a>情况2:插入结点不为根结点</h3><h4 id="情况2-1-插入结点的父亲结点p为黑色"><a href="#情况2-1-插入结点的父亲结点p为黑色" class="headerlink" title="情况2.1:插入结点的父亲结点p为黑色."></a>情况2.1:插入结点的父亲结点p为黑色.</h4><ul><li>此时满足条件3,保持为红色<h4 id="情况2-2-插入结点的父亲结点p为红色"><a href="#情况2-2-插入结点的父亲结点p为红色" class="headerlink" title="情况2.2:插入结点的父亲结点p为红色."></a>情况2.2:插入结点的父亲结点p为红色.</h4></li><li>此时不满足条件3:产生双红缺陷<ul><li>此时需要考虑该节点的叔叔结点(祖先结点的另一个孩子)</li></ul></li></ul><p><img src="双红缺陷.jpg" alt></p><h5 id="情况2-2-1-叔叔结点为黑色-包括叔叔结点为外部（也是黑色）结点"><a href="#情况2-2-1-叔叔结点为黑色-包括叔叔结点为外部（也是黑色）结点" class="headerlink" title="情况2.2.1:叔叔结点为黑色(包括叔叔结点为外部（也是黑色）结点)"></a>情况2.2.1:叔叔结点为黑色(包括叔叔结点为外部（也是黑色）结点)</h5><h6 id="情况2-2-1-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR"><a href="#情况2-2-1-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR" class="headerlink" title="情况2.2.1.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)"></a>情况2.2.1.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)</h6><ul><li>以LL为例,将红色结点都向上提升,形成(a’)的4阶b树,可以看到.按照规则,含有3个关键字的四阶b树,其关键字如果含有2个红色结点,必然为<code>RBR</code>结构.</li><li>所以只需要按照图中结构,让p变为黑,g变为红即可.</li></ul><p><img src="RRBLL.jpg" alt></p><h6 id="情况2-2-1-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL"><a href="#情况2-2-1-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL" class="headerlink" title="情况2.2.1.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)"></a>情况2.2.1.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)</h6><ul><li>以RL为例,将红色结点都向上提升,形成(B’)的4阶b树按照规则,含有3个关键字的四阶b树,其关键字如果含有2个红色结点,必然为<code>RBR</code>结构.<br><img src="RRBRL.jpg" alt></li><li>并且要求该子结构为如图c和c’的类型.</li></ul><p><img src="RRBStandard.jpg" alt></p><ul><li>一次需要先对x结点做左旋操作,然后再按照(a’)方式进行染色.（即x为黑,g为红）</li></ul><hr><ul><li>通过b树来理解双红缺陷(黑叔叔)<ul><li>在某个三叉结点中插入红关键码,使得原黑关键字不再居中.<ul><li>RRB or BRR,出现相邻的红关键码</li></ul></li></ul></li></ul><h5 id="情况2-2-2-叔叔结点为红色"><a href="#情况2-2-2-叔叔结点为红色" class="headerlink" title="情况2.2.2:叔叔结点为红色"></a>情况2.2.2:叔叔结点为红色</h5><h6 id="情况2-2-2-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR"><a href="#情况2-2-2-1-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的左孩子-LL-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的右孩子-RR" class="headerlink" title="情况2.2.2.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)"></a>情况2.2.2.1:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的左孩子(LL) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的右孩子(RR)</h6><ul><li>以LL为例,将红色结点向上提升,形成(a’)的b书,可以看到该4阶b树发生了上溢,需要按照b树的规则对其进行分裂.所以将红黑树中的双红缺陷转换为了b树中的上溢缺陷.</li></ul><p><img src="RRRLL.jpg" alt></p><ul><li>对a对应的b树做分裂操作,如图(c’),将中间结点(即染为红色)提升,剩下的左右子孩子,将中间关键字染为红色,周围关键字染为黑色.</li></ul><p><img src="RRRLL_Btree.jpg" alt></p><ul><li>同样,将g结点提升之后需要考虑g的父亲结点是否会产生双红缺陷.重复考虑类似的插入操作.</li></ul><h6 id="情况2-2-2-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL"><a href="#情况2-2-2-2-插入结点为父亲结点的左孩子-并且父亲结点是爷爷结点的右孩子-LR-插入结点为父亲结点的右孩子-并且父亲结点是爷爷结点的左孩子-RL" class="headerlink" title="情况2.2.2.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)"></a>情况2.2.2.2:插入结点为父亲结点的左孩子,并且父亲结点是爷爷结点的右孩子(LR) || 插入结点为父亲结点的右孩子,并且父亲结点是爷爷结点的左孩子(RL)</h6><ul><li>以RL为例,类似于情况2.2.2.1.</li></ul><p><img src="RRRRL.jpg" alt></p><hr><ul><li>总结<ul><li>重构,染色操作均属于常熟时间的局部操作,股只需统计总次数.</li><li>红黑树的每一次插入操作都可在o(logn)时间内完成</li><li>其中至多做: o(logn)次结点染色,一次旋转操作.</li></ul></li></ul><div class="table-container"><table><thead><tr><th>情况</th><th>旋转次数</th><th>染色次数</th><th>伺候</th></tr></thead><tbody><tr><td>uncle为黑</td><td>1轮2次</td><td>2</td><td>调整随机完成</td></tr><tr><td>uncle为红</td><td>0</td><td>3</td><td>可能再次双红,但必上升两层. </td></tr></tbody></table></div><ul><li>流程图</li></ul><p><img src="RBTreeInsert.png" alt></p><h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a>散列表(哈希表)</h1><ul><li>散列函数:一个把查找表中的关键字映射成该关键字对应的地址的函数,记为<ul><li>Hash(key) = Addr</li></ul></li><li>冲突:散列函数可能会把两个或两个以上的不同关键字映射到同一地址</li><li>同义词:发生碰撞的不同关键字</li><li>散列表:根据关键字而直接进行访问的数据结构散列表建立了关键字和存储地址之间的一种直接映射关系.</li></ul><h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><ul><li>散列函数的特点<ul><li>定义域包括全部需要存储的关键字,值域取决于散列表的大小或地址范围</li><li>散列函数计算出来的地址应该等概率、均匀地分布在整个地址空间内,减少冲突的发生.</li><li>散列函数应该尽量简答,能够在短时间内计算出任意关键字的散列地址.</li></ul></li></ul><hr><ul><li><p>直接定址法 : H(key) = key or H(key) = a * key + b</p><ul><li>取关键字的某个线性函数值作为散列地址</li><li>均匀也不会产生冲突</li><li>适合查找表较小且连续的情况,不连续会造成空间浪费</li></ul></li><li><p>除留余数法: H(key) = key % p</p><ul><li>p为不大于散列表长m但最接近或等于m的质数</li><li>p决定了造成冲突的可能性</li></ul></li><li><p>数字分析法:</p><ul><li>如果关键字是位数较多的数字，且这些数字部分存在相同规律则可以采用抽取剩余不同规律部分作为散列地址</li><li>例如手机:前3位接入号,中间4位HLR识别号,后4位用户号,选择后四位作为散列地址就是不错的选择</li><li>可以对这些抽出来的数字进行<strong>反转</strong>,<strong>左移</strong>,<strong>右移</strong>等操作<ul><li>目的：尽量合理地将关键字分配到散列表的各个位置</li></ul></li><li>适合处理关键字位数比较大的情况,事先知道关键字的分布且关键字的若干位分布较均匀.</li></ul></li><li><p>平方取中法:</p><ul><li>即取关键字平方的中间位数作为散列地址</li><li>例如:比如假设关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址</li><li>适合于不知道关键字的分布，而位数又不是很大的情况</li></ul></li><li><p>折叠法:</p><ul><li>折将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些,然后将这几部分叠加求和,并按散列表表长，取后几位作为散列地址</li><li>例如:比如假设关键字是 9876543210，散列表表长为三位,则我们可以将它分为四组 987|654|321|0,然后将它们叠加求和 987+654+321+0=1962,再取后 3 位得到散列地址即为 962</li><li>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况</li></ul></li><li><p>随机数法: H(key) = random(key)</p><ul><li>取关键字的随机函数值为它的散列地址</li><li>当关键字的长度不等时采用这个方法构造散列函数是比较合适的</li></ul></li></ul><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul><li>任何散列函数都不能绝对地避免冲突.需要为发生冲突的关键字寻找下一个Hash地址.</li><li>Hi表示处理冲突中第i次探测得到的散列地址.</li></ul><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><ul><li>开放定址法:可存放新关键字的空间地址既向它的同义词表项开放,又向她的非同义词表项开放.<ul><li>$H_{i} = (H(key) + d_{i})$ % m<ul><li>m为散列表长</li><li>$d_{i}$为增量序列</li></ul></li></ul></li></ul><hr><ul><li><p>线性探测法</p><ul><li>$d_{i}$ = 0,1,2,…,m-1</li><li>冲突发生时,顺序查看表中下一个单元(循环探测),直到找到一个空闲单元或查遍全表</li><li>问题:容易造成大量元素在相邻的散列地址上聚集起来,大大降低了查找效率<ul><li>使得第i个散列地址的同义词存入i+1个散列地址,本应存入第i+1个散列地址的元素只能存入第i+2个散列地址.</li></ul></li></ul></li><li><p>平方(二次)探测法</p><ul><li>$d_{i} = 0^{2},1^{2},-1^{2},2^{2},-2^{2},…,k^{2},-k^{2}$<ul><li>k &lt;= m/2</li><li>m 必须是一个可以表示成4k+3的素数</li></ul></li><li>避免堆积问题,但不能探测散列表上的所有元素,但至少能探测到一半单元</li></ul></li><li><p>再散列法</p><ul><li>$d_{i} = Hash_{2}(key)$</li><li>$H_{i} = (H(key)+i*Hash_{2}(key))%m</li><li>第一个散列函数用于得到地址,当发生冲突时使用第二个散列函数</li></ul></li><li><p>伪随机序列法</p><ul><li>$d_{i} = 伪随机序列$</li></ul></li></ul><hr><ul><li>在开放定址法中,不能物理删除已有元素,会阶段其他具有相同散列地址的元素.</li><li>只能利用删除标记做逻辑删除</li><li>需要定期维护散列表</li></ul><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><ul><li>把同义词存储在一个线性链表中,这个线性链表由其散列地址唯一识别.</li><li>拉链法适用于经常进行插入和删除的情况.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂</title>
      <link href="/2021/07/04/ComputerBasics/DesignPatterns/AbstactFactory/"/>
      <url>/2021/07/04/ComputerBasics/DesignPatterns/AbstactFactory/</url>
      
        <content type="html"><![CDATA[<h1 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h1><ul><li>通过”对象创建”模式绕开new,来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创建的稳定.它是接口抽象之后的第一步工作.</li><li><p>典型模式</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li><li><p>为什么要绕开new?</p><ul><li>根据<code>依赖倒置原则</code>,在代码实现中不应该出现<code>细节依赖</code>（出现依赖具体类）,应该使用抽象接口,但是抽象接口无法实例化,所以需要绕开new</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常面临着”<strong>一系列相互依赖的对象</strong>“的创建工作;同时,由于需求的变化,往往存在更多系列对象的创建工作.</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>提供一个接口,让该接口负责创建一系列”相关或者相互依赖的对象”,无需指定它们具体的类<ul><li>就是让一个抽象类包含一组相互关联的抽象积累的工厂类中的创建函数(相当于工厂家族?)</li></ul></li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Abstract_Factory.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li>如果没有应对”多系列对象构建”的需求变化,则没有必要使用抽象工厂模式,这时候使用简单的工厂完全可以.</li><li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系.不同系列的对象之间不能相互依赖.</li><li>抽象工厂模式主要在于应对”新系列”的需求变动.其缺点在于难以应对”新对象”的需求变动.<ul><li>指代的是在在抽象工厂中难以添加新的创建函数(因为要求稳,你瞎改的话还用什么设计模式)</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="普通工厂"><a href="#普通工厂" class="headerlink" title="普通工厂"></a>普通工厂</h2><ul><li>代码复杂冗余,而且容易导致相互关联的对象之间不匹配.<br>```cpp<br>//数据库访问有关的基类<br>class IDBConnection{</li></ul><p>};<br>class IDBConnectionFactory{<br>public:<br>    virtual IDBConnection* CreateDBConnection()=0;<br>};</p><p>class IDBCommand{</p><p>};<br>class IDBCommandFactory{<br>public:<br>    virtual IDBCommand* CreateDBCommand()=0;<br>};</p><p>class IDataReader{</p><p>};<br>class IDataReaderFactory{<br>public:<br>    virtual IDataReader* CreateDataReader()=0;<br>};</p><p>//支持SQL Server<br>class SqlConnection: public IDBConnection{</p><p>};<br>class SqlConnectionFactory:public IDBConnectionFactory{</p><p>};</p><p>class SqlCommand: public IDBCommand{</p><p>};<br>class SqlCommandFactory:public IDBCommandFactory{</p><p>};</p><p>class SqlDataReader: public IDataReader{</p><p>};<br>class SqlDataReaderFactory:public IDataReaderFactory{</p><p>};</p><p>//支持Oracle<br>class OracleConnection: public IDBConnection{</p><p>};</p><p>class OracleCommand: public IDBCommand{</p><p>};</p><p>class OracleDataReader: public IDataReader{</p><p>};</p><p>class EmployeeDAO{<br>    IDBConnectionFactory<em> dbConnectionFactory;<br>    IDBCommandFactory</em> dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;</p><p>public:<br>    vector<employeedo> GetEmployees(){<br>        IDBConnection* connection =<br>            dbConnectionFactory-&gt;CreateDBConnection();<br>        connection-&gt;ConnectionString(“…”);</employeedo></p><pre><code>    IDBCommand* command =        dbCommandFactory-&gt;CreateDBCommand();    command-&gt;CommandText(&quot;...&quot;);    command-&gt;SetConnection(connection); //关联性    IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性    while (reader-&gt;Read()){    }}</code></pre><p>};</p><pre><code>## 抽象工厂```cpp//数据库访问有关的基类class IDBConnection{};class IDBCommand{};class IDataReader{};class IDBFactory{public:    virtual IDBConnection* CreateDBConnection()=0;    virtual IDBCommand* CreateDBCommand()=0;    virtual IDataReader* CreateDataReader()=0;};//支持SQL Serverclass SqlConnection: public IDBConnection{};class SqlCommand: public IDBCommand{};class SqlDataReader: public IDataReader{};class SqlDBFactory:public IDBFactory{public:    virtual IDBConnection* CreateDBConnection()=0;    virtual IDBCommand* CreateDBCommand()=0;    virtual IDataReader* CreateDataReader()=0;};//支持Oracleclass OracleConnection: public IDBConnection{};class OracleCommand: public IDBCommand{};class OracleDataReader: public IDataReader{};class EmployeeDAO{    IDBFactory* dbFactory;public:    vector&lt;EmployeeDO&gt; GetEmployees(){        IDBConnection* connection =            dbFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(&quot;...&quot;);        IDBCommand* command =            dbFactory-&gt;CreateDBCommand();        command-&gt;CommandText(&quot;...&quot;);        command-&gt;SetConnection(connection); //关联性        IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性        while (reader-&gt;Read()){        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2021/07/04/ComputerBasics/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2021/07/04/ComputerBasics/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么要用面向对象设计?<ul><li>变化是复用的天敌,面向对象设计最大的优势在于:抵御变化</li></ul></li></ul><h1 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h1><ul><li>隔离变化<ul><li>从宏观层面来看,面向对象的构建方式更能适应软件的变化,能将变化所带来的影响力减为最小.</li></ul></li><li>各司其职<ul><li>从微观层面来看,面向对象的方式更强调各个类的”责任”</li><li>由于需求变化导致的新增类型不应该影响原理类型的实现—是所谓各负其责</li></ul></li><li>对象是什么?<ul><li>从语言实现层面来看,对象封装了代码和数据</li><li>从规格层面讲,对象是一些列可使用的公共接口</li><li>从概念层面讲,对象是某种拥有责任的抽象</li></ul></li></ul><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h2><ul><li>高层模块(稳定)不应该依赖于底层模块(变化),二者都应该依赖于抽象(稳定)<ul><li>高层模块不应该直接依赖于某个具体类,而应该依赖某个抽象接口,而具体类由抽象接口继承得到.</li></ul></li><li>抽象(稳定)不应该依赖于实现细节(变化),实现细节应该依赖于抽象（稳定）<ul><li>抽象接口应使用虚函数来把持高层模块调用时的统一,将具体实现细节交给子类.</li></ul></li></ul><h2 id="开放封闭原侧-OCP"><a href="#开放封闭原侧-OCP" class="headerlink" title="开放封闭原侧(OCP)"></a>开放封闭原侧(OCP)</h2><ul><li>对扩展开放,对更改封闭</li><li>类模块应该是可扩展的,但是不可修改的.</li></ul><h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h2><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><h2 id="Liskov替换原则-LSP"><a href="#Liskov替换原则-LSP" class="headerlink" title="Liskov替换原则(LSP)"></a>Liskov替换原则(LSP)</h2><ul><li>子类必须能够替换它们的积累(IS-A)</li><li>继承表达类型抽象</li></ul><h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul><h1 id="优先使用对象组合-而不是类继承"><a href="#优先使用对象组合-而不是类继承" class="headerlink" title="优先使用对象组合,而不是类继承"></a>优先使用对象组合,而不是类继承</h1><ul><li>类继承通常为”白箱复用”,对象组合通常为”黑箱复用”.</li><li>继承在某种程度上破坏封装性,子类父类耦合度高.</li><li>而对象组合只要求被组合的对象具有良好的接口,耦合度低</li></ul><h1 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h1><ul><li>使用封装层来创建对象之间的分界层,让设计者可以在分界层的一测进行修改,而uhuidui另一侧产生不良的影响,从而实现层之间的松耦合.</li></ul><h1 id="针对接口编程-而不是针对实现编程"><a href="#针对接口编程-而不是针对实现编程" class="headerlink" title="针对接口编程,而不是针对实现编程"></a>针对接口编程,而不是针对实现编程</h1><ul><li>不将变量类型声明为某个特定的具体类,而是声明为某个接口.</li><li>客户程序无需获知对象的具体类型,只需要知道对象所具有的接口.</li><li>减少系统中各部分的依赖关系,从而实现”高内聚、松耦合”的类型设计方案.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法</title>
      <link href="/2021/07/04/ComputerBasics/DesignPatterns/Factory/"/>
      <url>/2021/07/04/ComputerBasics/DesignPatterns/Factory/</url>
      
        <content type="html"><![CDATA[<h1 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h1><ul><li>通过”对象创建”模式绕开new,来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创建的稳定.它是接口抽象之后的第一步工作.</li><li><p>典型模式</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Bilder</li></ul></li><li><p>为什么要绕开new?</p><ul><li>根据<code>依赖倒置原则</code>,在代码实现中不应该出现<code>细节依赖</code>（出现依赖具体类）,应该使用抽象接口,但是抽象接口无法实例化,所以需要绕开new</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常面临着创建对象的工作;由于需求的变化,需要创建的对象的具体类型经常变化</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>定义一个用于创建对象的接口(工厂基类),让子类决定实例化哪一个类.Factory Method使得一个类的实例化延迟(目的:结构,手段:虚函数)到子类.</li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Factory_Method.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系.面对一个经常变化的具体类型,紧耦合关系(new)会导致软件的脆弱.</p></li><li><p>Factory Method模式通过<strong>面向对象(多态)</strong>的手法,将所要创建的具体对象的工作延迟到子类,从而实现一种扩展(而非更改)的策略,较好地解决了这种紧耦合关系</p></li><li><p>Factory Method模式解决”当个对象”的需求变化.缺点在于要要求创建方法/参数相同</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="不适用工厂导致紧耦合关系-new"><a href="#不适用工厂导致紧耦合关系-new" class="headerlink" title="不适用工厂导致紧耦合关系(new)"></a>不适用工厂导致紧耦合关系(new)</h2><ul><li>这种紧耦合关系会导致在需求变化的情况下不断地修改源代码.</li></ul><pre><code class="lang-cpp">// 设计糟糕,只能支持具体类void Button1_Click(){    ISplitter * splitter= new BinarySplitter();//依赖具体类    splitter-&gt;split();}// 理想但是虚函数无法实例化void Button1_Click(){    ISplitter * splitter= new ISplitter();//依赖具体类    splitter-&gt;split();}</code></pre><h2 id="工厂基类"><a href="#工厂基类" class="headerlink" title="工厂基类"></a>工厂基类</h2><ul><li>工厂基类用于扩展不同的具体工厂.</li><li>而每一个具体工厂提供一种具体的对象生成函数,其返回父类接口的指针,这样在对象生成的时候可以保持代码一致.</li></ul><pre><code class="lang-cpp">//工厂基类class SplitterFactory{public:    virtual ISplitter* CreateSplitter()=0;    virtual ~SplitterFactory(){}};//具体工厂class BinarySplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new BinarySplitter();    }};class TxtSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new TxtSplitter();    }};class PictureSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new PictureSplitter();    }};class VideoSplitterFactory: public SplitterFactory{public:    virtual ISplitter* CreateSplitter(){        return new VideoSplitter();    }};</code></pre><hr><pre><code class="lang-cpp">//抽象类class ISplitter{public:    virtual void split()=0;    virtual ~ISplitter(){}};//具体类class BinarySplitter : public ISplitter{};class TxtSplitter: public ISplitter{};class PictureSplitter: public ISplitter{};class VideoSplitter: public ISplitter{};</code></pre><hr><pre><code class="lang-cpp">* 使用是时候通过构造函数从外面传进一个工厂实例,这样在这个文件中的代码非常稳定,不需要进行更改.//使用方法class MainForm : public Form{    SplitterFactory*  factory;//工厂public:    MainForm(SplitterFactory*  factory){        this-&gt;factory=factory;    }    void Button1_Click(){           ISplitter * splitter=            factory-&gt;CreateSplitter(); //多态new               splitter-&gt;split();    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2021/06/26/ComputerBasics/DesignPatterns/Decorator/"/>
      <url>/2021/06/26/ComputerBasics/DesignPatterns/Decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul><li><p>在软件组件的设计中,如果责任划分的不清晰,使用继承得到的结果往往是随着需求的变化,子类急剧膨胀,同时充斥着重复代码,这时候的关键是划清责任.</p></li><li><p>典型模式</p><ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li><p>过渡地使用继承来扩展对象的功能,由于继承为类型引入的静态特质(各种子类定死的调用方式,组合中的多态就是非静态特质),使得这种扩展方式缺乏灵活性,并且随着子类的增多(扩展功能的增多),各种子类的组合(扩展功能的组合)会导致更多子类的膨胀</p></li><li><p>需要使”对象功能的扩展”能够根据需要来动态地实现.同时避免”扩展功能的增多”带来的子类膨胀问题.从而使得任何”功能扩展变化”所导致的影响降为最低。</p></li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>动态(组合)地给一个对象增加一些额外的职责.就增加功能而言,Decorator模式比生成子类(继承)更为灵活(消除重复代码 &amp; 减少子类个数)</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="Decroator_Structure.jpg" alt></p><ul><li>Component和Decorator是不变的类<ul><li>Decorator拥有Component并继承自Component,实际表现功能的是组合,继承是为了完善纯虚类的接口.</li></ul></li><li>其他是变化的类<ul><li>在调用不同的ConcreteDecorator的时候通过传入不同的ConcreteComponent,然后利用多态在运行时处理不同的额外功能.</li></ul></li></ul><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>通过采用组合而非继承的手法,Decorator模式实现了在<strong>运行时</strong>动态扩展对象功能的能力,而且可以根据需要扩展多个功能.避免了使用继承带来的”灵活性差”和”多子类衍生问题”</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系,即Decorator类继承了Component类所具有的接口.但在实现上又表现为has-a Component的组合关系,即Decorator类又使用了另外一个Component类.</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题,Decorator模式应用的要点在于解决”主体类在多个方向上的扩展功能”——是为装饰器的含义.</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="编译时装配"><a href="#编译时装配" class="headerlink" title="编译时装配"></a>编译时装配</h2><ul><li>对于类似的类需要每次继承基类并添加上类似的功能,使得代码变得冗余.(对继承的不良使用)</li></ul><p><img src="Decroator_1.jpg" alt></p><pre><code class="lang-cpp">//业务操作class Stream{public：    virtual char Read(int number)=0;    virtual void Seek(int position)=0;    virtual void Write(char data)=0;    virtual ~Stream(){}};//主体类class FileStream: public Stream{public:    virtual char Read(int number){        //读文件流    }    virtual void Seek(int position){        //定位文件流    }    virtual void Write(char data){        //写文件流    }};class NetworkStream :public Stream{public:    virtual char Read(int number){        //读网络流    }    virtual void Seek(int position){        //定位网络流    }    virtual void Write(char data){        //写网络流    }};class MemoryStream :public Stream{public:    virtual char Read(int number){        //读内存流    }    virtual void Seek(int position){        //定位内存流    }    virtual void Write(char data){        //写内存流    }};//扩展操作class CryptoFileStream :public FileStream{public:    virtual char Read(int number){        //额外的加密操作...        FileStream::Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        FileStream::Seek(position);//定位文件流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        FileStream::Write(data);//写文件流        //额外的加密操作...    }};class CryptoNetworkStream : :public NetworkStream{public:    virtual char Read(int number){        //额外的加密操作...        NetworkStream::Read(number);//读网络流    }    virtual void Seek(int position){        //额外的加密操作...        NetworkStream::Seek(position);//定位网络流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        NetworkStream::Write(data);//写网络流        //额外的加密操作...    }};class CryptoMemoryStream : public MemoryStream{public:    virtual char Read(int number){        //额外的加密操作...        MemoryStream::Read(number);//读内存流    }    virtual void Seek(int position){        //额外的加密操作...        MemoryStream::Seek(position);//定位内存流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        MemoryStream::Write(data);//写内存流        //额外的加密操作...    }};class BufferedFileStream : public FileStream{    //...};class BufferedNetworkStream : public NetworkStream{    //...};class BufferedMemoryStream : public MemoryStream{    //...}class CryptoBufferedFileStream :public FileStream{public:    virtual char Read(int number){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Seek(position);//定位文件流        //额外的加密操作...        //额外的缓冲操作...    }    virtual void Write(byte data){        //额外的加密操作...        //额外的缓冲操作...        FileStream::Write(data);//写文件流        //额外的加密操作...        //额外的缓冲操作...    }};void Process(){        //编译时装配    CryptoFileStream *fs1 = new CryptoFileStream();    BufferedFileStream *fs2 = new BufferedFileStream();    CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream();}</code></pre><h2 id="运行时装配"><a href="#运行时装配" class="headerlink" title="运行时装配"></a>运行时装配</h2><ul><li>合理利用多态以及类的组合(将继承改为组合),消除大量的重复代码</li></ul><p><img src="Decroator_2.jpg" alt></p><pre><code class="lang-cpp">/业务操作class Stream{public：    virtual char Read(int number)=0;    virtual void Seek(int position)=0;    virtual void Write(char data)=0;    virtual ~Stream(){}};//主体类class FileStream: public Stream{public:    virtual char Read(int number){        //读文件流    }    virtual void Seek(int position){        //定位文件流    }    virtual void Write(char data){        //写文件流    }};class NetworkStream :public Stream{public:    virtual char Read(int number){        //读网络流    }    virtual void Seek(int position){        //定位网络流    }    virtual void Write(char data){        //写网络流    }};class MemoryStream :public Stream{public:    virtual char Read(int number){        //读内存流    }    virtual void Seek(int position){        //定位内存流    }    virtual void Write(char data){        //写内存流    }};//扩展操作DecoratorStream: public Stream{ // 这里这个继承是为了CryptoStream等类继承这个装饰器类时,能保证Read等接口是virtual的保证统一.protected:    Stream* stream;//...    DecoratorStream(Stream * stm):stream(stm){    }};class CryptoStream: public DecoratorStream {public:    CryptoStream(Stream* stm):DecoratorStream(stm){    }    virtual char Read(int number){         //额外的加密操作...        stream-&gt;Read(number);//读文件流    }    virtual void Seek(int position){        //额外的加密操作...        stream::Seek(position);//定位文件流        //额外的加密操作...    }    virtual void Write(byte data){        //额外的加密操作...        stream::Write(data);//写文件流        //额外的加密操作...    }};class BufferedStream : public DecoratorStream{    Stream* stream;//...public:    BufferedStream(Stream* stm):DecoratorStream(stm){     }    //...};void Process(){    //运行时装配    FileStream* s1=new FileStream();    CryptoStream* s2=new CryptoStream(s1); //将文件流传入,CryptoStream实现加密操作    BufferedStream* s3=new BufferedStream(s1);//将文件流传入,BufferedStream实现缓存操作    BufferedStream* s4=new BufferedStream(s2);//将加密文件流传入,会先缓存再加密再执行流操作.}</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥模式</title>
      <link href="/2021/06/26/ComputerBasics/DesignPatterns/Bridge/"/>
      <url>/2021/06/26/ComputerBasics/DesignPatterns/Bridge/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul><li><p>在软件组件的设计中,如果责任划分的不清晰,使用继承得到的结果往往是随着需求的变化,子类急剧膨胀,同时充斥着重复代码,这时候的关键是划清责任.</p></li><li><p>典型模式</p><ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>由于某些类型的固有的实现逻辑,使得它们具有两个变化的维度,乃至多个维度的变化.</li></ul><h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><ul><li>将抽象部分(业务功能)与实现平台(平台实现)分离,使他们都可以独立地变化.</li></ul><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img src="Bridge.jpg" alt></p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li><p>Bridge模式使用”对象间的组合关系”解耦了抽象和实现之间固有的绑定关系,使得抽象和实现可以沿着各自的维度来变化.所谓抽象和实现沿着各自维度的变化,即”子类化”它们.</p></li><li><p>Bridge模式有时候类似于多继承方案,但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因),复用性比较差.Brige模式是比多继承方案更好的解决方法.</p></li><li><p>Bridge模式的应用一般在”两个非常强的变化维度”,有时一个类也有多于两个的变化维度,这时可以使用Bridge的扩展模式</p><ul><li>在Abstractor中含有多个Implemtor的指针.</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="lang-cpp">class Messager{ // 这个相当于UML图中的Abstraction,用于放置一部分的抽象,这里是消息机制中的各种业务抽象protected:     MessagerImp* messagerImp;//通过组合(has-a)的方式在两个维度的变化组合在一起,如果有多个强变化的维度,可以在这里加多个指针public:    virtual void Login(string username, string password)=0;    virtual void SendMessage(string message)=0;    virtual void SendPicture(Image image)=0;    virtual ~Messager(){}};class MessagerImp{ //这个相当于UML图中的Implmentor,用于放置另一部分变化维度比较明显的的抽象,比如这里放置的是与平台相关的功能实现public:    virtual void PlaySound()=0;    virtual void DrawShape()=0;    virtual void WriteText()=0;    virtual void Connect()=0;    virtual MessagerImp(){}};//平台实现 nclass PCMessagerImp : public MessagerImp{public:    virtual void PlaySound(){        //**********    }    virtual void DrawShape(){        //**********    }    virtual void WriteText(){        //**********    }    virtual void Connect(){        //**********    }};class MobileMessagerImp : public MessagerImp{public:    virtual void PlaySound(){        //==========    }    virtual void DrawShape(){        //==========    }    virtual void WriteText(){        //==========    }    virtual void Connect(){        //==========    }};//业务抽象 m//类的数目：1+n+mclass MessagerLite :public Messager {public:    virtual void Login(string username, string password){        messagerImp-&gt;Connect();        //........    }    virtual void SendMessage(string message){        messagerImp-&gt;WriteText();        //........    }    virtual void SendPicture(Image image){        messagerImp-&gt;DrawShape();        //........    }};class MessagerPerfect  :public Messager {public:    virtual void Login(string username, string password){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;Connect();        //........    }    virtual void SendMessage(string message){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;WriteText();        //........    }    virtual void SendPicture(Image image){        messagerImp-&gt;PlaySound();        //********        messagerImp-&gt;DrawShape();        //........    }};void Process(){    //运行时装配    //  首先通过多态声明使用的是哪个平台的抽象    //  然后再通过构造函数传递Implmentor来实现运行时多态,达到组合各个维度代码的功能.    MessagerImp* mImp=new PCMessagerImp();    Messager *m =new MessagerLite(mImp);}</code></pre><h1 id="桥接模式与装饰器模式的区别"><a href="#桥接模式与装饰器模式的区别" class="headerlink" title="桥接模式与装饰器模式的区别"></a>桥接模式与装饰器模式的区别</h1><ul><li>主要区别需要通过UML图来说明.<ul><li>可以看到对于桥接模式来说,它是将抽象类(接口)的功能划分为两个(多个)维度,分为absraction和implmentor,absraction通过组合的方式拥有implmentor.两个分别进行继承,生成具体的类.通过运行时多态和参数传递(构造函数)的方法来实现多个功能的组合.</li><li>装饰模式中的装饰器类是一个单独的类,他即包含Component(即抽象接口)的指针(has-a)又继承自Component(is-a),其中is-a的部分是让具体的实现继承自装饰器并且保证抽象接口函数的结构统一.而has-a的部分是Compoent的变化维度,用于实现多个功能的组合.可以看出装饰器模式是不进行抽象维度划分的.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/06/24/Algorithm/UnionFind/"/>
      <url>/2021/06/24/Algorithm/UnionFind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章:<a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">算法学习笔记(1) : 并查集</a><br>参考文章:<a href="https://leetcode-cn.com/circle/discuss/3dPiT7/" target="_blank" rel="noopener">分享｜（建议收藏）LeetCoder 并查集模板</a></p></blockquote><h1 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h1><ul><li>并查集有两个操作,合并和查询,用一个元素代表与其关联的一类元素,可以有效解决集合或者图中的连通性问题.</li></ul><h1 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h1><ul><li>初始化操作让每个元素的自己单独为一个集合,但实际应用的时候应根据题意初始化并查集.</li></ul><pre><code class="lang-cpp">//最基础的并查集初始化int fa[MAXN];inline void init(int n){    for (int i = 1; i &lt;= n; ++i)        fa[i] = i;}</code></pre><h1 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h1><ul><li>查询操作用于查询某一个元素属于哪一个集合,这个集合由一个元素代表,返回这个代表元素<pre><code class="lang-cpp">inline int find(x){  if(fa[x] != x)      return find(fa[x]);  else      return x;}</code></pre></li></ul><h1 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h1><ul><li>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。<pre><code class="lang-cpp">inline void merge(int x,int y){  int findx = find(x);  int findy = find(y);  fx[findy] = findy;}</code></pre></li></ul><h1 id="优化1-路径压缩"><a href="#优化1-路径压缩" class="headerlink" title="优化1:路径压缩"></a>优化1:路径压缩</h1><ul><li>路径压缩用于解决并查集合并过程中可能导致深度过高,造成查询效率下降的问题.</li><li>路径压缩就说:要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</li></ul><pre><code class="lang-cpp">inline int find(int x){    if(find(x) == x)        return x;    else    {        fa[x] = find(fa[x]);        return fa[x];    }}//极简写法inline int find(int x){    return x == fa[x] ? x : (fa[x] = find(fa[x]));}</code></pre><h1 id="优化2-按秩合并"><a href="#优化2-按秩合并" class="headerlink" title="优化2:按秩合并"></a>优化2:按秩合并</h1><ul><li>路径压缩优化后，并查集并非都是一个菊花图（只有两层的树的俗称）<ul><li>只有在路径压缩时才会优化某一条路径,所以某一时刻的并查集可能比较复杂</li></ul></li><li>对于复杂的两个并查集合并,更好的做法是将深度低的并查集合并到深度深的并查集上,这样不会造成合并后并查集深度增加.<ul><li>因此对每一个并查集用rank表示其深度,在合并是根据rank值进行合并</li><li>注意如果深度相同并且不是同一个并查集,进行合并后rank会+1</li></ul></li></ul><pre><code class="lang-cpp">inline void merge(int x,int y){    int findx = find(x);    int findy = find(y);    if(rank[x] &gt; rank[y])        fa[findy] = findx;    else        fa[findx] = findy;    if(rank[findx] == rank[findy] &amp;&amp; findx != findy)        rank[findy]++; }</code></pre><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre><code class="lang-cpp">//模板//https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/class UnionFind{private:    vector&lt;int&gt; fa;    vector&lt;int&gt; rank;    int count;public:    UnionFind(){}    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid)//Init    {        count = 0;        int m = grid.size();        int n = grid[0].size();        fa.resize(n*m,0);        rank.resize(n*m,0);        for(int i = 0; i &lt; grid.size();++i)        {            for(int j = 0; j &lt; grid[0].size();++j)            {                if(grid[i][j] == &#39;1&#39;)                {                    fa[i*n+j] = i*n+j;                    ++count;                }                else                    fa[i*n+j] = -1;                rank[i*n+j] = 1;            }        }    }    inline int find(int x)    {        return x == fa[x]? x : (fa[x] = find(fa[x]));    }    inline void merge(int x,int y)    {        int fx = find(x);        int fy = find(y);        if(rank[fx] &gt; rank[fy])            fa[fy] = fx;        else            fa[fx] = fy;        if(rank[fx] == rank[fy] &amp;&amp; fx != fy)            rank[fy]++;        if(fx != fy)            --count;    }    inline int getCount()    {        return count;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/2021/06/23/ComputerBasics/CSAPP/Linking/"/>
      <url>/2021/06/23/ComputerBasics/CSAPP/Linking/</url>
      
        <content type="html"><![CDATA[<h1 id="链接简介"><a href="#链接简介" class="headerlink" title="链接简介"></a>链接简介</h1><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><ul><li><strong>链接</strong>是将各种代码和数据片段收集并组合称为一个单一文件的过程,这个文件可被加载(复制)到内存并执行.</li></ul><h2 id="链接的时期"><a href="#链接的时期" class="headerlink" title="链接的时期"></a>链接的时期</h2><ul><li>链接可以执行于<strong>编译时</strong>(源代码被翻译成机器代码时),<strong>加载时</strong>(程序被加载器加载到内存并执行时),<strong>运行时</strong>(程序运行的时候)</li></ul><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><ul><li>现代操作系统中,链接由连接器自动执行.</li><li>连接器使得程序可以<strong>分离编译</strong><ul><li>将大型程序分成一个个模块,单独编译,并进行链接.当需要修改某一模块时,只需重新编译某一模板并重新链接即可</li></ul></li></ul><h1 id="编译器驱动程序-程序编译过程"><a href="#编译器驱动程序-程序编译过程" class="headerlink" title="编译器驱动程序(程序编译过程)"></a>编译器驱动程序(程序编译过程)</h1><ul><li>示例程序<br>```cpp<br>/<em>code/link/main.c</em>/<br>int sum(int *a,int n);</li></ul><p>int array[2] = {1,2};</p><p>int main()<br>{<br>    int val = sum(array,2);<br>    return val;<br>}</p><pre><code>```cpp/* code/link/sum.c */int sum(int *a,int n){    int i,s=0;    for(i = 0; i &lt; n; ++i)    {        s+=a[i];    }    return s;}</code></pre><hr><ul><li>编译器驱动程序:用于调用语言预处理器、编译器、汇编器和链接器.</li><li>下图概括驱动程序将实例程序从ASCII码源文件翻译成可执行目标文件时的行为(静态链接).</li></ul><p><img src="Complie_Procedural.jpg" alt></p><ul><li>上图的编译过程如下<ul><li>main.c通过C预处理器(cpp)将C的源程序翻译成ACII码的中间文件main.i</li><li>main.i通过c编译器(cc1)将ACII码的中间文件翻译成ASCII汇编语言文件main.s</li><li>main.s通过汇编器(as)将ASCII汇编语言文件翻译成可重定位目标文件main.o</li><li>所有.o文件和一些必要的系统目标文件通过连接器程序(ld)组合起来创建一个可执行目标文件</li></ul></li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><ul><li>什么是静态链接？<ul><li>静态链接是静态链接器以一组<code>可重定位目标文件</code>和<code>命令行参数</code>作为输入,生成一个<code>完全链接的</code>、<code>可以加载</code>和<code>运行</code>的可执行目标木剑作为输出.<ul><li>可重定位文件由不同的代码和数据节组成，每一节都是一个连续的字节序列.<ul><li>指令,初始化的全局变量,未初始化的变量在不同的节中.</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p>连接器的主要任务</p><ul><li>符号解析<ul><li>任务:目标文件定义和引用符号<ul><li>每个符号对应一个函数、一个全局变量或一个静态变量</li></ul></li></ul></li><li><p>目的:将每个符号引用正好和一个符号定义关联起来.</p></li><li><p>重定位:</p><ul><li>任务:编译器和汇编器生成从地址0开始的代码和数据节.</li><li>目的: <ul><li>连接器将符号定义与内存位置进行关联.然后修改这些符号的引用,使它们指向相应的内存位置.</li><li>链接器使用汇编器产生的重定位条目的详细指令,不加甄别地执行这样的重定位.</li></ul></li></ul></li></ul></li></ul><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><ul><li>可重定位目标文件:包含二进制代码和数据,可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件.</li><li>可执行目标文件:包含二进制代码和数据,可以直接复制到内存并执行.</li><li>共享目标文件:特殊的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接</li></ul><hr><ul><li>其中编译器和汇编器生成<strong>可重定位目标文件</strong>和<strong>共享目标文件</strong>,连接器生成<strong>可执行目标文件</strong></li><li>目标模块:一个字节序列<ul><li>目标文件:一个以特定的文件形式存放在磁盘中的目标模块</li></ul></li></ul><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p><img src="ELF_HEADER_FILE.jpg" alt></p><h3 id="elf可重定位目标文件字段说明"><a href="#elf可重定位目标文件字段说明" class="headerlink" title="elf可重定位目标文件字段说明"></a>elf可重定位目标文件字段说明</h3><ul><li>ELF头:<ul><li>生成该文件袋系统的字的大小和字节顺序(小端、大端)(16B)</li><li>帮助连接器语法分析和解释目标文件的信息.<ul><li>ELF头的大小,目标文件类型,机器类型(e.g. x86-64),节头部表的文件偏移,节头部表中条目的大小和数量.</li></ul></li></ul></li><li>节头部表:描述不同节的位置和大小.</li><li>.text:已经编译的程序代码.</li><li>.rodata:只读数据<ul><li>字符常量或者switch的转跳表</li></ul></li><li>.data:已经初始化的全局和静态变量,局部变量保存在栈中.</li><li>.bss:未初始化的全局和静态变量,以及被初始化为0的全局或静态变量.<ul><li>在目标文件中改节不占实际的空间,仅仅是一个占位符.</li><li>目的:提高空间效率,在磁盘中不占空间,在内存中初始化为0</li></ul></li><li>.symtab:符号表,存放程序中定义和引用的函数和全局变量(包括静态变量)的信息.<ul><li>-g编译命令可以得到符号表,还包含局部变量</li><li>.symtab中的符号表不包含局部变量的条目</li></ul></li><li>.rel.text:.text节相关的可重定位信息.<ul><li>当连接器将某个目标文件和其他目标文件组合式,.text节中的代码会被合并,相应的一些指令中引用的操作数地址信息或跳转目标指令信息等可能要被修改.</li><li>一般调用外部函数或者引用全局变量的指令中的地址字段需要修改.</li></ul></li><li>.rel.data:.data节相关的可重定位.<ul><li>当连接器将某个目标文件和其他目标文件组合式,.data节中的代码会被合并,一些全局变量的地址可能被修改.</li></ul></li><li>.debug:调试符号表</li><li>.line:原始c源程序的行号和.text节中机器指令之间的映射.(需要-g选项)</li><li>.strtab:字符串表</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/06/23/ComputerBasics/DesignPatterns/Singleton/"/>
      <url>/2021/06/23/ComputerBasics/DesignPatterns/Singleton/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://www.cnblogs.com/sunchaothu/p/10389842.html" target="_blank" rel="noopener">C++ 单例模式总结与剖析</a></p></blockquote><ul><li>对象性能模式<ul><li>面向对象很好地解决了”抽象”的问题,但会造成一定的代价.(虚函数,继承等)</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件系统中,经常有这样一些特殊的类,必须保证他们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率</li><li>具体运用场景如：<ul><li>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;</li><li>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;</li></ul></li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;</li></ul><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li>全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）</li><li>线程安全</li><li>禁止赋值和拷贝</li><li>用户通过接口获取实例：使用 static 类成员函数</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="非线程安全的懒汉模式"><a href="#非线程安全的懒汉模式" class="headerlink" title="非线程安全的懒汉模式"></a>非线程安全的懒汉模式</h2><ul><li><code>懒汉式(Lazy-Initialization)</code>的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。</li></ul><pre><code class="lang-cpp">#include &lt;iostream&gt;// version1:// with problems below:// 1. thread is not safe// 2. memory leakclass Singleton{private:    Singleton();    ~Singleton(){}    Singleton(Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;    static Singleton* m_instance_ptr;public:    static Singleton* get_instance(){        if(m_instance_ptr==nullptr){              m_instance_ptr = new Singleton;        }        return m_instance_ptr;    }};Singleton* Singleton::m_instance_ptr = nullptr;</code></pre><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>线程安全的问题<ul><li>当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来</li><li>解决办法:加锁</li></ul></li><li>内存泄漏<ul><li>注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏</li><li>解决办法：使用共享指针</li></ul></li></ul><h2 id="线程安全、内存安全的懒汉模式-双检查锁"><a href="#线程安全、内存安全的懒汉模式-双检查锁" class="headerlink" title="线程安全、内存安全的懒汉模式(双检查锁)"></a>线程安全、内存安全的懒汉模式(双检查锁)</h2><pre><code class="lang-cpp">#include &lt;memory&gt; // shared_ptr#include &lt;mutex&gt;  // mutex// version 2:// with problems below fixed:// 1. thread is safe now// 2. memory doesn&#39;t leakclass Singleton{public:    typedef std::shared_ptr&lt;Singleton&gt; Ptr;    static Ptr get_instance(){        // &quot;double checked lock&quot;        if(m_instance_ptr==nullptr){            std::lock_guard&lt;std::mutex&gt; lk(m_mutex);            if(m_instance_ptr == nullptr){              m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(new Singleton);            }        }        return m_instance_ptr;    }private:    ~Singleton(){}    Singleton(Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;    static Ptr m_instance_ptr;    static std::mutex m_mutex;};// initialization static variables out of classSingleton::Ptr Singleton::m_instance_ptr = nullptr;std::mutex Singleton::m_mutex;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。</li><li>加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为双检锁(双检查锁)；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。<ul><li><strong>单检查锁</strong>的代价过高,单锁的话线程每次访问都会加锁,但是在创建出来单例以后线程都是读操作,并不需要加锁了.这样导致每次只能一个线程读,造成效率下降.<pre><code class="lang-cpp">Singleton* Singleton::getInstance() {  Lock lock;  if (m_instance == nullptr) {      m_instance = new Singleton();  }  return m_instance;}</code></pre></li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>该方法会由于内存读写reorder导致不安全<ul><li>前提:线程时间片轮转,执行的是汇编指令</li><li>所以对于c++代码在编译器进行优化以后,代码的执行顺序不一定是C++代码的逻辑顺序</li></ul></li><li>可能发生的错误情况<ul><li>在单列赋值的过程中,一般顺序是<code>分配内存空间-&gt;调用构造器-&gt;范围内存地址</code>,但可能编译器优化成<code>分配内存空间-&gt;范围内存地址-&gt;调用构造器</code>,这将可能导致threadB访问的时候直接范围未初始化好的单列,导致错误.</li></ul></li><li>解决方法: atomic</li></ul><hr><ul><li>使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; </li></ul><h2 id="atomic的可跨平台的双检查线程安全的单列模式"><a href="#atomic的可跨平台的双检查线程安全的单列模式" class="headerlink" title="atomic的可跨平台的双检查线程安全的单列模式"></a>atomic的可跨平台的双检查线程安全的单列模式</h2><ul><li>要注意c/c++的标准中volatile无法解决多线程问题,只有msvc这个垃圾方言实现了防止reorder的产生.<ul><li><a href="https://www.cnblogs.com/zhao-zongsheng/p/9092520.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhao-zongsheng/p/9092520.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33074506</a></li></ul></li></ul><pre><code class="lang-cpp">std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() {    Singleton* tmp = m_instance.load(std::memory_order_relaxed);    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence    if (tmp == nullptr) {        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);        tmp = m_instance.load(std::memory_order_relaxed);        if (tmp == nullptr) {            tmp = new Singleton;            std::atomic_thread_fence(std::memory_order_release);//释放内存fence            m_instance.store(tmp, std::memory_order_relaxed);        }    }    return tmp;}</code></pre><h2 id="基于C-11-magic-static的懒汉单例模式"><a href="#基于C-11-magic-static的懒汉单例模式" class="headerlink" title="基于C++11 magic static的懒汉单例模式"></a>基于C++11 magic static的懒汉单例模式</h2><ul><li><p>C++11标准中的Magic Static</p><ul><li>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</li><li>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</li></ul></li><li><p>static的声明周期(为什么可以这么写?)</p><ul><li>参考:<a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function" target="_blank" rel="noopener">What is the lifetime of a static variable in a C++ function?</a></li><li>The lifetime of function <code>static</code> variables begins the first time the program flow encounters the declaration and it ends at program termination. —- Motti<ul><li>Since C++98 has no reference to multiple threads how this will be behave in a multi-threaded environment is unspecified</li><li>In C++11 statics are initialized in a thread safe way, this is also known as Magic Statics.</li></ul></li><li>Compilers typically use a hidden flag variable to indicate if the local statics have already been initialized, and this flag is checked on every entry to the function. —-Roddy</li></ul></li></ul><pre><code class="lang-cpp">#include &lt;iostream&gt;class Singleton{public:    static Singleton&amp; get_instance(){        static Singleton instance;        return instance;    }private:    Singleton()    ~Singleton()    Singleton(const Singleton&amp;)=delete;    Singleton&amp; operator=(const Singleton&amp;)=delete;};</code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。<ul><li>这样做并不好，理由主要是无法避免用户使用delete instance导致对象被提前销毁。还是建议大家使用返回引用的方式。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2021/06/23/ComputerBasics/DesignPatterns/Observer/"/>
      <url>/2021/06/23/ComputerBasics/DesignPatterns/Observer/</url>
      
        <content type="html"><![CDATA[<h1 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h1><ul><li>组件协作模式:通过晚期绑定,来实现框架与应用程序之间的松耦合,是两者之间协作时常用的模式<ul><li>Templated Method</li><li>Strategy</li><li>Observer / Event</li></ul></li></ul><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul><li>在软件构建过程中,我们需要为某些对象建立一种”通知依赖关系”(类似回调)<ul><li>一个对象(目标对象)的状态发生改变,所有的依赖对象(观察者对象)都将得到通知.</li><li>如果这样的依赖关系过于紧密，软件将不能很好的抵御变化<ul><li>通过面向对象,弱化依赖关系,达到软件的松耦合</li></ul></li></ul></li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>定义对象间一种一对多(变化)的依赖关系,以便当一个对象(Subject)的状态发生改变时,所有依赖于它的对象都得到通知并自动更新.</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="观察者模式UML图.jpg" alt></p><ul><li>其中Subject和Observer是系统中不变的部分</li><li>ConcreteSubject和ConcreteObserver是系统是变化的部分</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li>用进度调更新来举例<br>```cpp<br>//IProgress是一个接口(纯虚类)相当于类图里的Observer<br>class IProgress{<br>public:<br>  virtual void DoProgress(float value)=0;<br>  virtual ~IProgress(){}<br>};</li></ul><p>// ConsoleNotifier是一个观察者,里面有实现的适用于自己的DoProgress.其一定要继承IProgress<br>class ConsoleNotifier : public IProgress {<br>public:<br>    virtual void DoProgress(float value){<br>        cout &lt;&lt; “.”;<br>    }<br>};</p><p>// MainForm是另一个观察者,里面有实现的适用于自己的DoProgress,也是创建Subjct的地方.<br>class MainForm : public Form, public IProgress<br>{<br>    ProgressBar* progressBar;</p><p>public:<br>    void Button1_Click(){<br>        string filePath = txtFilePath-&gt;getText();<br>        int number = atoi(txtFileNumber-&gt;getText().c_str());</p><pre><code>    //ConsoleNotifier观察者的对象    ConsoleNotifier cn;    //构建Subject并把观察者加入进去    FileSplitter splitter(filePath, number);    splitter.addIProgress(this);     splitter.addIProgress(&amp;cn);    //切分文本的功能,里面会调用进度条更新    splitter.split();    //移除观察者    splitter.removeIProgress(this);}virtual void DoProgress(float value){    progressBar-&gt;setValue(value);}</code></pre><p>};</p><p>// 对应类图里的Subject,用于实现对象中不变的部分<br>class Subject<br>{<br>private:<br>    List<iprogress*>  m_iprogressList; // 抽象通知机制，支持多个观察者<br>public:<br>    void addIProgress(IProgress* iprogress){<br>        m_iprogressList.push_back(iprogress);<br>    }</iprogress*></p><pre><code>void removeIProgress(IProgress* iprogress){    m_iprogressList.remove(iprogress);}</code></pre><p>protected:<br>    virtual void onProgress(float value){<br>        List<iprogress*>::iterator itor=m_iprogressList.begin();<br>        while (itor != m_iprogressList.end() )<br>            (*itor)-&gt;DoProgress(value); //更新进度条<br>            itor++;<br>        }<br>    }<br>};</iprogress*></p><p>class FileSplitter : public Subject<br>{<br>private:<br>    string m_filePath;<br>    int m_fileNumber;<br>public:<br>    FileSplitter(const string&amp; filePath, int fileNumber) :<br>        m_filePath(filePath),<br>        m_fileNumber(fileNumber)<br>        {}<br>    }</p><pre><code>void split(){    //1.读取大文件    //2.分批次向小文件中写入    for (int i = 0; i &lt; m_fileNumber; i++){        //...        float progressValue = m_fileNumber;        progressValue = (i + 1) / progressValue;        onProgress(progressValue);//发送通知    }}</code></pre><p>};</p><p>```</p><h1 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h1><ul><li>使用面向对象的抽象,Observer模式使得我们可以独立地改变目标与观察者,从而使两者之间的依赖关系达到松耦合</li><li>目标发送通知时,无需指定观察者,通知(可以携带通知信息作为参数)会自动传播.</li><li>观察这自己决定是否订阅通知,目标对象对此一无所知</li><li>Observer模式是基于时间的UI框架中非常常用的设计模式,也是MVC模式的一个重要组成部分.</li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2021/06/15/Algorithm/Sort/"/>
      <url>/2021/06/15/Algorithm/Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li><p>基本原理:每次将一个待排序的元素按其关键字大小插入到前面已经排好序的子序列中,直到全部记录插入完成.</p></li><li><p>插入排序在待排序列为<strong>正序</strong>时最优,时间复杂度为$O(N)$,在<strong>逆序</strong>时最差,时间复杂度为$O(N^{2})$</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3></li><li>伪代码:</li></ul><pre><code class="lang-md">1.查找出L(i)在L[1...i-1]中的插入位置k.2.将L[k..i-1]中所有元素一次后移一个位置3.将L[i]复制到L(k).</code></pre><ul><li>C++代码</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; InsertSort(vector&lt;int&gt;&amp; nums) {    for(int i = 1; i &lt; nums.size();++i)    {        int t = nums[i];        int j = 0;        for(j = i-1; j &gt;= 0 &amp;&amp; t &lt; nums[j]; --j)            nums[j+1] = nums[j];        nums[j+1] = t;    }    return nums;}</code></pre><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ul><li>直接插入排序中,对于查找插入的位置通过$O(N)$的方法按顺序遍历</li><li>因为前面待插入部分已经排好序,所以利用二分法可以减少元素的比较次数<ul><li>比较次数从$O(N^{2})$降为$O(log_{2}N)$</li></ul></li><li>但是插入的时候仍要在数组平移仍需O(N)的复杂度</li><li>所以,折半插入排序的复杂度仍为$O(N^{2})$</li></ul><hr><ul><li>C++代码</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; HalfInsertSort(vector&lt;int&gt;&amp; nums) {    for(int i = 1; i &lt; nums.size();++i)    {        int t = nums[i];        int lo = 0, hi =i-1;        while(lo &lt;= hi)        {            int mid = lo + (hi-lo)/2;            if(nums[i] &gt; nums[mid]) lo = mid+1;            else if(nums[i] &lt;= nums[mid])   hi = mid-1;        }        for(int j = i-1;j &gt;= lo;--j)            nums[j+1] = nums[j];        nums[lo] = t;    }    return nums;}</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>又名<strong>缩小增量排序</strong>:</li><li>排序过程:<ul><li>先取一个小于N的步长d1,把表中的全部记录分成d1组,所有距离为d1的倍数的记录放在同一组,在各组内进行直接插入排序.</li><li>然后取第二个步长d2 &lt; d1,重复上述过程</li><li>直到所取到的dt=1,即所有记录已放在同一组,再进行直接插入排序,由于此时已经具有较好的局部有序性,故可以很快得到最终结果.</li></ul></li><li>平均时间复杂度:$O(N^{1.3})$</li><li>最坏时间复杂度”$O(N^{2}$</li></ul><pre><code class="lang-cpp">vector&lt;int&gt; ShellSort(vector&lt;int&gt;&amp; nums) {    for(int s = nums.size()/2; s &gt; 0; s/=2)    {        for(int i = s; i &lt; nums.size();++i)        {            int t = nums[i];            int j;            for(j = i-s; j &gt;=0 &amp;&amp; t &lt; nums[j] ; j-=s)            {                nums[j+s] = nums[j];            }            nums[j+s] = t;        }    }    return nums;}</code></pre><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul><li>算法原理:根据序列中两个元素关键字的比较结果来对换这个记录在序列中的位置,以此来达到序列的有序.<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3></li><li><p>基本思想:每次两两比较相邻的元素的值,若为逆序则交换它们,知道序列比较完.以此冒泡排序可以确定一个元素的位置.最多n-1趟冒泡就能把所有元素排好序.</p></li><li><p>朴素冒泡排序</p></li></ul><pre><code class="lang-cpp">vector&lt;int&gt; BubbleSort(vector&lt;int&gt;&amp; nums) {    int n = nums.size();    bool  flag = false;    for(int i = 0; i &lt; n; ++i)    {         for(int j = 1; j &lt; n-i; ++j)        {            if(nums[j] &lt; nums[j-1])            {                swap(nums[j-1],nums[j]);                flag = false;            }        }        if(flag) break;    }    return nums;}</code></pre><ul><li>优化<ul><li>每次冒泡时判断是否发生了交换,如果未发生交换说明已经拍好序,直接退出</li></ul></li></ul><pre><code class="lang-cpp">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        for(int i = 0; i &lt; n; ++i)        {             bool flag = false; //记录本次冒泡是否已经排好序(即是否发生交换)            for(int j = 1; j &lt; n-i; ++j)            {                if(nums[j] &lt; nums[j-1])                {                    swap(nums[j-1],nums[j]);                    flag = true;                }            }            if(!flag) break;        }        return nums;    }</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="朴素快速排序"><a href="#朴素快速排序" class="headerlink" title="朴素快速排序"></a>朴素快速排序</h4><pre><code class="lang-cpp">int Partition(vector&lt;int&gt;&amp; nums,int i,int j){    int pviot = nums[i];    while(i &lt; j)    {        for(;i &lt; j &amp;&amp; nums[j] &gt;= pviot; --j);        nums[i] = nums[j];        for(;i &lt; j &amp;&amp; nums[i] &lt; pviot; ++i);        nums[j] = nums[i];    }    nums[i] = pviot;    return i;}void quickSort(vector&lt;int&gt;&amp; nums,int i ,int j){    if(i &lt; j)    {        int pviotPos = Partition(nums,i,j);        quickSort(nums,i,pviotPos-1);        quickSort(nums,pviotPos+1,j);    }}</code></pre><h4 id="非递归朴素快排-用栈"><a href="#非递归朴素快排-用栈" class="headerlink" title="非递归朴素快排(用栈)"></a>非递归朴素快排(用栈)</h4><ul><li><p>利用栈模拟快排</p><pre><code class="lang-cpp">void nrQuickSort(vector&lt;int&gt;&amp; nums,int i,int j){  stack&lt;int&gt; s;  s.push(i);  s.push(j);  while(!s.empty())  {      //框定范围      int right = s.top();      s.pop();      int left = s.top();      s.pop();      //切分      int pviot = nums[left];      int lo = left;      int hi = right;      while(lo &lt; hi)      {          for(;lo &lt; hi &amp;&amp; nums[hi] &gt;= pviot; --hi);          nums[lo] = nums[hi];          for(;lo &lt; hi &amp;&amp; nums[lo] &lt; pviot; ++lo);          nums[hi] = nums[lo];      }      nums[lo] = pviot;      int pviotPos = lo;      //模拟递归      if( pviotPos - left &gt; 1)      {          s.push(left);          s.push(pviotPos-1);      }      if(right - pviotPos &gt; 1)      {          s.push(pviotPos+1);          s.push(right);      }  }}</code></pre></li></ul><h4 id="非递归原地快排"><a href="#非递归原地快排" class="headerlink" title="非递归原地快排"></a>非递归原地快排</h4><ul><li>待补<blockquote><p>可参考<br><a href="https://www.zhihu.com/question/48406747" target="_blank" rel="noopener">如何用非递归、不用栈的方法，实现原位（in-place）的快速排序？</a><br><a href="https://stackoverflow.com/questions/29987995/creating-quicksort-without-recursion-and-stack" target="_blank" rel="noopener">Creating quicksort without recursion and stack</a><br><a href="https://stackoverflow.com/questions/55008384/can-quicksort-be-implemented-in-c-without-stack-and-recursion/55010206" target="_blank" rel="noopener">Can quicksort be implemented in C without stack and recursion?</a></p></blockquote></li></ul><h4 id="快排优化-优化哨兵选择-元素聚集-熵最优排序-优化小数组-gt-三数取中-三向切分-插排-gt-快速三向切分"><a href="#快排优化-优化哨兵选择-元素聚集-熵最优排序-优化小数组-gt-三数取中-三向切分-插排-gt-快速三向切分" class="headerlink" title="快排优化:优化哨兵选择+元素聚集(熵最优排序)+优化小数组-&gt; 三数取中+三向切分+插排 -&gt; 快速三向切分"></a>快排优化:优化哨兵选择+元素聚集(熵最优排序)+优化小数组-&gt; 三数取中+三向切分+插排 -&gt; 快速三向切分</h4><blockquote><p>参考:算法第四版<br>参考:<a href="https://blog.staynoob.cn/post/2016/05/insertion-shell-merge-quick-sort-algorithm-3/" target="_blank" rel="noopener">聊聊4种主流排序算法(番外篇):快速排序的优化历程</a><br>参考:<a href="https://www.jianshu.com/p/671981540727" target="_blank" rel="noopener">快速排序及其优化</a></p><ul><li>优化小数组<ul><li>对于小数组,快速排序比插入排序慢<ul><li>原因:因为递归存在开销</li></ul></li><li><strong>一般在元素在5~15之间的数组大小适合用插入排序</strong></li></ul></li></ul></blockquote><ul><li><p>优化哨兵选择</p><ul><li>使用子数组的一小部分元素的中位数来切分数组<ul><li>这样可以避免所选取的哨兵处于极端情况,当哨兵是数组中位数的时候最优.</li><li>但是计算一部分元素的中位数会存在开销</li><li><strong>一般三数取中效果最好</strong></li></ul></li></ul></li><li><p>元素聚集</p><ul><li>通常实际应用中数组中会存在大量相同的元素,可以利用<code>荷兰旗问题</code>中的思想,将数组划分为小于等于和大于哨兵的三部分</li><li>这种方法是三向切分</li></ul></li><li><p>算法第四版中的方法</p><ul><li>当子数组大小 &lt;= 8 时，切换到插入排序</li><li>当子数组大小 &lt;= 40 时，使用三取样切分（median-of-3）选择切分元素</li><li>当子数组大小 &gt; 40 时，使用 Tukey’s ninther 方法选择切分元素(在)</li><li>使用Bentley-McIlroy的三向切分</li></ul></li></ul><h5 id="朴素快速三向切分"><a href="#朴素快速三向切分" class="headerlink" title="朴素快速三向切分"></a>朴素快速三向切分</h5><p><img src="Quick3Way.jpg" alt></p><pre><code class="lang-cpp">// 三数取中+朴素三向切分+插排void InsertSort(vector&lt;int&gt;&amp; nums,int i,int j){    for(int lo = i+1; lo &lt;= j; ++lo)    {        int t = nums[lo],hi;        for(hi = lo-1; hi &gt;=i ; --hi)        {            if(nums[hi] &gt; t)                nums[hi+1] = nums[hi];            else                break;        }        nums[hi+1] = t;    }}int median3(vector&lt;int&gt;&amp; nums,int i,int j,int k){    return  nums[i] &lt; nums[j] ?            (nums[j] &lt; nums[k] ?  j : (nums[i] &lt; nums[k] ?  k :  i)) :            (nums[j] &gt; nums[k] ?  j : (nums[i] &lt; nums[k] ?  i :  k)) ;    }void quick3way(vector&lt;int&gt;&amp; nums,int i ,int j){    if(i &lt; j)    {        if( j-i+1 &lt;= 8)        {            HalfInsertSort(nums,i,j);            return;        }        int pviotPos = median3(nums,i,i+(j-i)/2,j);        swap(nums[i],nums[pviotPos]);        int pviot = nums[i];        int lo = i, hi = j, p = i+1;//[i...lo)  &lt;pviot                                    //[lo...hi]  =pviot                                    //(hi...j]  &gt;pviot         while(p &lt;= hi)        {            if(nums[p] &gt; pviot)            {                swap(nums[hi--],nums[p]);            }            else if(nums[p] &lt; pviot)            {                swap(nums[lo++],nums[p++]);            }            else            {                ++p;            }        }        quick3way(nums,i,lo-1);        quick3way(nums,hi+1,j);    }}</code></pre><h5 id="Bentley-McIlroy快速三向切分"><a href="#Bentley-McIlroy快速三向切分" class="headerlink" title="Bentley-McIlroy快速三向切分"></a>Bentley-McIlroy快速三向切分</h5><ul><li>在朴素三向切分中含有大量的元素对换<ul><li>只有在元素等于pviot时才不会发生对换</li></ul></li><li>Bentley-McIlroy将元素划分为4个部分，只交换相等的元素,具体思路如下:</li></ul><p><img src="BM_Qucik3Way.jpg" alt></p><pre><code class="lang-cpp">// Bentley-McIlroy快速三向切分 伪代码1. 将数组序列划分为四部分，如图所示    nums[lo...p] == pviot    nums[q...hi] == pviot    nums[p+1...i-1] &lt; pviot    nums[j+1...q-1] &gt; pviot2. 所以,初始化下列参数    i = lo,    p = lo+1,    j = hi+1,    q = hi;    pviot = nums[lo];3. 循环处理    3.1 从左向右寻找 &gt;= pviot的元素    3.2 从右向左寻找 &lt;= pviot的元素    3.3 处理循环结束条件以及边界情况        3.3.1 当 i == j 时 判断该元素是否 == pviot,做特殊处理        3.3.2 当 i &gt;=j 时 退出循环    3.4 将左边&gt;=pviot的nums[i]与右边&lt;=pviot的nums[j]交换,维护&gt;pviot和&lt;pviot的区间    3.5 判断左边和右边是否 == pviot ,实则与相应的nums[p]和nums[q]交换维护==pviot的区间4. 将 == | &lt; | &gt; | == 的区间转换为&lt; | == | &gt; 的区间5. 递归处理</code></pre><pre><code class="lang-cpp">// 最终版:三数取中 or Tukey&#39;s ninter + Bentley-McIlroy三向切分 + 折半插排void HalfInsertSort(vector&lt;int&gt;&amp; nums,int lo,int hi){    for(int i = lo+1;i &lt;= hi; ++i)    {        int t = nums[i];        int j = 0, k = i-1;        while(j &lt;= k)        {            int mid = j + (k-j)/2;            if(nums[mid] &gt;= t)                k = mid-1;            else if(nums[mid] &lt; t)                j= mid+1;        }        for(int m = i-1;m &gt;= j; --m)            nums[m+1] = nums[m];        nums[j] = t;    }}int Mid3(vector&lt;int&gt;&amp; nums,int i ,int j ,int k){    return nums[i] &gt; nums[j] ? // i &lt; j &gt; k            nums[j] &gt; nums[k] ? j : (nums[i] &gt; nums[k] ? k : i):            nums[j] &lt; nums[k] ? j : nums[i] &gt; nums[k] ? i : k;}void BMQuick3Way(vector&lt;int&gt;&amp; nums,int i,int j){    int n = j-i+1;    if(n &lt;= 8)    {        HalfInsertSort(nums,i,j);        return;    }    int pviotpos;    int mid = i + (j-i)/2;    if(n &lt;= 40)        pviotpos = Mid3(nums,i,mid,j);    else    {        int epos = n/8;         int mid1 =  Mid3(nums,i,i+epos,i+epos+epos);        int mid2 =  Mid3(nums,mid-epos,mid,mid+epos);        int mid3 =  Mid3(nums,j-epos-epos,j-epos,j);        pviotpos =  Mid3(nums,mid1,mid2,mid3);    }    swap(nums[pviotpos],nums[i]);    int p = i,q = j+1;    int lo = i+1,hi = j;    int pviot = nums[i];    while(true)    {        for(;nums[lo] &lt; pviot; ++lo);        for(;nums[hi] &gt; pviot; --hi);        if(lo == hi &amp;&amp; nums[lo] == pviot)            swap(nums[++p],nums[lo]);        if( lo &gt;= hi)            break;        swap(nums[lo],nums[hi]);        if(nums[lo] == pviot)            swap(nums[++p],nums[lo++]);        if(nums[hi] == pviot)            swap(nums[--q],nums[hi--]);    }    lo = hi+1;//这步操作的原因是,当边界条件是nums[lo] == nums[hi] == pviot的时,lo和hi指向同一个位置 | ---- lo == hi | ------ |                //其他情况则  | ---- hi |lo --- |                //所以这一步用于保证lo和hi的相对位置,统一操作                    for(int k = i ; k &lt;= p; ++k)        swap(nums[k],nums[hi--]);    for(int k = j ; k &gt;= q; --k)        swap(nums[k],nums[lo++]);    BMQuick3Way(nums,i,hi);    BMQuick3Way(nums,lo,j);}</code></pre><h4 id="非递归三向切分"><a href="#非递归三向切分" class="headerlink" title="非递归三向切分"></a>非递归三向切分</h4><ul><li>待补</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>基本思想:每一趟(如第<code>i</code>趟)在后面<code>n-i+1</code>个待排元素中选取关键字最小的元素,作为有序子序列的第<code>i</code>个元素,知道<code>n-1</code>趟做完,待排元素只剩下1个,就不用选了.</li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ul><li>算法:</li></ul><p><img src="Sort/简单选择排序.jpg" alt></p><pre><code class="lang-cpp">vector&lt;int&gt; SelectSort(vector&lt;int&gt;&amp; nums) {    for(int i = 0; i &lt; nums.size();++i)    {        int pos = i;        for(int j = i +1 ; j &lt; nums.size();++j)        {            if(nums[j] &lt; nums[pos])                pos = j;        }        swap(nums[i],nums[pos]);    }    return nums;}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>二叉堆的定义:<blockquote><p>n个关键字序列L[1…n]称为堆 &lt;==&gt;</p></blockquote></li></ul><blockquote><p>1) L(i) &gt;= L(2i) &amp;&amp; L(i) &gt;= L(2i+1)  或者 //大顶堆<br>2) L(i) &lt;= L(2i) &amp;&amp; L(i) &lt;= L(2i+1)       //小顶堆</p></blockquote><h4 id="堆的建立-堆的元素插入"><a href="#堆的建立-堆的元素插入" class="headerlink" title="堆的建立(堆的元素插入)"></a>堆的建立(堆的元素插入)</h4><ul><li>将新元素加入到数组末尾,增加堆的大小并让这个新元素上浮(Swim)到合适的位置<h4 id="删除最大元素-堆的排序"><a href="#删除最大元素-堆的排序" class="headerlink" title="删除最大元素(堆的排序)"></a>删除最大元素(堆的排序)</h4></li><li>删除堆顶的元素(大根堆的最大元素)并将数组的最后一个元素放到堆顶,建小堆的大小并让这个元素下沉到合适的位置</li></ul><h4 id="堆排实现"><a href="#堆排实现" class="headerlink" title="堆排实现"></a>堆排实现</h4><pre><code class="lang-cpp">void swim();//向上调整,用于堆的插入和构建void sink(vector&lt;int&gt;&amp; nums,int len,int k)//向下调整,用于堆的删除和堆排序,无序数组构建二叉堆{    //从1开始的二叉树, 左孩子2 *k ,右孩子 2*k +1    ///从0开始的二叉树, 左孩子2 *k+1 ,右孩子 2*k +2    for(int i = 2 *k+1 ; i &lt; len; i = 2*i+1)    {        if(i+1 &lt; len &amp;&amp; nums[i] &lt; nums[i+1])            ++i;        if(nums[i] &gt; nums[k])        {            swap(nums[i],nums[k]);            k = i;        }        else            break;    }}void buildHeap();void heapInsert();void heapDelete();void heapSort(vector&lt;int&gt;&amp; nums,int n){    //从1开始的二叉树, n/2为最后一个分支结点    //从0开始的二叉树, (n-1)/2为最后一个分支结点    for(int i = (n-1)/2; i &gt;= 0; --i)        sink(nums,n,i);    for(int i = n-1; i &gt; 0; --i)    {        swap(nums[0],nums[i]);        sink(nums,i,0);    }}</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="递归归并排序"><a href="#递归归并排序" class="headerlink" title="递归归并排序"></a>递归归并排序</h3><pre><code class="lang-cpp">void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v(j-i+1,0);    int cnt = 0;    int lo = i,hi = mid+1;    while(lo &lt;= mid &amp;&amp; hi &lt;= j)    {        if(nums[lo] &lt; nums[hi])            v[cnt++] = nums[lo++];        else            v[cnt++] = nums[hi++];    }    while(lo &lt;= mid)        v[cnt++] = nums[lo++];    while(hi &lt;= j)        v[cnt++] = nums[hi++];    for(int k = 0 ; k &lt; cnt; ++k)    {        nums[i+k] = v[k];    }}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    if(i &lt; j)    {        int mid = i + (j-i)/2;        MergeSort(nums,i,mid);        MergeSort(nums,mid+1,j);        Merge(nums,i,mid,j);    }}</code></pre><h3 id="非递归归并排序"><a href="#非递归归并排序" class="headerlink" title="非递归归并排序"></a>非递归归并排序</h3><pre><code class="lang-cpp">void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v(j-i+1,0);    int cnt = 0;    int lo = i,hi = mid+1;    while(lo &lt;= mid &amp;&amp; hi &lt;= j)    {        if(nums[lo] &lt; nums[hi])            v[cnt++] = nums[lo++];        else            v[cnt++] = nums[hi++];    }    while(lo &lt;= mid)        v[cnt++] = nums[lo++];    while(hi &lt;= j)        v[cnt++] = nums[hi++];    for(int k = 0 ; k &lt; cnt; ++k)    {        nums[i+k] = v[k];    }}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    int  n = nums.size();    for(int sz = 1; sz &lt; n; sz += sz)//步长    {        for(int i = 0; i + sz &lt; n; i += 2*sz)        {            Merge(nums,i,i+sz-1,min(i+sz+sz-1,n-1));        }    }}</code></pre><h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><blockquote><p>参考:<a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/" target="_blank" rel="noopener">复习基础排序算法（Java）</a></p></blockquote><ul><li>特点:<ul><li>一个数该放在哪里，是由这个数本身的大小决定的，它不需要经过比较。也可以认为是哈希的思想：由数值映射地址。</li><li>因此这三种算法一定需要额外的空间才能完成排序任务，时间复杂度可以提升到O(N)，但适用场景不多，主要是因为使用这三种排序一定要保证输入数组的每个元素都在一个合理的范围内<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html" target="_blank" rel="noopener">一文弄懂计数排序算法！</a></p></blockquote></li></ul></li></ul><h4 id="基础版-时间复杂度与元素值有关-不稳定排序"><a href="#基础版-时间复杂度与元素值有关-不稳定排序" class="headerlink" title="基础版(时间复杂度与元素值有关,不稳定排序)"></a>基础版(时间复杂度与元素值有关,不稳定排序)</h4><ul><li>找出原数组中元素值最大的，记为max,最小值为min</li><li>创建一个新数组count，其长度是max-min+1，其元素默认值都为0</li><li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li><li>遍历count数组，找出其中元素值大于0的元素,并输出</li></ul><pre><code class="lang-cpp">// 参考代码public int[] countSort2(int[] A) {    // 找出数组A中的最大值、最小值    int max = Integer.MIN_VALUE;    int min = Integer.MAX_VALUE;    for (int num : A) {        max = Math.max(max, num);        min = Math.min(min, num);    }    // 初始化计数数组count    // 长度为最大值减最小值加1    int[] count = new int[max-min+1];    // 对计数数组各元素赋值    for (int num : A) {        // A中的元素要减去最小值，再作为新索引        count[num-min]++;    }    // 创建结果数组    int[] result = new int[A.length];    // 创建结果数组的起始索引    int index = 0;    // 遍历计数数组，将计数数组的索引填充到结果数组中    for (int i=0; i&lt;count.length; i++) {        while (count[i]&gt;0) {            // 再将减去的最小值补上            result[index++] = i+min;            count[i]--;        }    }    // 返回结果数组    return result;}</code></pre><h4 id="前缀和版（时间复杂度为N-稳定排序）"><a href="#前缀和版（时间复杂度为N-稳定排序）" class="headerlink" title="前缀和版（时间复杂度为N,稳定排序）"></a>前缀和版（时间复杂度为N,稳定排序）</h4><ul><li>找出数组中的最大值<code>max</code>、最小值<code>min</code>。</li><li>创建一个新数组<code>count</code>，其长度是<code>max-min</code>加<code>1</code>，其元素默认值都为<code>0</code>。</li><li>遍历原数组中的元素，以原数组中的元素作为<code>count</code>数组的索引，以原数组中的元素出现次数作为<code>count</code>数组的元素值。</li><li>对<code>count</code>数组变形，新元素的值是前面元素累加之和的值，即<code>count[i+1] = count[i+1] + count[i]</code>;</li><li>创建结果数组<code>result</code>，长度和原始数组一样。</li><li>遍历<code>数组元素</code>，<code>count[A[j]-min]-1为A[j]</code>在结果数组result中的位置,然后对<code>count[A[j]-min]</code>自减<code>1</code></li></ul><hr><ul><li>要想保证稳定排序,则最后一步时逆序遍历或者在求前缀和nums[i]的对应为为count[1…i-1]的前缀和</li></ul><pre><code class="lang-cpp">//逆序遍历public int[] countSort4(int[] A) {    // 找出数组A中的最大值、最小值    int max = Integer.MIN_VALUE;    int min = Integer.MAX_VALUE;    for (int num : A) {        max = Math.max(max, num);        min = Math.min(min, num);    }    // 初始化计数数组count    // 长度为最大值减最小值加1    int[] count = new int[max-min+1];    // 对计数数组各元素赋值    for (int num : A) {        // A中的元素要减去最小值，再作为新索引        count[num-min]++;    }    // 计数数组变形，新元素的值是前面元素累加之和的值    for (int i=1; i&lt;count.length; i++) {        count[i] += count[i-1];    }    // 创建结果数组    int[] result = new int[A.length];    // 遍历A中的元素，填充到结果数组中去，从后往前遍历    for (int j=A.length-1; j&gt;=0; j--) {        result[count[A[j]-min]-1] = A[j];        count[A[j]-min]--;    }    return result;}</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul><li>计数排序是基于关键字<code>各位(比如个十百千)</code>的大小进行排序,是一种借助多关键字排序的思想对但逻辑关键字排序的方法.</li><li>MSD(最高位优先法):按关键字位权重<code>递减</code>依次逐层划分为若干更小的子序列,最后将所有子序列依次链接成一个有序序列.</li><li>LSD(最低位优先法):按关键字位权重<code>递增</code>依次逐层划分为若干更小的子序列,最后将所有子序列依次链接成一个有序序列.</li></ul><hr><ul><li>分配操作<ul><li>创建n个空队列,每个队列枚举某个关键字的所有可能并排好序,然后依次遍历元素中当前考察关键字的大小,放入对应的队列中.</li></ul></li><li>收集操作<ul><li>将各个队列中的结点依次首尾链接,得到新的序列.</li></ul></li><li>在对每个关键字进行了分配和收集操作后将得到最终有序的数组.</li></ul><pre><code class="lang-cpp">//年前时瞎写的代码,没验证准确性#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#define SIZE 10void RadixSort(int a[]);void Traverse(int a[],int m);int temp[10][100];//临时数组（桶数组）int count[100] = {0};//桶中长度int main(void){    int a[SIZE];    srand(time(0));    int i;    for(i=0;i&lt;SIZE;i++)    {        a[i] = rand()%1000+1;    }    Traverse(a,10);    RadixSort(a);    Traverse(a,10);}int GetDigit(int a,int d)//数a，获取d位上的数{    int m[]={1,1,10,100};    return ((a/m[d])%10);}void Traverse(int a[],int m){    int i;    for(i=0;i&lt;m;i++)    {        printf(&quot;%d &quot;,a[i]);    }    printf(&quot;\n&quot;);}void RadixSort(int a[]){    int d;    int t;    int j=0;    int k=0;    int i;    int l;    for(d=1;d&lt;=3;d++)    {            for(i=0;i&lt;10;i++)        {        count[i] = -1;        }        k=0;        for( i = 0; i&lt;SIZE; i++)        {                t = GetDigit(a[i],d);            temp[t][++count[t]] = a[i];        }        for(i=0;i&lt;SIZE;i++)        {            for(l=0;l&lt;= count[i];l++)            {                a[k++] = temp[i][l];            }        }        Traverse(a,SIZE);    }}</code></pre><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li>原理：将数组按照步长放在不同的桶里，桶的数量根据数组长度和步长确定，数组全部入桶之后，每个桶内进行排序，按顺序将所有桶的数据合并。</li></ul><pre><code class="lang-java">public class Solution {    // 桶排序    // 1 &lt;= A.length &lt;= 10000    // -50000 &lt;= A[i] &lt;= 50000    // 10_0000    private static final int OFFSET = 50000;    public int[] sortArray(int[] nums) {        int len = nums.length;        // 第 1 步：将数据转换为 [0, 10_0000] 区间里的数        for (int i = 0; i &lt; len; i++) {            nums[i] += OFFSET;        }        // 第 2 步：观察数据，设置桶的个数        // 步长：步长如果设置成 10 会超出内存限制        int step = 1000;        // 桶的个数        int bucketLen = 10_0000 / step;        int[][] temp = new int[bucketLen + 1][len];        int[] next = new int[bucketLen + 1];        // 第 3 步：分桶        for (int num : nums) {            int bucketIndex = num / step;            temp[bucketIndex][next[bucketIndex]] = num;            next[bucketIndex]++;        }        // 第 4 步：对于每个桶执行插入排序        for (int i = 0; i &lt; bucketLen + 1; i++) {            insertionSort(temp[i], next[i] - 1);        }        // 第 5 步：从桶里依次取出来        int[] res = new int[len];        int index = 0;        for (int i = 0; i &lt; bucketLen + 1; i++) {            int curLen = next[i];            for (int j = 0; j &lt; curLen; j++) {                res[index] = temp[i][j] - OFFSET;                index++;            }        }        return res;    }    private void insertionSort(int[] arr, int endIndex) {        for (int i = 1; i &lt;= endIndex; i++) {            int temp = arr[i];            int j = i;            while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) {                arr[j] = arr[j - 1];                j--;            }            arr[j] = temp;        }    }}</code></pre><h1 id="内部排序性能分析"><a href="#内部排序性能分析" class="headerlink" title="内部排序性能分析"></a>内部排序性能分析</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><blockquote><ul><li>来自：<a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">wikipedia . 排序算法</a></li></ul></blockquote><ul><li>稳定性:排序过程中,相同大小的元素值在排序过后是扔保持相对位置.</li></ul><div class="table-container"><table><thead><tr><th>Name</th><th>Best</th><th>Average</th><th>Worst</th><th>Memory</th><th>Stable</th><th>Method</th><th>Array</th><th>LinkList </th></tr></thead><tbody><tr><td>插入排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Insertion</td><td>$\surd$</td><td>$\surd$ </td></tr><tr><td>折半插入排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Insertion</td><td>$\surd$</td><td>$\surd$ </td></tr><tr><td>希尔排序</td><td>$nlog_{2}{n}$</td><td>$n^{1.3}$</td><td>$n^{2[1]}$</td><td>1</td><td>No</td><td>Insertion</td><td>$\surd$</td><td>$X$ </td></tr><tr><td>冒泡排序</td><td>n</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>Yes</td><td>Exchanging</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td>快速排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$n^{2}$</td><td>$log_{2}{n}^{[2]}$</td><td>NO</td><td>Exchanging</td><td>$\surd$</td><td>$X^{[3]}$ </td></tr><tr><td>(简单)选择排序</td><td>$n^{2}$</td><td>$n^{2}$</td><td>$n^{2}$</td><td>1</td><td>$NO^{[4]}$</td><td>Selection</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td></td><td>堆排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>1</td><td>NO</td><td>Selection</td><td>$\surd$</td><td>$X$ </td></tr><tr><td></td><td>归并排序</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$nlog_{2}{n}$</td><td>$n^{[5]}$</td><td>YES</td><td>Merging</td><td>$\surd$</td><td>$\surd$</td></tr><tr><td></td><td>计数排序</td><td></td><td>$n + r^{[7]}$</td><td>$n + r$</td><td>$n + r$</td><td>YES</td><td>Non-comparison</td><td>$\surd$</td><td>$?^{[6]}$</td><td></td></tr><tr><td></td><td>基数排序</td><td></td><td>$d(n+r)^{[8]}$</td><td>$d(n+r)$</td><td>$r$</td><td>YES</td><td>Non-comparison</td><td>$\surd$</td><td>$?^{[6]}$</td></tr><tr><td></td><td>桶排序</td><td></td></tr></tbody></table></div><ul><li>[1]希尔排序的最差情况由增量序列决定,使用{n/2,n/4,…,1}的最差情况为$O(n^{2}$)</li><li>[2]快速排序的一般版本为递归实现,也可以实现非递归版本,此时空间复杂度为$O(1)$</li><li>[3]快速排序一般不用于链表排序,但是强行写也不是不行</li><li>[4]普通选择排序是不稳定的,但是如果使用新数组存储排序结果或者对链表进行排序则是稳定的<ul><li>使用新数组会导致时间复杂度为O(n)</li><li>对链表使用选择排序,每次选择最小的结点,并用头插法重新加入链表中.</li></ul></li><li>[5]对于归并排序递归和非递归都需要O(n)的空间复杂度,但是对于递归来说还需要$log_{2}{n}$的递归栈<ul><li>在提一点默认采用2路归并,对于k路归并时间复杂度为$log_{k}{n}$</li></ul></li><li>[6]实现肯定能实现但是推不推荐就不知道了</li><li>[7]这里的r是数组中的元素范围，因为计数排序需要2遍,第一遍遍历数组加入当每个桶(每个桶代表1个元素值)中,第二遍这个元素范围.</li><li>[8]r表示关键字的范围,用于元素的分配,d为需要收集分配的次数.</li></ul><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><div class="table-container"><table><thead><tr><th>Name</th><th>最好情况</th><th>最差情况</th><th>其他说明 </th></tr></thead><tbody><tr><td>插入排序</td><td>数组已经有序</td><td>数组逆序</td><td>比较次数$O(n^{2})$ </td></tr><tr><td>折半插入排序</td><td>数组已经有序</td><td>数组逆序</td><td>比较次数$O(nlog_{2}{n})$ </td></tr><tr><td>希尔排序</td><td>数组已经有序</td><td>每个步长下都是逆序</td><td></td></tr><tr><td>冒泡排序</td><td>数组已经有序</td><td>数组逆序</td><td></td></tr><tr><td>$快速排序^{[1]}$</td><td>每次划分的区域左右元素数量相等</td><td>每次快排后哨兵在最左或最右导致划分区间最大程度不对称 -&gt; 数组有序</td><td></td></tr><tr><td>(简答)选择排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>堆排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>归并排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>计数排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>基数排序</td><td></td><td></td><td>与数组元素排列无关</td></tr><tr><td>桶排序</td><td></td><td></td><td>与数组元素排列无关</td></tr></tbody></table></div><ul><li>[1] 假设快速排序每次选取最左边的元素为哨兵</li></ul><h2 id="总体小结"><a href="#总体小结" class="headerlink" title="总体小结"></a>总体小结</h2><ul><li>何时选择何种排序方法：<ul><li>待排序的记录数目n较小时，可采用插入排序和简单选择排序</li><li>若待排序记录基本有序，则采用直接插入排序或冒泡排序</li><li>n很大且关键字的位数少，采用链式基数排序较好</li><li>若n较大，则采用时间复杂度为nlogn的算法，快速排序，堆排序，归并排序</li><li>内部排序方法最好：快速排序</li><li>外部排序方法最好：归并排序</li></ul></li></ul><h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="归并排序-最合适"><a href="#归并排序-最合适" class="headerlink" title="归并排序(最合适)"></a>归并排序(最合适)</h2><h3 id="自顶向下的链表归并排序"><a href="#自顶向下的链表归并排序" class="headerlink" title="自顶向下的链表归并排序"></a>自顶向下的链表归并排序</h3><ul><li>时间复杂度:O($nlog_{2}{n}$)</li><li>空间复杂度:O($log_{2}{n}$) 递归栈</li></ul><pre><code class="lang-cpp">//伪代码1.将链表从中间断开,设断开的两个链表的头结点为left和right2.递归拆分left链表和right链表.直到无法继续拆分3.将两个链表merge.</code></pre><pre><code class="lang-cpp">ListNode* sortList(ListNode* head) {    if(!head || !head-&gt;next)  return head;    ListNode* middle = findMiddle(head);    ListNode* left = sortList(head);    ListNode* right = sortList(middle);    return merge(left,right);}ListNode* findMiddle(ListNode* head){    ListNode* root = new ListNode(-1);    root-&gt;next = head;    ListNode* slow = root;    ListNode* fast = root;    while(fast &amp;&amp; fast-&gt;next)    {        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    }    ListNode* middle = slow-&gt;next;    slow-&gt;next = nullptr;    root-&gt;next = nullptr;    delete root;    return middle;}ListNode* merge(ListNode* l ,ListNode* r){    ListNode* root = new ListNode(-1);    ListNode* p = root;    while(l &amp;&amp; r)    {        if(l-&gt;val &gt; r-&gt;val)        {            p-&gt;next = r;            r = r-&gt;next;        }        else        {            p-&gt;next = l;            l = l-&gt;next;        }        p = p-&gt;next;    }    if(l)        p-&gt;next = l;    if(r)        p-&gt;next = r;    p = root-&gt;next;    root-&gt;next = nullptr;    delete root;    return p;}</code></pre><h3 id="自底向上的链表归并排序"><a href="#自底向上的链表归并排序" class="headerlink" title="自底向上的链表归并排序"></a>自底向上的链表归并排序</h3><pre><code class="lang-cpp">ListNode* sortList(ListNode* head) {    //计算链表长度    int len = 0;    ListNode* p = head;    while(p)    {        ++len;        p = p-&gt;next;    }    ListNode* root = new ListNode(0,head);//哑结点    for(int s = 1; s &lt; len; s &lt;&lt;= 1)//步长[1,2,4,...]    {        ListNode* prev = root,*curr = prev-&gt;next;//用于切分和定位结点        while(curr)        {            ListNode* left = nullptr;            left = curr;            for(int i = 1; i &lt; s &amp;&amp; curr != nullptr; ++i)                curr = curr-&gt;next;            ListNode* right = nullptr;            if(curr)            {                right = curr-&gt;next;                curr-&gt;next = nullptr;                curr = right;            }            for(int i = 1; i &lt; s &amp;&amp; curr != nullptr; ++i)                curr = curr-&gt;next;            if(curr)            {                ListNode* next = curr-&gt;next;                curr-&gt;next = nullptr;                curr = next;            }            prev-&gt;next = merge(left,right);            while(prev-&gt;next)                prev = prev-&gt;next;        }    }    return root-&gt;next;}ListNode* merge(ListNode* l ,ListNode* r){    ListNode* root = new ListNode(-1);    ListNode* p = root;    while(l &amp;&amp; r)    {        if(l-&gt;val &gt; r-&gt;val)        {            p-&gt;next = r;            r = r-&gt;next;        }        else        {            p-&gt;next = l;            l = l-&gt;next;        }        p = p-&gt;next;    }    if(l)        p-&gt;next = l;    if(r)        p-&gt;next = r;    p = root-&gt;next;    root-&gt;next = nullptr;    delete root;    return p;}</code></pre><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="非交换值-原地"><a href="#非交换值-原地" class="headerlink" title="非交换值 + 原地"></a>非交换值 + 原地</h3><pre><code class="lang-cpp">ListNode* quickSort(ListNode* head,ListNode* tail)//排序[head,tail){    if(head == tail ||  head-&gt;next == tail) return head;    ListNode* dummy = new ListNode(-1,head);    ListNode* p = head-&gt;next;    ListNode* pviot = head;    ListNode* Rtail = pviot;    Rtail-&gt;next = nullptr;    while(p != tail)    {        ListNode* t = p-&gt;next;        if(p-&gt;val &lt; pviot-&gt;val)        {            p-&gt;next = dummy-&gt;next;            dummy-&gt;next = p;        }        else        {            Rtail-&gt;next = p;            Rtail = p;        }        p = t;    }    Rtail-&gt;next = p;    ListNode* node = quickSort(dummy-&gt;next,pviot);    pviot-&gt;next = quickSort(pviot-&gt;next,tail);    return node;   }ListNode* sortList(ListNode* head) {    return quickSort(head,nullptr);}};</code></pre><h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>待补</li></ul><h2 id="简单排序-插入-冒泡-选择"><a href="#简单排序-插入-冒泡-选择" class="headerlink" title="简单排序(插入/冒泡/选择)"></a>简单排序(插入/冒泡/选择)</h2><ul><li>待补</li></ul><h2 id="非比较排序-1"><a href="#非比较排序-1" class="headerlink" title="非比较排序"></a>非比较排序</h2><ul><li>待补</li></ul><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>外部排序指代排序文件较大,内存一次放不下,需存放在外村的文件的排序.</li><li>带排序的记录储存在外村,排序时在把数据一部分一部分地调入内存进行排序,排序过程中需要多次进行内存与外存之间的交换.<h2 id="外部归并排序"><a href="#外部归并排序" class="headerlink" title="外部归并排序"></a>外部归并排序</h2></li><li>外排的时间复杂度主要考虑访问此判断次数(I/O次数)<ul><li><code>外部排序的总时间 = 内部排序所需的时间 + 外存信息读写的时间 + 内部归并所需的时间</code></li></ul></li><li>归并排序分为两个阶段<ul><li><ol><li>根据内存缓冲区大小,将外存上的文件分为若干长度为<code>l</code>的子文件,依次读入内存并利用内部排序方法对他们进行排序,并将排序后的有序子文件重新写回,称这些有序子文件为<code>归并段</code>或<code>顺串</code></li></ol></li><li><ol><li>对这些归并段进行逐趟归并,使归并段(有序子文件)逐渐由小到大,直至得到整个有序子文件为止.</li></ol></li></ul></li><li>增大归并路数,可减少归并趟数,从而减少总的磁盘I/O次数<ul><li>归并趟数S = 归并树的高度 = $\lceil log_{k}{r} \rceil$</li><li><code>r</code>为初试归并段个数</li></ul></li></ul><h2 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h2><ul><li>目的:利用败者树增大归并路数</li></ul><hr><ul><li>普通增加归并串的问题:增加归并路数k时,内部归并的时间将增加,这将抵消由于增大k而减少外存访问次数所得的收益.</li><li>S躺归并总共需要的是比较次数:$S(n-1)(k-1) = \lceil log_{k}{r} \rceil (n-1)(k-1) = \lceil log_{2}{r} \rceil (n-1)(k-1) / \lceil log_{2}{k} \rceil$<ul><li>n为一趟归并待归并的元素个数,n个元素需要n-1次</li><li>k-1为从k个关键字中选择最小的一个需要的比较次数</li><li>r为初试归并段个数</li></ul></li><li>可以看出$(k-1) / \lceil log_{2}{k} \rceil$随着k增大而增大,所以内部归并的时间也随着k的增大而增大</li></ul><hr><ul><li>解决方法啊:败者树<ul><li>败者树是一种树形选择结构<ul><li>它是一种完全二叉树</li><li>有序归并段放在叶子结点上,每次把用各个归并段的第一个结点进行比较</li><li>分支结点用于记录左右孩子中的失败者</li><li>最后根结点结果为胜利者(最小数)</li></ul></li></ul></li></ul><p><img src="败者树.jpg" alt></p><ul><li>对于k陆归并的败者树深度为$\lceil log_{2}{k} \rceil$,因此k个记录中选择最小关键字,最多需要$\lceil log_{2}{k} \rceil$次比较.</li><li>所以使用败者树后的总的比较次数为<ul><li>$S(n-1) \lceil log_{2}{k} \rceil = \lceil log_{k}{r}(n-1)\lceil log_{2}{k} \rceil = (n-1)\lceil log_{2}{r} \rceil$</li></ul></li><li>所以利用败者树进行比较的话,内部归并与归并路数k无关.只要内存空间允许,增大归并路数k将有效地减少归并树的高度,从而减少I/O次数,提高外部排序的速度.</li><li>在内存空间一定的时候,增加归并的路数会导致平均每个归并缓存区变小,所以导致I/O交换的次数会变多,导致性能下降.</li></ul><h2 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h2><ul><li>目的: 生成初始归并段,用于增大归并段长度来减少归并段个数</li><li>减少归并段的原因: 由$S(n-1)(k-1) = (n-1)\lceil log_{2}{r} \rceil$可知减少初试归并段的个数也能减少归并趟数S</li><li>使用置换选择排序的原因:生成归并串依赖可用内存区的大小下,生成尽可量长的初试归并段</li></ul><hr><ul><li><p>方法伪代码:<br><img src="置换选择排序.jpg" alt></p></li><li><p>例子</p><ul><li>设待排文件FI = {17,21,05,44,10,12,56,32,29},WA的容量为3.排序过程如下表</li></ul></li></ul><p><img src="置换选择排序例子.jpg" alt></p><h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><ul><li>WPL(带权路径长度):树中所有叶结点的带权路径长度之和称为该树的带权路径长度.</li><li>目的:由长度不相等的归并段,进行多路平衡归并,不同归并的选择会导致I/O次数的不同.<ul><li>如下图左边的I/O次数为484次,右边的I/O次数为466次</li></ul></li></ul><p><img src="不同归并树对IO次数的影响.jpg" alt></p><hr><ul><li>最佳归并树的构成方法(哈夫曼树扩展)<ul><li>若初试归并段不足以构成一棵阉割k叉树时,需要添加长度为0的虚段(放置最远)</li></ul></li></ul><p><img src="Sort/计算最佳归并树的虚段数目.jpg" alt></p><ul><li>关于完全k叉树性质: $n_{0} = (k-1)n_{k} + 1$的证明<script type="math/tex; mode=display">n_{0} := 度为0的结点(叶子结点)</script><script type="math/tex; mode=display">n_{k} := 度为k的结点(分支结点)</script><script type="math/tex; mode=display">n := 树中的总结点个数</script><script type="math/tex; mode=display">B := 分支个数</script></li></ul><script type="math/tex; mode=display">n = n_{0} + n_{k}</script><script type="math/tex; mode=display">n = B+1(结点个数等于分支个数+1)</script><script type="math/tex; mode=display">B = k * n_{k}(分支个数等于非叶子结点的总度数)</script><script type="math/tex; mode=display">n_{0} + n_{k} = k * n_{k} + 1</script><script type="math/tex; mode=display">n_{0} = (k-1)n_{k} + 1</script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List深入探索</title>
      <link href="/2021/06/05/ComputerBasics/CPP/STL/List/"/>
      <url>/2021/06/05/ComputerBasics/CPP/STL/List/</url>
      
        <content type="html"><![CDATA[<h1 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h1><ul><li>List是一个双端队列<h2 id="gcc2-9中list的类图"><a href="#gcc2-9中list的类图" class="headerlink" title="gcc2.9中list的类图"></a>gcc2.9中list的类图</h2><img src="UML_List.jpg" alt></li></ul><h2 id="gcc2-9中list的成员变量"><a href="#gcc2-9中list的成员变量" class="headerlink" title="gcc2.9中list的成员变量"></a>gcc2.9中list的成员变量</h2><pre><code class="lang-cpp">template&lt;class T, class Alloc = alloc&gt;class list {protected:    typedef __list_node&lt;T&gt; list_node;public:    typedef list_node *link_type;    typedef __list_iterator&lt;T, T &amp;, T *&gt; iterator;protected:    link_type node;};</code></pre><pre><code class="lang-cpp">template&lt;class T&gt;struct __list_node {    typedef void *void_pointer;    void_pointer prev;    void_pointer next;    T data;};</code></pre><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li>为实现前闭后开的特性,在环形链表末尾加入一个用以占位的空节点,并将迭代器list::end()指向该节点.</li></ul><p><img src="List_Graphy" alt></p><hr><ul><li>对于链表的迭代器的<code>++</code>,<code>--</code>,<code>-&gt;</code>,<code>*</code>等操作都是运算符重载.<ul><li>还定义了iterator_category、value_type、difference_type、pointer和pointer5个关联类型(associated types),这些特征将被STL算法使用.</li></ul></li></ul><p><img src="List_Operator.jpg" alt></p><pre><code class="lang-cpp">template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator {    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;    typedef bidirectional_iterator_tag     iterator_category;     // 关联类型1    typedef T                             value_type;            // 关联类型2    typedef ptrdiff_t                     difference_type;    // 关联类型3    typedef Ptr                         pointer;            // 关联类型4    typedef Ref                         reference;            // 关联类型5    typedef __list_node &lt;T&gt;*            link_type;    link_type node;        // 指向的链表节点    reference operator*() const { return (*node).data; }    //*ite -&gt; 调用 -&gt; (*ite).dta;    pointer operator-&gt;() const { return &amp;(operator*()); }    //ite-&gt;method() -&gt; 调用 -&gt; (&amp;(*ite))-&gt;method();    //注意对于 -&gt; 运算符,他们一直向后传递一直到可以停止为止    self&amp; operator++() {        node = (link_type) ((*node).next);        return *this;    }    //这里是前置++    self operator++(int) {        self tmp = *this;        ++*this;        return tmp;    }    //注意这里后置++中第79行先调用 __list_iterator(const iterator&amp; x) : node(x.node) 的拷贝构造函数,而*this为传入的参数};</code></pre><hr><ul><li>注意在这里前置++运算符返回左值,而后置++返回右值,这与基础类型的++和—运算一致.<ul><li>需要强调的是(i++)++的后置++返回的是右值(临时),不能再对其后置++.<br>```cpp<br>int i(6);<br>i++++;        // 被解析为 ++(++i), 能通过编译<br>++++i;        // 被解析为 (i++)++, 不能通过编译</li></ul></li></ul><p>list<int> c;<br>auto ite = c.begin();<br>++++ite;    // 被解析为 ++(++ite), 能通过编译<br>ite++++;    // 被解析为 (ite++)++, 不能通过编译<br>```</int></p><h2 id="gcc4-9版本list"><a href="#gcc4-9版本list" class="headerlink" title="gcc4.9版本list"></a>gcc4.9版本list</h2><p><img src="List2.9VS4.9.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> ComputerBasics </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画线算法</title>
      <link href="/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/20213658" target="_blank" rel="noopener">绘制直线的光栅化算法</a></li><li>计算机图形学(第四版) Computer Graphics with OpenGL Fourth Edition</li></ul></li><li><p>我们需要根据一条直线(屏幕上代指线段)的两个端点$(x_{0},y_{0}),(x_{1},y_{1}),x_{0} &lt; x_{1}$,绘制中间的像素点.</p><h1 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h1></li><li>斜截式<ul><li>$y = kx + b$<ul><li>根据两个端点可以计算k和b<ul><li>$k = \frac{y_{0} -y_{1}}{x_{0} - x_{1}}$</li><li>$b = y_{0} - kx_{0}$</li></ul></li></ul></li></ul></li><li>按照直觉的方法,就是通过遍历所有的x的值,计算y的值来得到直线上每一个像素的位置.但是由于其涉及乘法,对性能损耗大.需要尽可能的不适用乘法.</li></ul><h1 id="DDA-Digital-Differential-Analyzer-数值微分分析器"><a href="#DDA-Digital-Differential-Analyzer-数值微分分析器" class="headerlink" title="DDA(Digital Differential Analyzer 数值微分分析器)"></a>DDA(Digital Differential Analyzer 数值微分分析器)</h1><ul><li>采用增量的思想,$\delta_{x}$为x方向的增量,$\delta_{y}$为y方向的增量<ul><li>$y_{i+1} = kx_{i+1} + b= k(x_{i} + \delta_{x}) + b= kx_{i} + b +  k\delta_{x} = y_{i} + k\delta_{x}$  </li></ul></li><li>这样，每个纵坐标的值都是在前一个纵坐标的基础上加上斜率k.</li></ul><hr><ul><li><p>问题1:当斜率过大时,直线过于稀疏</p><ul><li>当0 &lt; |k| &lt;= 1时, x方向遍历,$y_{i+1} = y_{i} + k$</li><li>当|k| &gt; 1时,y方向遍历,$x_{i+1} = y_{i} + 1/k$</li></ul></li><li><p>问题2:效率仍然比较低</p><ul><li>此方法用到了浮点数,浮点数加减法效率仍无法满意</li></ul></li></ul><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>输入线段的端点值,计算水平和垂直方向差值dx,dy,绝对值大的值用于确定step值(确定哪个方向增量为1)</li><li>从$(x_{0},y_{0})$开始,每次在x和y方向上增加相应的增加,并绘制像素</li></ul><pre><code class="lang-cpp">#include &lt;stdlib.h&gt;#include &lt;math.h&gt;inline int round (const float a) {return int(a+0.5)}void lineDDA(int x0,int y0,int x1,int y1){    int dx = x1 - x0,dy = y1 - y0,steps,k;    float xIncrement,yIncrement,x=x0,y=y0;    if(fabs(dx) &gt; fabs(dy))        step = fabs(dx);    else        step = fabs(dy);    xIncrement = float (dx)/ float (steps);    yIncrement = float (dy)/ float (steps);    setPixel(round(x),round(y));    for(k = 0; k &lt; steps; ++k)    {        x += xIncrement;        y += yIncrement;        setPixel(round(x),round(y));    }}</code></pre><h2 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h2><ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/345284076" target="_blank" rel="noopener">【十天自制软渲染器】DAY 02：画一条直线（DDA 算法 &amp; Bresenham’s 算法</a></li></ul><hr><ul><li>对于任意斜率在[0,1)的直线,其端点为(x1,y1),(x2,y2),其斜率为k(0&lt;=k&lt;1)<ul><li>第一个点是$(x_{1},y_{1})$.</li><li>对于第二个点可能是$(x_{1}+1,y_{1}+1)$,也有可能是$(x_{1}+1,y_{1})$;<ul><li>我们通过计算$y_{1}+k$可以得到第二个点的实际位置,此时我们只需比较$y_{1}+k$和$y_{1}+0.5$的大小即可.<ul><li>$y_{1}+k &gt;= y_{1}+0.5$,直线在这个像素中心的上方,取$y_{1}+1$.</li><li>$y_{1}+k &lt; y_{1}+0.5$,直线在这个像素中心的下方,取$y_{1}$.</li></ul></li><li>我们将把$y_{1}+k 和 y_{1}+0.5$考虑成误差形式<ul><li>假设初始误差$\epsilon=0$(假设两端点的值都为整数)</li><li>则我们只需比较$\epsilon + k 和 0.5$的大小</li></ul></li></ul></li><li>然后我们必须更新新的误差值$\epsilon$让参与第三个点的计算<ul><li>若第二点为$(x_{1}+1,y_{1}+1)$,那么$\epsilon \leftarrow  y + \epsilon + k - (y+1) = \epsilon + k -1$</li><li>若第二点为$(x_{1}+1,y_{1})$,那么$\epsilon \leftarrow  y + \epsilon + k - (y) = \epsilon + k$</li></ul></li><li>之后一直按上述规则更新.</li></ul></li></ul><pre><code class="lang-cpp">//伪代码EPS = 0y = y1for x from x1 to x2 do    draw point at (x,y)    if((EPS + k) &lt; 0.5)        EPS = EPS+k    else        EPS = EPS+k-1        y = y +1    end ifend for</code></pre><hr><ul><li>上述方法涉及浮点运算,对效率有影响,我们对误差判断的不等式做如下变换<script type="math/tex; mode=display">\epsilon + k < 0.5</script><script type="math/tex; mode=display">\epsilon + \Delta y / \Delta x < 0.5</script><script type="math/tex; mode=display">2\epsilon\Delta x + 2\Delta y < \Delta x</script><script type="math/tex; mode=display">2(\epsilon'+ \Delta y) < \Delta x,\epsilon' = \epsilon\Delta x</script></li><li>因此,我们构建初始误差值$\epsilon’$,每次加上$\Delta y$.然后每次用<code>2</code>$(\epsilon’+\Delta y)$和$\Delta x$进行判断即可.</li><li>对于误差值的更新,我们做如下变换<ul><li>$\epsilon = \epsilon + k \leftrightarrow \epsilon\Delta x = \epsilon\Delta x + \Delta y \leftrightarrow \epsilon’ = \epsilon’ + \Delta y$ </li><li>$\epsilon = \epsilon + k - 1 \leftrightarrow \epsilon\Delta x  = \epsilon\Delta x + \Delta y - \Delta x \leftrightarrow \epsilon’ = \epsilon’ + \Delta y - \Delta x$</li></ul></li></ul><pre><code class="lang-cpp">//伪代码EPS_PRIM = 0y = y1for x from x1 to x2 do    draw point at (x,y)    if(2(EPS_PRIM + dy) &lt; dx)        EPS_PRIM = EPS_PRIM + dy    else        EPS_PRIM = EPS_PRIM + dy - dx        y = y +1    end ifend for</code></pre><hr><ul><li>c++实现</li></ul><pre><code class="lang-cpp">void line(Screen &amp;s,  int x1, int y1,  int x2, int y2,  TGAImage &amp;image, TGAColor color) {  int y = y1;  int eps = 0;  int dx = fabs(x2 - x1);  int dy = fabs(y2 - y1);  for (int x = x1; x &lt;= x2; x++) {    image.set(x, y, color);    eps += dy;    // 这里用位运算 &lt;&lt;1 代替 *2    if((eps &lt;&lt; 1) &gt;= dx)  {      y++;      eps -= dx;    }  }}</code></pre><ul><li>上述算法在使用于斜率的<code>绝对值</code>在[0,1)的直线,并且x1 &lt; x2的直线,对于其他情况,可以通过交换xy的遍历方式解决.</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 const</title>
      <link href="/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/"/>
      <url>/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/</url>
      
        <content type="html"><![CDATA[<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><ul><li>定义：const用于定义一个变量，它的值不能被改变</li></ul><h2 id="const对象必须初始化"><a href="#const对象必须初始化" class="headerlink" title="const对象必须初始化"></a>const对象必须初始化</h2><ul><li><p>然而并不是所有的const对象都必须初始化</p></li><li><p>顶层const必须初始化，因为本身不能改变，不初始化根本没法用。而底层const(常量指针)可以不初始化</p><blockquote><p>参考:<a href="https://blog.csdn.net/qq_21034239/article/details/70492318" target="_blank" rel="noopener">https://blog.csdn.net/qq_21034239/article/details/70492318</a></p></blockquote></li><li><p>其实没有那么简单,const对象必须初始化值对bulit-in类型和POD类行有效</p><ul><li>built-in类型是内置类型包括算术类型和空类型(void)</li><li>注意的是指针和引用是复合类型</li></ul></li></ul><blockquote><p>参考:<a href="https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away" target="_blank" rel="noopener">https://stackoverflow.com/questions/8440381/why-do-const-variables-have-to-be-initialized-right-away</a><br>(翻译:<a href="https://www.it1352.com/465052.html" target="_blank" rel="noopener">https://www.it1352.com/465052.html</a>)</p></blockquote><h3 id="什么是POD类型"><a href="#什么是POD类型" class="headerlink" title="什么是POD类型"></a>什么是POD类型</h3><blockquote><p>参考: <a href="https://zhuanlan.zhihu.com/p/45545035" target="_blank" rel="noopener">什么是 POD 数据类型？</a></p></blockquote><ul><li>POD类型是 Plain Old Data 的缩写,定义它的作用是为了跟c语言进行兼容,即可以使用 memcpy() 这种最原始的函数进行操作<ul><li>也就是说，能用 C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据。</li></ul></li></ul><h4 id="如何判断POD类型"><a href="#如何判断POD类型" class="headerlink" title="如何判断POD类型"></a>如何判断POD类型</h4><ul><li>首先可以使用is_pod<t>::value函数进行判断</t></li><li>对于built-in类型肯定是POD类型,而对于类和结构体需要它是trival（平凡）的和布局有序的.</li></ul><hr><ul><li>trival（平凡）的.<ul><li>不显式写构造/析构函数、拷贝/移动构造函数、拷贝/移动运算符等</li><li>使用delete删除默认的三大函数</li><li>使用default声明默认的三大函数</li><li>不能有虚函数和虚基类</li></ul></li></ul><p><img src="POD_1.jpg" alt></p><ul><li>布局有序<ul><li>需要有相同的访问级别(private,public)</li><li>类中的第一个非静态成员的类型不能与其基类相同</li><li>只要有父类，非静态数据只能在其中一个类中，不可分散</li></ul></li></ul><h2 id="const对象仅对当前文件有效"><a href="#const对象仅对当前文件有效" class="headerlink" title="const对象仅对当前文件有效"></a>const对象仅对当前文件有效</h2><ul><li><p>在编译时会进行预处理，将代码中所有带const限定符的变量用初始化的常亮替代。</p></li><li><p>const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同在不同文件中分别定义了独立的变量。</p></li><li><p>如果要在多个文件中共享const对象，在需要声明变量的时候前面加extern</p></li></ul><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ul><li>用于声明<ul><li>变量只能被定义一次，但可以被多次声明。</li></ul></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>C/C++程序编译链接过程(还没写)</li></ul><h2 id="对const的引用"><a href="#对const的引用" class="headerlink" title="对const的引用"></a>对const的引用</h2><ul><li><p>别称: 常量引用</p></li><li><p>常量引用可以引用常量和非常量</p></li><li>非常量引用不能引用常量</li></ul><pre><code class="lang-cpp">const int a = 1;int d = 1;const int &amp;b = a;//trueconst int &amp;c = 1;//trueconst int &amp;d = d;//trueint &amp;e = a;//false;</code></pre><ul><li>初始化常量引用的时候可以使用任意类型和任意表达式，只要可以转换成相应的引用类型。<blockquote><p>原因：因为在常量引用绑定初始值的时候，生成了一个临时变量。其事实上绑定的是临时变量。</p></blockquote></li></ul><blockquote><p>这样保证了const int&amp;绑定的是int型的表达式</p><p>还有值得注意的是一般情况下引用的类型必须与其所引用的对象的类型一致</p></blockquote><pre><code class="lang-cpp">double dval = 3.14;const int &amp;ri = dval;</code></pre><p>等价于</p><pre><code class="lang-cpp">double dval = 3.14;const int temp = dval;const int &amp;ri = temp;</code></pre><ul><li>根据上述也可以解释为什么非常量引用不能引用常量，因为这样初始化绑定的是临时量。<blockquote><p>非const变量引用const量，其实绑定了中间变量temp，因为是非const量所以可以改变这非const量，按引用来const量也应该改变，但其实改变的是中间量temp，const量不变，产生矛盾，c++把这种行为定义为非法。</p></blockquote></li></ul><h3 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h3><ul><li>const只约束当前绑定的对象的相关操作，而不管对象本身是不是常量。</li></ul><pre><code class="lang-cpp">int a  = 1;int &amp;b = a;const int &amp;c = a;b = 2;cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2a = 3cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;//2 2 2c = 4cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;// error: assignment of read-only reference ‘c’</code></pre><h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><blockquote><p>对于指针常量和常量指针的定义C++ primer里定义的跟大多数教材不一样</p><h3 id="指针常量-pointer-to-const"><a href="#指针常量-pointer-to-const" class="headerlink" title="指针常量(pointer to const)"></a>指针常量(pointer to const)</h3><ul><li>从右往左读，它是一个指针，是一个指向常量类型的指针。说明不能改变他所指向对象的内容。但是可以改变它指向的对象。</li></ul></blockquote><pre><code class="lang-cpp">const int a = 1;const int b = 2;const int *c = &amp;a;*c = 1;//faslec = &amp;b;//true</code></pre><h3 id="常量指针-const-pointer"><a href="#常量指针-const-pointer" class="headerlink" title="常量指针(const pointer)"></a>常量指针(const pointer)</h3><ul><li>从右往左读，它是一个常量，说明指针的地址不能改变。但是可以改变它指向对象的内容。</li></ul><pre><code class="lang-cpp">int a = 1;int b = 2;int *const c = &amp;a; c= &amp;b;//falsec= 2;//true</code></pre><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><ul><li>顶层const说明指针本身是个常量-常量指针(const pointer)</li><li>底层const说明指针指向的对象是个常量-指针常量(pointer to const)</li></ul><h3 id="const对拷贝的影响"><a href="#const对拷贝的影响" class="headerlink" title="const对拷贝的影响"></a>const对拷贝的影响</h3><ul><li>顶层const对拷贝无影响</li><li>底层const对拷贝有影像<blockquote><p>拷贝两者有相同的底层const的，或者被拷贝数据可以从非常量转变为常量,才无影响</p></blockquote></li></ul><pre><code class="lang-cpp">int main(){   // 顶层const对拷贝无影响    {        // const int -&gt; int  yes        const int b = 1;        int a = b;        // int -&gt; const int yes        int c = 1;        const int d = c;    }     // &amp;int(int*) -&gt; int *const/const int*/const int *const    int a = 1;    int *const b = &amp;a; //ok    const int *c = &amp;a; //ok    const int *const d = &amp;a; //ok    // &amp;(const int) -&gt; int *const/const int*/const int *const    const int e = 1;    int *const f = &amp;e; //error 没有相同的底层const    const int *g = &amp;e; //ok    const int *const h = &amp;e; //ok  &amp;e可以转换成const int *const    //(int cont*) -&gt; int *const/const int*/const int *const    int i = 1;    int *const  j= &amp;i;    int *const  k = j; //ok    const int*  l = j; //ok    const int *const m = j; //ok    return 0;}</code></pre><ul><li>总结(我自己有点绕晕了,总结一下)<blockquote><p>1) 对于非指针类型之间的拷贝,没有限制 const int &lt;-&gt; int</p></blockquote></li></ul><blockquote><p>2) 对于指针之间的拷贝。右值没有底层const,总合法;右值有底层const,则看左值有没有底层const,有则合法,没有则不合法。   </p><ul><li>常量对象不能赋值给非常量引用,常量对象不能赋值给非常量指针</li></ul><p>3) 对于指针和非指针之间，类型不同不合法;</p></blockquote><h2 id="constexpr和常量表达式-c-11"><a href="#constexpr和常量表达式-c-11" class="headerlink" title="constexpr和常量表达式[c++11]"></a>constexpr和常量表达式[c++11]</h2><ul><li>常量表达式(const expression)是指不会改变并且在编译过程就能得到计算结果的表达式<blockquote><p>数据类型是常量并且初始值是常量或字面值或两者混合的是常量表达式。</p></blockquote></li></ul><pre><code class="lang-cpp">const int a = 1; //trueconst int b = a+1; //trueint c = 1; //falseconst int d = get_d(); //false，该值在编译时才能获得，所以不是常量表达式</code></pre><h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><ul><li>constexpr定义的变量必须要用常量表达式初始化</li><li>constexpr是顶层const，即其本身为常量</li><li>对于字面量<blockquote><p>算术类型，引用和指针，字面值常量类（包括枚举类型），枚举都是字面值<br>自定义类，IO库，string类等不算字面值</p></blockquote></li></ul><h3 id="constexpr-指针"><a href="#constexpr-指针" class="headerlink" title="constexpr 指针"></a>constexpr 指针</h3><ul><li>constexpr指针只能指向地址固定的变量，比如全局变量，staitc变量</li></ul><pre><code class="lang-cpp">constexpr int *p1; //顶层constconst int *p2;  //底层constint *const p3;  //顶层constconstexpr const int *p4;//&lt;=&gt;const int *const p5;</code></pre><h2 id="const补充"><a href="#const补充" class="headerlink" title="const补充"></a>const补充</h2><p><a href="https://interview.huihut.com/#/?id=cc" target="_blank" rel="noopener">const 使用</a></p><ul><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ul><pre><code class="lang-cpp">// 类class A{private:    const int a;                // 常对象成员，只能在初始化列表赋值public:    // 构造函数    A() : a(0) { };    A(int x) : a(x) { };        // 初始化列表    // const可用于对重载函数的区分    int getValue();             // 普通成员函数    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值};void function(){    // 对象    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量    const A a;                  // 常对象，只能调用常成员函数    const A *p = &amp;a;            // 指针变量，指向常对象    const A &amp;q = a;             // 指向常对象的引用    // 指针    char greeting[] = &quot;Hello&quot;;    char* p1 = greeting;                // 指针变量，指向字符数组变量    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量}// 函数void function1(const int Var);           // 传递过来的参数在函数内不可变void function2(const char* Var);         // 参数指针所指内容为常量void function3(char* const Var);         // 参数指针为常量void function4(const int&amp; Var);          // 引用参数在函数内为常量// 函数返回值const int function5();      // 返回一个常数const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lesson 1 Bresenham’s Line Drawing Algorithm</title>
      <link href="/2021/06/05/Project/TinyRenderer/L1_Line_Drawing_Algorithm/"/>
      <url>/2021/06/05/Project/TinyRenderer/L1_Line_Drawing_Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="插值画线算法"><a href="#插值画线算法" class="headerlink" title="插值画线算法"></a>插值画线算法</h1><pre><code class="lang-cpp">void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) {     for (float t=0.; t&lt;1.; t+=.01) {         int x = x0 + (x1-x0)*t;         int y = y0 + (y1-y0)*t;         image.set(x, y, color);     } }</code></pre><ul><li>存在问题<ul><li>效率低下,不好确定插值精度k<ul><li>算法控制精度的方式无关屏幕像素点，无法做到真正的逐点绘制，x和y是一个近似的int值，可能存在重复绘制和缺省绘制的情况，我们需要逐x像素或逐y像素绘制线段。</li></ul></li></ul></li></ul><h1 id="逐像素直线算法"><a href="#逐像素直线算法" class="headerlink" title="逐像素直线算法"></a>逐像素直线算法</h1><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){    for(int x = x1; x &lt;= x2; ++x)    {        float t = (x - x1) / (float)(x2 - x1);        int y = y1 * (1.f - t) + y2 * t;        image.set(x,y,color);    }}line(13, 20, 80, 40, image, white); line(20, 13, 40, 80, image, red); line(80, 40, 13, 20, image, red);</code></pre><p><img src="Second_attempt.png" alt></p><ul><li>存在问题:<ul><li>第一条直线比较好</li><li>第二条直线有很多洞,不太行</li><li>未出现第三条线,第一第三条线是一样的只是颜色和方向不一样<ul><li>因为我们的算法从默认是x1 &lt; x2的,如果按照直线3的画法将导致进入不了循环</li></ul></li></ul></li></ul><h1 id="改进逐像素直线算法"><a href="#改进逐像素直线算法" class="headerlink" title="改进逐像素直线算法"></a>改进逐像素直线算法</h1><ul><li>如果斜率的绝对值大于1,以y=x做对称</li><li><p>保证从直线中坐标小的位置绘制到坐标大的位置</p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  for(int x = x1; x &lt;= x2; ++x)  {      float t = (x - x1) /(float)(x2-x1);      int y = y1*(1.f - t) + y2*t;      if(yDir)          image.set(y,x,color);      else          image.set(x,y,color);  }}</code></pre></li><li><p>存在问题</p><ul><li>效率低下</li></ul></li></ul><h1 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h1><ul><li><p>方法见之前的笔记:<a href="https://sanctorum003.github.io/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">画线算法</a></p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  int dx = x2-x1;  int dy = y2-y1;  float derror = abs(dy/(float)dx);  float error = 0.f;  int y = y1;  for(int x = x1; x &lt;= x2; ++x)  {      if(yDir)          image.set(y,x,color);      else              image.set(x,y,color);      error += derror;      if(error &gt; 0.5)      {          y += (y1 &gt; y2) ? -1.f : 1.f ;          error--;      }  }}</code></pre></li><li><p>存在问题</p><ul><li>涉及到浮点数运算,效率有所下降.</li></ul></li></ul><h1 id="优化的Bresenham算法"><a href="#优化的Bresenham算法" class="headerlink" title="优化的Bresenham算法"></a>优化的Bresenham算法</h1><ul><li>方法见之前的笔记:<a href="https://sanctorum003.github.io/2021/06/05/CG/CG/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">画线算法</a></li><li><p>公式推导如下:<br><img src="non_float_bresenham.jpg" alt></p><pre><code class="lang-cpp">void line(int x1,int y1,int x2,int y2,TGAImage&amp; image,TGAColor color){  bool yDir = false;  //如果斜率的绝对值大于1,以y=x做对称  if(abs(x1-x2) &lt; abs(y1-y2))  {      swap(x1,y1);      swap(x2,y2);      yDir = true;  }  //保证从直线中坐标小的位置绘制到坐标大的位置  if(x1 &gt; x2)  {      swap(x1,x2);      swap(y1,y2);  }  int dx = x2-x1;  int dy = y2-y1;  int error = 0;  int y = y1;  for(int x = x1; x &lt;= x2; ++x)  {      if(yDir)          image.set(y,x,color);      else              image.set(x,y,color);      error += 2 * dy;      if(error &gt; dx)      {          y += (y1 &gt; y2) ? -1.f : 1.f;          error -= 2*dx;      }  }}</code></pre><h1 id="Wireframe-rendering-线框渲染"><a href="#Wireframe-rendering-线框渲染" class="headerlink" title="Wireframe rendering(线框渲染)"></a>Wireframe rendering(线框渲染)</h1></li><li>obj文件特点:<ul><li>v代表定点</li><li>f代表面</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tinyrenderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习总览</title>
      <link href="/2021/06/05/Menu/C++%E5%A4%8D%E4%B9%A0%E6%80%BB%E8%A7%88/"/>
      <url>/2021/06/05/Menu/C++%E5%A4%8D%E4%B9%A0%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="huihut-interview再总结"><a href="#huihut-interview再总结" class="headerlink" title="huihut/interview再总结"></a>huihut/interview再总结</h1><ul><li>参考:<a href="https://interview.huihut.com/#/" target="_blank" rel="noopener">https://interview.huihut.com/#/</a></li></ul><div class="table-container"><table><thead><tr><th>关键字</th></tr></thead><tbody><tr><td><a href="https://sanctorum003.github.io/2021/06/05/C++/C++%E5%A4%8D%E4%B9%A0%20const/" target="_blank" rel="noopener">const</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*</title>
      <link href="/2021/06/03/Algorithm/A_Star/"/>
      <url>/2021/06/03/Algorithm/A_Star/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是对<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Introduction to the A* Algorithm</a>的学习笔记<br>参考<a href="https://zhuanlan.zhihu.com/p/54510444" target="_blank" rel="noopener">路径规划之 A* 算法</a></p></blockquote><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><ul><li>输入:图结构</li><li>输出:图的结点序列(The path found by A* is made of graph nodes and edges)</li><li><p>Tradeoffs:结点越少,A*速度越快</p></li><li><p>拓展:<a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html" target="_blank" rel="noopener">Map representations</a></p></li></ul><h1 id="寻路算法概括"><a href="#寻路算法概括" class="headerlink" title="寻路算法概括"></a>寻路算法概括</h1><h2 id="Breadth-First-Search-BFS"><a href="#Breadth-First-Search-BFS" class="headerlink" title="Breadth First Search(BFS)"></a>Breadth First Search(BFS)</h2><ul><li>特点:搜寻每个方向的权值相等</li><li>使用场景:<ul><li>regular path finding</li><li>procedural map generation</li><li>flow field pathfinding</li><li>distance maps</li><li>other types of map analysis</li></ul></li></ul><h2 id="Dijkstra-ˈdeɪkstra-’s-Algorithm-Uniform-Cost-Search"><a href="#Dijkstra-ˈdeɪkstra-’s-Algorithm-Uniform-Cost-Search" class="headerlink" title="Dijkstra[/ˈdɛɪkstra/]’s Algorithm(Uniform Cost Search)"></a>Dijkstra[/ˈdɛɪkstra/]’s Algorithm(Uniform Cost Search)</h2><ul><li>特点:优先选择低代价的路径进行搜索</li><li>使用场景:适合在存在不同代价路径的图中进行搜索</li></ul><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><ul><li>是Dijkstra’s Algorithm的改进,针对单个目的地进行了优化<ul><li>Dijkstra 算法可以找到所有位置的路径</li><li>A* 查找到一个位置或几个位置中最近的位置的路径。</li><li>它优先考虑更接近目标的路径</li></ul></li></ul><h1 id="从BFS到A"><a href="#从BFS到A" class="headerlink" title="从BFS到A*"></a>从BFS到A*</h1><h2 id="朴素BFS"><a href="#朴素BFS" class="headerlink" title="朴素BFS"></a>朴素BFS</h2><pre><code class="lang-python"># 计算从start开始到任意点的路径frontier = Queue()frontier.put(start)came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   for next in graph.neighbors(current):      if next not in came_from:         frontier.put(next)         came_from[next] = current</code></pre><ul><li>通过上述代码可以将从start开始到任意点的路径保存在一个字典结构中,可视化效果如下<br><img src="BFS_PATH.jpg" alt></li></ul><pre><code class="lang-python"># 获得某一个goal到start的路径current = goal path = []while current != start:    path.append(current)   current = came_from[current]path.append(start) # optionalpath.reverse() # optional</code></pre><ul><li>扩展:<a href="https://www.redblobgames.com/pathfinding/tower-defense/" target="_blank" rel="noopener">Flow Field Pathfinding for Tower Defense</a></li></ul><h2 id="提前停止-early-exit"><a href="#提前停止-early-exit" class="headerlink" title="提前停止(early exit)"></a>提前停止(early exit)</h2><ul><li>对于计算某一点<code>start</code>到<code>goal</code>的路径,我们不必计算所有的点,只需在找到<code>goal</code>时停止bfs即可.</li><li>通过<code>提前停止</code>可以减少计算量,可视化如下图</li></ul><p><img src="BFS_EarlyExit.jpg" alt></p><pre><code class="lang-python"># early exitfrontier = Queue()frontier.put(start )came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   if current == goal:       break              for next in graph.neighbors(current):      if next not in came_from:         frontier.put(next)         came_from[next] = current</code></pre><ul><li>扩展<a href="https://www.redblobgames.com/pathfinding/early-exit/" target="_blank" rel="noopener">Early exits</a></li></ul><h2 id="移动代价-Movement-costs"><a href="#移动代价-Movement-costs" class="headerlink" title="移动代价(Movement costs)"></a>移动代价(Movement costs)</h2><ul><li>引入Dijkstra’s Algorithm.需要记录移动时的代价.</li></ul><pre><code class="lang-py">frontier = PriorityQueue()frontier.put(start, 0)came_from = dict()cost_so_far = dict()came_from[start] = Nonecost_so_far[start] = 0while not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      new_cost = cost_so_far[current] + graph.cost(current, next)      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:         cost_so_far[next] = new_cost         priority = new_cost         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul><li><p>详细理解Dijkstra:<a href="https://zhuanlan.zhihu.com/p/129373740" target="_blank" rel="noopener">[最短路径问题]—Dijkstra 算法最详解</a></p></li><li><p>Dijkstra是一种基于贪心的算法，它也是BFS的变种,是计算一个非负权图中，某个起始点到其它所有节点最短路径值的算法，即求单源最短路径，也能求最短路径节点顺序。</p></li></ul><p><img src="Dijkstra.svg" alt></p><ul><li>方法参考伪代码<ul><li>相关参数:设<code>S</code>为已经求得的最短路径的结点,<code>V</code>为图中所有结点的集合,<code>dist[a,b]</code>为a点到b点的相对最短路径(相对最短路劲指的是从a点到b点并且只经过<code>S</code>中的结点的最短路径)<ul><li>Step 1(Line1-2): 将起始点<code>s</code>加入到S中,并将<code>dist[s,s]</code>设为0</li><li>Step 2(Line3-4): 计算从<code>s</code>点开始到其他所有点$v_{i}$的直接路径并写入$dist[s,v_{i}]$(对于无法直接到达的点赋值为 $\infin$)</li><li>(Line5):接下去是循环计算每一个点的最短路径,判断条件是 $V-S$是否为空.</li><li>Step 3(Line6-7):在循环中,每次挑选一个路径最短的结点$v_{j}$,并将他加入到<code>S</code>中</li><li>Step 4(Linr8-10)[<code>松弛</code>]:对于挑选出的结点$v_{j}$,跟新剩下<code>V-S</code>中的结点,判断是否经过$v_{j}$到b的权值是否更小,并进行更新.</li><li>重复进行循环直到<code>V-S</code>为空.</li></ul></li></ul></li></ul><h4 id="为什么每次加入集合S的点就是该点到源点的最小距离？"><a href="#为什么每次加入集合S的点就是该点到源点的最小距离？" class="headerlink" title="为什么每次加入集合S的点就是该点到源点的最小距离？"></a>为什么每次加入集合S的点就是该点到源点的最小距离？</h4><blockquote><p>参考:<a href="https://www.zhihu.com/question/20972566/answer/1106454505" target="_blank" rel="noopener">Dijkstra算法到底是讲什么的，谁可以通俗的讲解一下？通俗的程度：零基础也能听得懂？</a></p></blockquote><ul><li>这个问题与Dijkstra算法正确性挂钩，现在就来证明一下：  <ul><li>（1）因为每次都是找的<code>V-S</code>中的最小节点值的点加入<code>S</code>，那么加入<code>S</code>的顺序一定是节点到源点最小距离的顺序。  </li><li>（2）每次加入<code>S</code>的节点<code>v</code>一定与<code>S</code>中的节点直接相连，若不然，则存在中间节点连接集合S和点v，那么  一定有比v更小的节点值，与<code>dist[v]</code>最小矛盾。  </li><li>（3）对于一个已求得部分节点最短距离的<code>S</code>集合，下一个加入集合<code>S</code>中的节点必然是<code>S</code>集合中节点的下一邻接点，而根据算法特性，<code>S</code>集合中节点的下一邻接点都被进行松弛更新过，所以<code>V-S</code>中的最小节点值一定是该节点的最短距离。（注意，这里找最小值是为了便于计算，有可能有多个节点的最短距离已经产生，今后也不会再更新，只是他们距离更大一些，所以暂时不被选择）。      </li></ul></li></ul><ul><li>简单地说，因为下一个最短距离的节点必然是<code>S</code>集合的下一邻接点，而选择<code>V-S</code>中最小节点值的节点恰能满足该节点是<code>S</code>的下一邻接点，所以该节点值一定是最短距离。</li></ul><h3 id="Dijkstra-for-pathfinding-代码实现"><a href="#Dijkstra-for-pathfinding-代码实现" class="headerlink" title="Dijkstra for pathfinding 代码实现"></a>Dijkstra for pathfinding 代码实现</h3><ul><li>参考<a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm" target="_blank" rel="noopener">Implementation of A*</a></li></ul><pre><code class="lang-cpp">// Graph with weightsstruct GridWithWeights: SquareGrid {  std::unordered_set&lt;GridLocation&gt; forests;  GridWithWeights(int w, int h): SquareGrid(w, h) {}  double cost(GridLocation from_node, GridLocation to_node) const {    return forests.find(to_node) != forests.end()? 5 : 1;  }};</code></pre><pre><code class="lang-cpp">// Queue with prioritiestemplate&lt;typename T, typename priority_t&gt;struct PriorityQueue {  typedef std::pair&lt;priority_t, T&gt; PQElement;  std::priority_queue&lt;PQElement, std::vector&lt;PQElement&gt;,                 std::greater&lt;PQElement&gt;&gt; elements;  inline bool empty() const {     return elements.empty();  }  inline void put(T item, priority_t priority) {    elements.emplace(priority, item);  }  T get() {    T best_item = elements.top().second;    elements.pop();    return best_item;  }};</code></pre><pre><code class="lang-cpp">// dijkstra Search(build path map)template&lt;typename Location, typename Graph&gt;void dijkstra_search  (Graph graph,   Location start,   Location goal,   std::unordered_map&lt;Location, Location&gt;&amp; came_from,   std::unordered_map&lt;Location, double&gt;&amp; cost_so_far){  PriorityQueue&lt;Location, double&gt; frontier;  frontier.put(start, 0);  came_from[start] = start;  cost_so_far[start] = 0;  while (!frontier.empty()) {    Location current = frontier.get();    if (current == goal) {      break;    }    for (Location next : graph.neighbors(current)) {      double new_cost = cost_so_far[current] + graph.cost(current, next);      if (cost_so_far.find(next) == cost_so_far.end()          || new_cost &lt; cost_so_far[next]) {        cost_so_far[next] = new_cost;        came_from[next] = current;        frontier.put(next, new_cost);      }    }  }}```cpp//build the pathtemplate&lt;typename Location&gt;std::vector&lt;Location&gt; reconstruct_path(   Location start, Location goal,   std::unordered_map&lt;Location, Location&gt; came_from) {  std::vector&lt;Location&gt; path;  Location current = goal;  while (current != start) {    path.push_back(current);    current = came_from[current];  }  path.push_back(start); // optional  std::reverse(path.begin(), path.end());  return path;}</code></pre><h2 id="Heuristic-search-启发式搜索"><a href="#Heuristic-search-启发式搜索" class="headerlink" title="Heuristic search(启发式搜索)"></a>Heuristic search(启发式搜索)</h2><h3 id="什么是启发式算法"><a href="#什么是启发式算法" class="headerlink" title="什么是启发式算法"></a>什么是启发式算法</h3><ul><li>参考:<img src="https://www.cnblogs.com/sddai/p/5644011.html" alt="启发式算法（Heuristic Algorithm）"></li></ul><hr><ul><li>启发式算法（Heuristic Algorithm）有不同的定义：一种定义为，一个基于直观或经验的构造的算法，对优化问题的实例能给出可接受的计算成本（计算时间、占用空间等）内，给出一个近似最优解，该近似解于真实最优解的偏离程度不一定可以事先预计；另一种是，启发式算法是一种技术，这种技术使得在可接受的计算成本内去搜寻最好的解，但不一定能保证所得的可行解和最优解，甚至在多数情况下，无法阐述所得解同最优解的近似程度。我比较赞同第二种定义，因为启发式算法现在还没有完备的理论体系，只能视作一种技术。</li></ul><hr><ul><li>互动百科解释:人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的 步骤去寻求答案。启发式解决问题的方法是与算法相对立的。算法是把各种可能性都一一进行尝试，最终能找到问题的答案，但它是在很大的问题空间内，花费大量 的时间和精力才能求得答案。启发式方法则是在有限的搜索空间内，大大减少尝试的数量，能迅速地达到问题的解决。但由于这种方法具有尝试错误的特点，所以也 有失败的可能性。科学家的许多重大发现，常常是利用极为简单的启发式规则。</li></ul><h3 id="Greedy-Best-First-Search-最佳优先搜索"><a href="#Greedy-Best-First-Search-最佳优先搜索" class="headerlink" title="Greedy Best First Search(最佳优先搜索)"></a>Greedy Best First Search(最佳优先搜索)</h3><ul><li>在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。</li></ul><pre><code class="lang-py"># 定义曼哈顿距离def heuristic(a, b):   # Manhattan distance on a square grid   return abs(a.x - b.x) + abs(a.y - b.y)</code></pre><ul><li>其原理也很简单。与Dijkstra算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法。</li></ul><pre><code class="lang-py"># Greedy Best First Searchfrontier = PriorityQueue()frontier.put(start, 0)came_from = dict()came_from[start] = Nonewhile not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      if next not in came_from:         priority = heuristic(goal, next)         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="Greedy-Best-First-Search的问题"><a href="#Greedy-Best-First-Search的问题" class="headerlink" title="Greedy Best First Search的问题"></a>Greedy Best First Search的问题</h3><ul><li>如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径，下图描述了这种情况。</li></ul><p><img src="GB-FS.jpg" alt></p><h2 id="The-A-algorithm"><a href="#The-A-algorithm" class="headerlink" title="The A* algorithm"></a>The A* algorithm</h2><ul><li>A<em>算法结合了Djikstra和Greedy Best First的特点. A </em>通过以下函数来计算每个结点的优先级:<script type="math/tex; mode=display">f(n) = g(n) + h(n)</script><ul><li>其中,<code>f(n)</code>是节点<code>n</code>的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</li><li>其中,<code>g(n)</code>就是在Djikstra算法中计算的离起始点的距离,我们在Djikstra中取<code>g(n)</code>值最小的作为最高优先级</li><li>其中,<code>h(n)</code>为A*算法的启发函数,计算节点n距离终点的预计代价(距离).取<code>h(n)</code>值最小的作为最高优先级</li></ul></li><li>A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。</li></ul><hr><ul><li>A* 伪代码<ul><li>open_set 为待遍历的结点</li><li>close_set 为已经遍历的结点<br>```cpp</li></ul></li><li>初始化open_set和close_set；</li><li>将起点加入open_set中，并设置优先级为0（优先级最高）；</li><li>如果open_set不为空，则从open_set中选取优先级最高的节点n：<ul><li>如果节点n为终点，则：<ul><li>从终点开始逐步追踪parent节点，一直达到起点；</li><li>返回找到的结果路径，算法结束；</li></ul></li><li>如果节点n不是终点，则：<ul><li>将节点n从open_set中删除，并加入close_set中；</li><li>遍历节点n所有的邻近节点：<ul><li>如果邻近节点m在close_set中，则：<ul><li>跳过，选取下一个邻近节点</li></ul></li><li>如果邻近节点m也不在open_set中，则：<ul><li>设置节点m的parent为节点n</li><li>计算节点m的优先级</li><li>将节点m加入open_set中<br>```</li></ul></li></ul></li></ul></li></ul></li></ul><hr><ul><li>A* python伪代码</li></ul><pre><code class="lang-py">frontier = PriorityQueue()frontier.put(start, 0)came_from = dict()cost_so_far = dict()came_from[start] = Nonecost_so_far[start] = 0while not frontier.empty():   current = frontier.get()   if current == goal:      break   for next in graph.neighbors(current):      new_cost = cost_so_far[current] + graph.cost(current, next)      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:         cost_so_far[next] = new_cost         priority = new_cost + heuristic(goal, next)         frontier.put(next, priority)         came_from[next] = current</code></pre><h3 id="深入启发函数"><a href="#深入启发函数" class="headerlink" title="深入启发函数"></a>深入启发函数</h3><p>上面已经提到，启发函数会影响A*算法的行为。</p><ul><li><p>在极端情况下，当启发函数<code>h(n)</code>始终为0，则将由<code>g(n)</code>决定节点的优先级，此时算法就退化成了Dijkstra算法。</p></li><li><p><del>如果<code>h(n)</code>始终小于等于节点<code>n</code>到终点的代价，则A*算法保证一定能够找到最短路径。但是当<code>h(n)</code>的值越小，算法将遍历越多的节点，也就导致算法越慢.</del></p></li><li><p>如果<code>h(n)</code>完全等于节点<code>n</code>到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远.</p></li><li><p><del>如果<code>h(n)</code>的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快</del></p></li><li><p>在另外一个极端情况下，如果<code>h(n)</code>相较于<code>g(n)</code>大很多，则此时只有<code>h(n)</code>产生效果，这也就变成了最佳优先搜索。</p></li></ul><p>由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。</p><ul><li><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li><p>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。</p><pre><code class="lang-py">function heuristic(node) =  # D是指两个相邻节点之间的移动代价,通常是一个固定的常数  dx = abs(node.x - goal.x)  dy = abs(node.y - goal.y)  return D * (dx + dy)</code></pre></li><li><p>如果图形中允许朝八个方向移动，则可以使用对角距离。</p><pre><code class="lang-py">  # 这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是sqrt(2)*D  function heuristic(node) =    dx = abs(node.x - goal.x)    dy = abs(node.y - goal.y)    return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)</code></pre></li><li><p>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</p><pre><code class="lang-py">  # 欧几里得距离是指两个节点之间的直线距离  function heuristic(node) =    dx = abs(node.x - goal.x)    dy = abs(node.y - goal.y)    return D * sqrt(dx * dx + dy * dy)</code></pre></li></ul></li></ul><h3 id="A-代码实现"><a href="#A-代码实现" class="headerlink" title="A*代码实现"></a>A*代码实现</h3><ul><li>参考<a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm" target="_blank" rel="noopener">Implementation of A*</a></li></ul><pre><code class="lang-cpp">//A* algorithminline double heuristic(GridLocation a, GridLocation b) {  return std::abs(a.x - b.x) + std::abs(a.y - b.y);}template&lt;typename Location, typename Graph&gt;void a_star_search  (Graph graph,   Location start,   Location goal,   std::unordered_map&lt;Location, Location&gt;&amp; came_from,   std::unordered_map&lt;Location, double&gt;&amp; cost_so_far){  PriorityQueue&lt;Location, double&gt; frontier;  frontier.put(start, 0);  came_from[start] = start;  cost_so_far[start] = 0;  while (!frontier.empty()) {    Location current = frontier.get();    if (current == goal) {      break;    }    for (Location next : graph.neighbors(current)) {      double new_cost = cost_so_far[current] + graph.cost(current, next);      if (cost_so_far.find(next) == cost_so_far.end()          || new_cost &lt; cost_so_far[next]) {        cost_so_far[next] = new_cost;        double priority = new_cost + heuristic(next, goal);        frontier.put(next, priority);        came_from[next] = current;      }    }  }}</code></pre><h2 id="JPS算法"><a href="#JPS算法" class="headerlink" title="JPS算法"></a>JPS算法</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络整理</title>
      <link href="/2021/04/29/Recruitment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/29/Recruitment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计网体系结构"><a href="#计网体系结构" class="headerlink" title="计网体系结构"></a>计网体系结构</h1><h2 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h2><p>物理层，数据链路层，网络层，运输层，会话层，表示层，应用层</p><h2 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h2><p>网络接口层，网际层（IP），运输层（TCP,UDP），应用层</p><h2 id="五层"><a href="#五层" class="headerlink" title="五层"></a>五层</h2><p>物理层，数据链接层，网络层，运输层，应用层</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><ul><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道<br>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ul><h2 id="字节流和报文的区别"><a href="#字节流和报文的区别" class="headerlink" title="字节流和报文的区别"></a>字节流和报文的区别</h2><ul><li>TCP将应用层传过来的报文进行分段，放在发送缓冲区里，TCP发送的时候不管发送的是什么东西，直接按连续字节进行发送。</li><li>UDP将应用层传过来的报文直接加上头部进行发送，udp也没有缓冲区</li></ul><h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><ul><li><p>原因</p><blockquote><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p></blockquote></li><li><p>解决</p><blockquote><p>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。<br>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。<br>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。<br>使用更加复杂的应用层协议。</p></blockquote></li></ul><h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><ul><li><p>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</p></li><li><p>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</p></li><li><p>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</p></li><li><p>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p></li></ul><h1 id="实现udp可靠化"><a href="#实现udp可靠化" class="headerlink" title="实现udp可靠化"></a>实现udp可靠化</h1><ul><li>发送队列和接收队列</li><li>ACK、RTO计算、ARQ <blockquote><p>ACK确认比特   (ack确认号)<br>连接的往返时间成为 RTT<br>重传的超时时间 RTO<br>ARQ自动重传请求</p></blockquote></li><li>流量控制、拥塞控制</li></ul><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p><a href="https://zhuanlan.zhihu.com/p/84316213" target="_blank" rel="noopener">计算机网络太难？了解这一篇就够了</a></p><ul><li>A为客户端，B为服务器</li><li>一开始B创建传输控制块TCB,等待接受。然后A也创建TCB，向A发送请求，tcp报文段中SYN=1,seq=x.这次传输不传输数据</li><li>然后B接收到后，如果同意链接，发送报文段，SYN=1,ACK=1,seq=y,ack=x+1.</li><li>然后a接收到后，向B再发送确实报文,SYN=1,ACK=1,seq = x+1,ack = y+1。这里可以带数据也可以不带，不带的话不消耗序号，下次传输再seq=x+1</li></ul><h2 id="为什么不二次"><a href="#为什么不二次" class="headerlink" title="为什么不二次"></a>为什么不二次</h2><ul><li>防止信道内存在堵塞的报文，在结束链接后再次发给B，然后B就同意链接，一直等待a发送数据，导致资源消耗。如果三次链接的话，就要b再次收到a的确认报文才会建立链接</li></ul><h2 id="为什么不四次"><a href="#为什么不四次" class="headerlink" title="为什么不四次"></a>为什么不四次</h2><ul><li>完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ul><li>A-&gt;B FIN=1,seq=u(消耗一个序号),A进入终止等待1</li><li>B-&gt;A ACK=1,ack=u+1,seq=y(B进入关闭等待，a到b已经无数据传送，b到a还要继续传输剩下的数据)，然后a接收到后进入终止等待2，等待b发送终止信号</li><li>B-&gt;A FIN=1,seq=w,ACK=1,ack=u+1(重新发送ACK=1和ack=u+1)，此时B处于最后确认</li><li>A-&gt;B ACK=1,seq=u+1,ack=w+1（seq因为消耗了一个序号所以为u+1），b接收到后关闭，a进入等待。TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。</li></ul><h2 id="二三次合并？"><a href="#二三次合并？" class="headerlink" title="二三次合并？"></a>二三次合并？</h2><ul><li>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</li></ul><h2 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL?"></a>2MSL?</h2><ul><li><p>保证第四次挥手时，tcp报文不会丢失，导致a关闭了，b没关，所以在2msl内要是有b发送的重传报文则需要重新发送，并重新计时</p></li><li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p></li></ul><h2 id="保活计时器？"><a href="#保活计时器？" class="headerlink" title="保活计时器？"></a>保活计时器？</h2><ul><li>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</li></ul><h1 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h1><ul><li>数据包校验</li><li>对失序数据包重排序</li><li>丢弃重复数据</li><li>应答机制（ack确认）</li><li>超时重发</li><li>流量控制，拥塞控制</li></ul><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><ul><li><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p></li><li><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p></li></ul><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><ul><li><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p></li><li><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></li><li><p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p></li></ul><h2 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h2><ul><li>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li></ul><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><ul><li><p>到达慢开始阈值的时候，拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p></li><li><p>如果出现了超时，则令 ssthresh（慢开始阈值） = cwnd / 2，然后重新执行慢开始。</p></li></ul><h2 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h2><ul><li><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p></li><li><p>在发送方，如果收到三个重复确认（3-ACK），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p></li></ul><h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><ul><li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li></ul><h1 id="http-post-get"><a href="#http-post-get" class="headerlink" title="http(post get)"></a>http(post get)</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p></li><li><p>从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</p></li><li><p>从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</p></li><li><p>从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</p></li><li><p>就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</p></li><li><p>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法整理</title>
      <link href="/2021/04/27/Recruitment/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/27/Recruitment/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="topk"><a href="#topk" class="headerlink" title="topk"></a>topk</h1><ul><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></li></ul><pre><code class="lang-cpp">class Solution {public:    int partition(vector&lt;int&gt;&amp; nums,int i,int j)    {        int pviot = nums[i];        while(i &lt; j)        {            for(;i&lt;j &amp;&amp; nums[j] &lt;= pviot ;--j);                nums[i] = nums[j];            for(;i&lt;j &amp;&amp; nums[i] &gt;= pviot;++i);                nums[j] = nums[i];        }        nums[i] = pviot;        return i;    }    int quickSort(vector&lt;int&gt;&amp; nums,int i,int j ,int k)    {        int pos = partition(nums,i,j);        if(k &gt; pos)            return quickSort(nums,pos+1,j,k);        else if( k &lt; pos)            return quickSort(nums,i,pos-1,k);        else             return nums[pos];    }    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        return quickSort(nums,0,nums.size()-1,k-1);    }};</code></pre><h1 id="手撕堆排"><a href="#手撕堆排" class="headerlink" title="手撕堆排"></a>手撕堆排</h1><pre><code class="lang-cpp">class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     * 将给定数组排序     * @param arr int整型vector 待排序的数组     * @return int整型vector     */    void HeapShiftDown(vector&lt;int&gt;&amp; arr,int k,int n)    {        for(int m = k*2+1; m &lt; n; m=m*2+1)        {            if(m+1 &lt; n &amp;&amp; arr[m+1] &gt; arr[m])                 m++;            if(arr[m]&gt; arr[k])            {               swap(arr[k],arr[m]);                k = m;            }            else                break;        }    }    void HeapAdjust(vector&lt;int&gt;&amp; arr)    {        int k = (arr.size()-1)/2;        for(int i = k; i &gt;=0;--i)            HeapShiftDown(arr,i,arr.size());    }    vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) {        // write code here        int n = arr.size();        HeapAdjust(arr);        for(int i = n-1;i&gt;0;--i)        {            swap(arr[0],arr[i]);            HeapShiftDown(arr,0,i);        }        return arr;    }};</code></pre><h1 id="手撕快速"><a href="#手撕快速" class="headerlink" title="手撕快速"></a>手撕快速</h1><ul><li><p><a href="https://www.zhihu.com/question/22393997" target="_blank" rel="noopener">复杂度证明</a></p><pre><code class="lang-cpp">class Solution {public:  /**   * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可   * 将给定数组排序   * @param arr int整型vector 待排序的数组   * @return int整型vector   */  int Partition(vector&lt;int&gt;&amp; nums,int i,int j)  {      int pivot = nums[i];      while(i&lt;j)      {            while(i&lt;j &amp;&amp; nums[j] &gt;= pivot)                --j;              nums[i] = nums[j];          while(i&lt;j &amp;&amp; nums[i] &lt;= pivot)                ++i;              nums[j] = nums[i];      }      nums[i] = pivot;      return i;  }  void QuickSort(vector&lt;int&gt;&amp; nums,int i,int j)  {      if(i &lt; j)      {          int index = Partition(nums,i,j);          QuickSort(nums, i, index-1);          QuickSort(nums, index+1, j);       }  }  vector&lt;int&gt; MySort(vector&lt;int&gt;&amp; arr) {      // write code here      QuickSort(arr, 0, arr.size()-1);      return arr;  }};</code></pre></li></ul><h1 id="手撕归并"><a href="#手撕归并" class="headerlink" title="手撕归并"></a>手撕归并</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void Merge(vector&lt;int&gt;&amp; nums,int i,int mid,int j){    vector&lt;int&gt; v;    int a=i,b=mid+1;    while(a &lt;= mid &amp;&amp; b &lt;=j)    {        if(nums[a] &lt; nums[b])        {            v.push_back(nums[a]);            ++a;        }        else        {            v.push_back(nums[b]);            ++b;           }    }    while(a &lt;= mid)    {        v.push_back(nums[a]);        ++a;    }    while(b &lt;= j)    {        v.push_back(nums[b]);        ++b;       }    for(int k= 0; k&lt; v.size();++k)        nums[i+k] = v[k];}void MergeSort(vector&lt;int&gt;&amp; nums,int i,int j){    if(i &lt; j)    {        int mid = i + (j-i)/2;        MergeSort(nums,i,mid);        MergeSort(nums,mid+1,j);        Merge(nums,i,mid,j);    }}int main(){    int n;    cin&gt;&gt;n;    vector&lt;int&gt; v(n,0);    for(int i = 0; i&lt; n; ++i)    {        cin&gt;&gt;v[i];    }    MergeSort(v,0,n-1);    for(int i =0; i &lt; v.size();++i)    {        cout&lt;&lt;v[i];        if(i != v.size()-1)            cout&lt;&lt;&quot; &quot;;    }    return 0;}</code></pre><h1 id="最长回文字串"><a href="#最长回文字串" class="headerlink" title="最长回文字串"></a>最长回文字串</h1><ul><li>dp</li></ul><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        string res;        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(),vector&lt;bool&gt;(s.size(),false));        for(int i = s.size()-1; i&gt;=0 ;--i)        {            for(int j = i; j &lt; s.size();++j)            {                if( (j-i &gt; 1 &amp;&amp; s[i] == s[j] &amp;&amp; dp[i+1][j-1]) || (j-i &lt;= 1 &amp;&amp; s[i] == s[j] ))                {                    dp[i][j] = true;                    if(j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);                }            }        }        return res;    }};</code></pre><ul><li><p>中心扩展</p><pre><code class="lang-cpp">class Solution {public:  pair&lt;int,int&gt; expandAroundCenter(string s,int i,int j)  {      while(i&gt;=0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j])      {          --i;          ++j;      }      return {i+1,j-1};  }  string longestPalindrome(string s) {      int start=0,end = 0;      for(int i = 0; i &lt; s.size();++i)      {          auto [left1,right1] = expandAroundCenter(s,i,i);          auto [left2,right2] = expandAroundCenter(s,i,i+1);          if(right1 -left1 &gt; end -start)          {              end = right1;              start = left1;          }          if(right2 - left2 &gt; end - start)          {              end = right2;              start = left2;          }      }      return s.substr(start,end-start+1);  }};</code></pre></li></ul><h1 id="最大连续子数组的和"><a href="#最大连续子数组的和" class="headerlink" title="最大连续子数组的和"></a>最大连续子数组的和</h1><ul><li>dp</li></ul><pre><code class="lang-cpp">class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int res = nums[0];        vector&lt;int&gt; dp(n,nums.size());        dp[0] = nums[0];        for(int i = 1; i &lt; nums.size();++i)        {            if(dp[i-1] + nums[i] &lt; nums[i])                dp[i] = nums[i];            else                dp[i] = dp[i-1] + nums[i];            res = max(res,dp[i]);        }        return res;    }};</code></pre><h1 id="如果删除vector中间元素-怎么实现（不能用erease，无序）"><a href="#如果删除vector中间元素-怎么实现（不能用erease，无序）" class="headerlink" title="如果删除vector中间元素 怎么实现（不能用erease，无序）"></a>如果删除vector中间元素 怎么实现（不能用erease，无序）</h1><ul><li>将中间之后的元素往前移动一个位置并vector大小减一</li></ul><h1 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h1><pre><code class="lang-cpp">#include &lt;QCoreApplication&gt;#include &lt;assert.h&gt;#include &lt;QDebug&gt;//普通版本的strcpy，实现没有检查dst和src内存重叠问题,会崩溃char* myStrcpy(char* dst, const char* src){ //const约束,内容不可变    assert(src != Q_NULLPTR &amp;&amp; dst != Q_NULLPTR); //参数非0检验    char* pstr = dst;    while ((*dst++ = *src++) != &#39;\0&#39;){}    return pstr;}//检查内存重叠char* my1Strcpy(char* dst, const char* src){    assert(src != Q_NULLPTR &amp;&amp; dst != NULL);    char * nsrc = const_cast&lt;char*&gt;(src);    char * adest = dst;    size_t size = strlen(src);    if (src &lt; dst &amp;&amp; (src + size) &gt; dst) {        //内存重叠,从后向前复制        char* bsrcp = nsrc + size - 1;        char* bdestp = dst + size - 1;        while ((*bdestp-- = *bsrcp--) &amp;&amp; size-- != 0){}    } else {        while ((*dst++ = *nsrc++) != &#39;\0&#39;){}    }    return dst;}int main(int argc, char *argv[]){    QCoreApplication a(argc, argv);    char dest[10] = &quot;hello&quot;;    qDebug() &lt;&lt; my1Strcpy(&amp;dest[3], dest) &lt;&lt; endl;    return a.exec();}</code></pre><h1 id="输入1-n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）"><a href="#输入1-n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）" class="headerlink" title="输入1~n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）"></a>输入1~n共n个数，打乱后随机删除一个，找出删除的那个数（不许排序）</h1><p>对于删除一个数，大概有四种方法：</p><p>（1）用1+2+…+n减去当前输入数据的总和。时间复杂度：O(n) 空间复杂度：O(1) 【容易溢出】</p><p>（2）用1<em>2…</em>n除以当前输入数据的总积。时间复杂度：O(n) 空间复杂度：O(1) 【容易溢出】</p><p>（3）用1^2^…^n的结果在逐个异或当前输入数据。时间复杂度：O(n) 空间复杂度：O(1)</p><p>（4）对输入数据进行Hash，然后从头到尾遍历一次。时间复杂度O(n) 空间复杂度O(n)</p><h1 id="输入1-n共n个数，打乱后随机删除一个，再复制一个，找出这两个数"><a href="#输入1-n共n个数，打乱后随机删除一个，再复制一个，找出这两个数" class="headerlink" title="输入1~n共n个数，打乱后随机删除一个，再复制一个，找出这两个数"></a>输入1~n共n个数，打乱后随机删除一个，再复制一个，找出这两个数</h1><ul><li><p>类似 剑指 Offer 56 - I. 数组中数字出现的次数</p><ul><li>第一轮整体遍历，求出a^b（因为相同的数字异或为0，0异或任何数字为数字自身）</li><li>然后结合a^b以及原来数组求出这两个数字</li><li>原理：用一个只有一位为1的数字来遍历异或整个数组，把这个数组分成两个子数组（异或结果相同的数字在同一个子数组），如果是两个相同的数字，它们一定在同一个子数组里（保证子数组异或时为0），现在只需要把两个只出现一次的数字分到不同的子数组，那么子数组分别遍历异或得到的两个数字就是这两个数字。</li><li>怎么把两个只出现一次的数字分到不同地子数组？<ul><li>找到a^b第一个为1的位置，异或结果为1说明a和b在这一位上不同，那用只有这一位为1的数字m去分别异或a和b，得到的结果一定不同，也就把a和b分到了不同的子数组。结合上一点得出结果。</li></ul></li></ul></li><li><p>实在写不出来hash</p></li></ul><h1 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h1><pre><code class="lang-cpp">/** * struct TreeNode { *    int val; *    struct TreeNode *left; *    struct TreeNode *right; * }; */class Solution {public:    /**     *      * @param root TreeNode类 the root of binary tree     * @return int整型vector&lt;vector&lt;&gt;&gt;     */    vector&lt;int&gt; preorder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur;        s.push(root);        while(!s.empty())        {            cur = s.top();            s.pop();            res.push_back(cur-&gt;val);            if(cur-&gt;right)                s.push(cur-&gt;right);            if(cur-&gt;left)                s.push(cur-&gt;left);        }        return res;    }    vector&lt;int&gt; inorder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur = root;        while(!s.empty() || cur != nullptr)        {            if(cur != nullptr)            {                s.push(cur);                cur = cur-&gt;left;            }            else            {                cur = s.top();                s.pop();                res.push_back(cur-&gt;val);                cur = cur-&gt;right;            }        }        return res;    }    vector&lt;int&gt; postoreder(TreeNode* root)    {        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; s;        TreeNode* cur = root;        TreeNode* pre = nullptr;        while(!s.empty() || cur != nullptr)        {            if(cur!=nullptr) {                s.push(cur);                cur = cur-&gt;left;            }            else {                cur = s.top();                s.pop();                if(cur-&gt;right==nullptr || pre==cur-&gt;right) { // 访问节点的条件                    res.push_back(cur-&gt;val); // 访问                    pre = cur; // 这一步是记录上一次访问的节点                    cur = nullptr; // 此处为了跳过下一次循环的访问左子节点的过程，直接进入栈的弹出阶段，因为但凡在栈中的节点，它们的左子节点都肯定被经过且已放入栈中。                }                else                 { // 不访问节点的条件                    s.push(cur); // 将已弹出的根节点放回栈中                    cur = cur-&gt;right; // 经过右子节点                }        }    }         return res;}    vector&lt;vector&lt;int&gt; &gt; threeOrders(TreeNode* root) {        // write code here        vector&lt;vector&lt;int&gt; &gt; res;        res.push_back(preorder(root));        res.push_back(inorder(root));        res.push_back(postoreder(root));        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学整理</title>
      <link href="/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html" target="_blank" rel="noopener">细说图形学渲染管线</a></p><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><h2 id="Broad-Phase"><a href="#Broad-Phase" class="headerlink" title="Broad-Phase"></a>Broad-Phase</h2><p><a href="https://zhuanlan.zhihu.com/p/113415779" target="_blank" rel="noopener">游戏物理引擎(二) 碰撞检测之Broad-Phase</a></p><ul><li><p>Broad-Phase使用某种Bounding Volume来表示刚体的碰撞信息,然后用空间划分的方式来保存这些Bounding Volume,就可以再较短的时间内筛选出可能互相碰撞的刚体对.</p></li><li><p>AABB包围盒</p></li></ul><h3 id="Uniform-Grid"><a href="#Uniform-Grid" class="headerlink" title="Uniform Grid"></a>Uniform Grid</h3><ul><li>将空间划分成等大方块</li></ul><h3 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h3><ul><li>每次只沿某一个轴划分 二叉树like</li></ul><h3 id="Oct-Tree"><a href="#Oct-Tree" class="headerlink" title="Oct-Tree"></a>Oct-Tree</h3><ul><li>三维均匀切分,设置每一块的终止条件</li></ul><h3 id="BSP-Tree"><a href="#BSP-Tree" class="headerlink" title="BSP-Tree"></a>BSP-Tree</h3><ul><li>每次取一个方向（非横平竖直）将空间分为两部分 （会很麻烦）</li></ul><h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><ul><li><p>以object为单位划分空间</p></li><li><p>二叉树，两个子节点分别存两部分物体的AABB</p></li><li><p>一个物体只可能出现在一个包围盒中</p></li><li><p>如何划分很有讲究，不好的划分会使包围盒重合，降低效率</p><blockquote><p>可以用topk算法快速找中位物体划分</p></blockquote></li></ul><h2 id="Narrow-Phase"><a href="#Narrow-Phase" class="headerlink" title="Narrow-Phase"></a>Narrow-Phase</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/127844705" target="_blank" rel="noopener">游戏物理引擎(三) 碰撞检测之Narrow-Phase</a></li></ul><h3 id="Separating-Axis-Theorem-SAT-算法"><a href="#Separating-Axis-Theorem-SAT-算法" class="headerlink" title="Separating Axis Theorem(SAT)算法"></a>Separating Axis Theorem(SAT)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/176667175" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（一） - SAT</a></li></ul><h3 id="Gilbert-Johnson-Keerthi-GJK-算法"><a href="#Gilbert-Johnson-Keerthi-GJK-算法" class="headerlink" title="Gilbert-Johnson-Keerthi (GJK)算法"></a>Gilbert-Johnson-Keerthi (GJK)算法</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（上）</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/177006015" target="_blank" rel="noopener">2D凸多边形碰撞检测算法（二） - GJK（下）</a></li></ul><h1 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a>DrawCall</h1><p><a href="https://zhuanlan.zhihu.com/p/358687016" target="_blank" rel="noopener">Unity:浅谈对Drawcall的理解</a></p><ul><li>渲染分为三个阶段:应用阶段、几何阶段、光栅化阶段</li><li>Drawllcall就是应用阶段收集完模型的顶点材质以及其他数据后,CPU去通知GPU去对所传递的图元进行渲染。</li></ul><h2 id="为啥要减少drawcall呢？"><a href="#为啥要减少drawcall呢？" class="headerlink" title="为啥要减少drawcall呢？"></a>为啥要减少drawcall呢？</h2><ul><li>传输数据消耗较大，GPU的计算能力又非常优秀，那么存在一种情况:Cpu传递的drawcall指令只渲染一小部分，GPU飞快的渲染完了，而下一条drawcall的指令还没有完成传输过程。此类的指令过多就造成了卡顿。所以提高drawcall传输效率就非常有必要了</li></ul><h2 id="减少drawcall的方法"><a href="#减少drawcall的方法" class="headerlink" title="减少drawcall的方法"></a>减少drawcall的方法</h2><ul><li>主要的方法就是合批（Batch），合批又分为静态合批，动态合批两个不同的操作</li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>mipmap（多级渐远纹理）<blockquote><p>它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一,每提升一个Level，对相邻的四个元素进行插值。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p></blockquote></li></ul><h1 id="前向渲染和延迟渲染"><a href="#前向渲染和延迟渲染" class="headerlink" title="前向渲染和延迟渲染"></a>前向渲染和延迟渲染</h1><h1 id="齐次坐标和透视除法"><a href="#齐次坐标和透视除法" class="headerlink" title="齐次坐标和透视除法"></a>齐次坐标和透视除法</h1><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul><li><p>目的：为了解决欧式几何空间中两条支线是不能相交的，但透视空间两条支线是可以相交的。</p></li><li><p>齐次坐标就是用N+1维来代表N维坐标，通过添加一个额外的分量w，</p></li></ul><blockquote><p>如果(x,y,z)是个点，则变为(x,y,z,1);<br>如果(x,y,z)是个向量，则变为(x,y,z,0);</p></blockquote><h2 id="透视除法"><a href="#透视除法" class="headerlink" title="透视除法"></a>透视除法</h2><ul><li>透视除法不在vs中进行，vs转换得到的是裁剪空间，透视除法在光栅化之前进行</li><li>透视除法将齐次坐标的每一个分量除以w，得到NDC</li><li>透视除法可以将齐次坐标转换成欧式坐标</li></ul><h1 id="欧拉角和万向结死锁"><a href="#欧拉角和万向结死锁" class="headerlink" title="欧拉角和万向结死锁"></a>欧拉角和万向结死锁</h1><p><a href="https://zhuanlan.zhihu.com/p/42519819" target="_blank" rel="noopener">3D游戏世界里的万向节锁</a></p><ul><li>万向结死锁就是一个物体在一个3D世界里面随着旋转顺序和旋转角度的改变，导致物体只能在一个固定的平面旋转，无法旋转到你预想的角度。由于物体的旋转，物体的坐标轴方向也发生了改变，导致其中2条坐标轴发生了重合。当你围绕着重合的坐标轴旋转时，物体的旋转方向始终在一个平面上旋转。</li></ul><h1 id="画线算法"><a href="#画线算法" class="headerlink" title="画线算法"></a>画线算法</h1><ul><li>光栅直线的特点<blockquote><p>X的值每次增长1 </p></blockquote></li></ul><blockquote><p>Y的值会在保持不变和增长1之间选择</p></blockquote><h2 id="DDA"><a href="#DDA" class="headerlink" title="DDA"></a>DDA</h2><h2 id="Bresenham"><a href="#Bresenham" class="headerlink" title="Bresenham"></a>Bresenham</h2><h1 id="点到平面计算距离"><a href="#点到平面计算距离" class="headerlink" title="点到平面计算距离"></a>点到平面计算距离</h1><p><img src="点到直线距离.png" alt></p><ul><li>设点为P，根据屏幕方程得到平面法向量N,取平面上一点Q,连接PQ,得到向量QP,设两条向量的夹角为Alpha,则cos(Alpha)可求，然后根据三角函数，距离可求</li></ul><h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>$\left[\begin{matrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{matrix} \right]$</p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li>绕x轴</li></ul><p>$\left[\begin{matrix}<br>    1 &amp; 0 &amp; 0 &amp; 0\\<br>    0 &amp; cos\theta  &amp; -sin\theta &amp; 0\\<br>    0 &amp; sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕y轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; 0 &amp; sin\theta &amp; 0\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\<br>    -sin\theta &amp; 0 &amp; cos\theta  &amp; 0 \\<br>        0 &amp; 0 &amp; 0 &amp; 1   \\<br>\end{matrix} \right]$</p><ul><li>绕z轴</li></ul><p>$\left[\begin{matrix}<br>    cos\theta &amp; -sin\theta &amp; 0 &amp; 0\\<br>    sin\theta &amp; cos\theta  &amp; 0 &amp; 0\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix} \right]$</p><ul><li>绕任意轴<blockquote><p>太复杂了</p></blockquote></li></ul><blockquote><p>绕任意轴都可以轴上面三个组合得到</p></blockquote><h1 id="正交矩阵的逆矩阵"><a href="#正交矩阵的逆矩阵" class="headerlink" title="正交矩阵的逆矩阵"></a>正交矩阵的逆矩阵</h1><ul><li>转置</li></ul><h1 id="shaowmap"><a href="#shaowmap" class="headerlink" title="shaowmap"></a>shaowmap</h1><h1 id="延迟渲染和前向渲染"><a href="#延迟渲染和前向渲染" class="headerlink" title="延迟渲染和前向渲染"></a>延迟渲染和前向渲染</h1><h1 id="深度是什么，深度值啥时候写入"><a href="#深度是什么，深度值啥时候写入" class="headerlink" title="深度是什么，深度值啥时候写入"></a>深度是什么，深度值啥时候写入</h1><ul><li>光栅化的时候就能知道深度值</li></ul><h1 id="怎样从一个旋转缩放矩阵中拆分出缩放矩阵"><a href="#怎样从一个旋转缩放矩阵中拆分出缩放矩阵" class="headerlink" title="怎样从一个旋转缩放矩阵中拆分出缩放矩阵"></a>怎样从一个旋转缩放矩阵中拆分出缩放矩阵</h1><ul><li>缩放分量就是矩阵</li><li>中每一列的模的大小，然后得出缩放后除以相应大小就能得到旋转矩阵</li></ul><h1 id="点乘和叉乘应用场景"><a href="#点乘和叉乘应用场景" class="headerlink" title="点乘和叉乘应用场景"></a>点乘和叉乘应用场景</h1><ul><li>点乘可以快速得到两向量之间的夹角，判断两个向量是否同方向  </li><li>判定左右和内外</li></ul><h2 id="怎么判断一个点在矩形内，园内，三角形内"><a href="#怎么判断一个点在矩形内，园内，三角形内" class="headerlink" title="怎么判断一个点在矩形内，园内，三角形内"></a>怎么判断一个点在矩形内，园内，三角形内</h2><ul><li>通过叉乘判断是否这个点都在这个形状的一侧，如果都在一侧就是在内部，不然都在外部</li></ul><h1 id="Phong和blinnphong的区别"><a href="#Phong和blinnphong的区别" class="headerlink" title="Phong和blinnphong的区别"></a>Phong和blinnphong的区别</h1><p>phong = 环境光+漫反射+镜面反射<br>blinnphong在phong的高光部分进行修改，用法线和半角向量</p><h2 id="blinnphong的优缺点"><a href="#blinnphong的优缺点" class="headerlink" title="blinnphong的优缺点"></a>blinnphong的优缺点</h2><ul><li>运算效率高在Phong模型中，必须计算反射光线R，但是在BlinnPhong模型中，用N·H的值来取代V·R。</li><li>2.高光更加柔和、真实感没Phong模型强BlinnPhong 引入了 法线直接计算高光。在phong中，法线只是用于计算入射光线的反射光线，结果要比Phong更加柔和。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 智能指针</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/150555165" target="_blank" rel="noopener">现代 C++：一文读懂智能指针</a></p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h2><p>头文件：<code>#include &lt;memory&gt;</code></p><h2 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h2><pre><code class="lang-cpp">std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</code></pre><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul><li>共享资源所有权的指针。</li></ul><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul><li>共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</li></ul><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>独占资源所有权的指针。</li></ul><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h3 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h3><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>Aliasing constructor<blockquote><p>简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p></blockquote></li></ul><pre><code class="lang-cpp">// shared_ptr constructor example#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;using Vec = std::vector&lt;int&gt;;std::shared_ptr&lt;int&gt; GetSPtr() {    auto elts = {0, 1, 2, 3, 4};    std::shared_ptr&lt;Vec&gt; pvec = std::make_shared&lt;Vec&gt;(elts); //use_count == 1    std::shared_ptr&lt;int&gt; t(pvec, &amp;(*pvec)[2]);  //use_count == 2    pvec.reset(); // use_count == 1    return t;}int main() {    std::shared_ptr&lt;int&gt; sptr = GetSPtr();// use_count == 1 ,t,pvec都销毁,sptr引用    sptr.reset();// use_count == 1    cout&lt;&lt;*sptr.get()&lt;&lt;endl;  // =2  指向的是&amp;(*pvec)[2],并且延长了pvec指向vector&lt;int&gt;的生命周期    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理</title>
      <link href="/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/21/Recruitment/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vector实现原理"><a href="#vector实现原理" class="headerlink" title="vector实现原理"></a>vector实现原理</h1><p><a href="https://zhuanlan.zhihu.com/p/358113531" target="_blank" rel="noopener">(新手向)谈谈C++中的萃取</a><br><a href="https://blog.csdn.net/ncepu_Chen/article/details/114947710" target="_blank" rel="noopener">侯捷C++课程笔记03: STL标准库与泛型编程</a></p><ul><li>容器<code>vector</code>的代码如下:</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc= alloc&gt;class vector {public:    typedef T value_type;    typedef value_type* iterator;    typedef value_type&amp; reference;    typedef size_t size_type;protected:    iterator start;    iterator finish;    iterator end_of_storage;public:    iterator begin() { return start; }    iterator end() { return finish; }    size_type size() const { return size_type(end() - begin()); }    size_type capacity() const { return size_type(end_of_storage - begin()); }    bool empty() const { return begin() == end(); }    reference operator[](size_type n) { return *(begin() + n); }    reference front() { return *begin(); }    reference back() { return *(end() - 1); }};</code></pre><p><img src="https://img-blog.csdnimg.cn/20210321014124690.png" alt></p><p>容器<code>vector</code>的迭代器<code>start</code>指向第一个元素,迭代器<code>finish</code>指向最后一个元素的下一个元素,这两个迭代器对应begin()和end()的返回值,维持了<strong>前闭后开</strong>的特性.</p><p><code>vector</code><strong>对使用者是连续的</strong>,因此重载了<code>[]</code>运算符.</p><p><code>vector</code><strong>的实现也是连续的</strong>,因此使用指针类型做迭代器(即迭代器<code>vector&lt;T&gt;::iterator</code>的实际类型是原生指针<code>T*</code>).</p><h2 id="内存满了怎么办（push-back）"><a href="#内存满了怎么办（push-back）" class="headerlink" title="内存满了怎么办（push_back）"></a>内存满了怎么办（push_back）</h2><ul><li><code>vector::push_back</code>方法先判断内存空间是否满,若内存空间不满则直接插入;若内存空间满则调用<code>insert_aux</code>函数先扩容两倍再插入元素.</li></ul><pre><code class="lang-cpp">void push_back(const T &amp;x) {    if (finish != end_of_storage) { // 尚有备用空间,则直接插入,并调整finish迭代器        construct(finish, x);                ++finish;                        } else                             // 已无备用空间则调用 insert_aux 先扩容再插入元素        insert_aux(end(), x);}</code></pre><ul><li><code>insert_aux</code>被设计用于在容器任意位置插入元素,在容器内存空间不足会现将原有容器扩容.</li></ul><pre><code class="lang-cpp">template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_ux(iterator position, const T &amp;x) {    if (finish != end_of_storage) {     // 尚有备用空间,则将插入点后元素后移一位并插入元素，因为这个函数还会被其他函数调用，比如insert之类的所以还是要检查        construct(finish, *(finish - 1));   // 以vector最后一个元素值为新节点的初值        ++finish;        T x_copy = x;        copy_backward(position, finish - 2, finish - 1);        *position = x_copy;    } else {        // 已无备用空间,则先扩容,再插入        const size_type old_size = size();        const size_type len = old_size != 0 ?: 2 * old_size:1;  // 扩容后长度为原长度的两倍        iterator new_start = data_allocator::allocate(len);        iterator new_finish = new_start;        try {            new_finish = uninitialized_copy(start, position, new_start);    // 拷贝插入点前的元素            construct(new_finish, x);                                       // 插入新元素并调整水位            ++new_finish;            new_finish = uninitialized_copy(position, finish, new_finish);  // 拷贝插入点后的元素()，还是比如说insert函数，这种情况就要把后面的元素进行拷贝        }        catch (...) {            // 插入失败则回滚,释放内存并抛出错误            destroy(new_start, new_finish) :            data_allocator::deallocate(new_start, len);            throw;        }        // 释放原容器所占内存        destroy(begin(), end());        deallocate();        // 调整迭代器        start = new_start;        finish = new_finish;        end_of_storage = new_start + len;    }};</code></pre><h1 id="map实现原理"><a href="#map实现原理" class="headerlink" title="map实现原理"></a>map实现原理</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h1 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h1><ul><li>复杂度O(1)</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>直接定址法</li></ul><p><code>H(key) = key</code> 或 <code>H(Key) = a * key + b</code></p><ul><li>除留余数法</li></ul><p><code>H(key) = key % p(p &lt;=m , m = 散列表长)</code></p><ul><li><p>数字分析法</p><ul><li>如果关键字是r进行数，取数码分布比较均价的若干位作为key</li></ul></li><li><p>平法取中法</p><ul><li>将关键字平法取中间几位</li></ul></li></ul><h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><ul><li>空闲地址既可以存放同义词也可以存放非同义词</li></ul><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><h4 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h4><h4 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h4><hr><ul><li>开放定址法不能删除已有元素</li></ul><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>将同义词存放在一个线性表中</p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 RTTI</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20RTTI/</url>
      
        <content type="html"><![CDATA[<h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><p>typeid、type_info 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Flyable                       // 能飞的{public:    virtual void takeoff() = 0;     // 起飞    virtual void land() = 0;        // 降落};class Bird : public Flyable         // 鸟{public:    void foraging() {...}           // 觅食    virtual void takeoff() {...}    virtual void land() {...}    virtual ~Bird(){}};class Plane : public Flyable        // 飞机{public:    void carry() {...}              // 运输    virtual void takeoff() {...}    virtual void land() {...}};class type_info{public:    const char* name() const;    bool operator == (const type_info &amp; rhs) const;    bool operator != (const type_info &amp; rhs) const;    int before(const type_info &amp; rhs) const;    virtual ~type_info();private:    ...};void doSomething(Flyable *obj)                 // 做些事情{    obj-&gt;takeoff();    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;        // 输出传入对象类型（&quot;class Bird&quot; or &quot;class Plane&quot;）    if(typeid(*obj) == typeid(Bird))            // 判断对象类型    {        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化        bird-&gt;foraging();    }    obj-&gt;land();}int main(){    Bird *b = new Bird();    doSomething(b);    delete b;    b = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 只在堆上或栈上生成对象的类</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%8F%AA%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h1><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p></blockquote><h2 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h2><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h2 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h2><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 delete this</title>
      <link href="/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/"/>
      <url>/2021/04/21/C++/C++%E5%A4%8D%E4%B9%A0%20delete%20this/</url>
      
        <content type="html"><![CDATA[<h1 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h1><blockquote><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p></blockquote><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 内存分配和管理</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h1><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h1 id="malloc与free"><a href="#malloc与free" class="headerlink" title="malloc与free"></a>malloc与free</h1><p>用于分配、释放内存</p><p>malloc、free 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">char *str = (char*) malloc(100);assert(str != nullptr);</code></pre><p>释放内存后指针置空</p><pre><code class="lang-cpp">free(p); p = nullptr;</code></pre><h1 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h1><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><p>new、delete 使用</p><p>申请内存，确认是否申请成功</p><pre><code class="lang-cpp">int main(){    T* t = new T();     // 先内存分配 ，再构造函数    delete t;           // 先析构函数，再内存释放    return 0;}</code></pre><h1 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h1><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><pre><code class="lang-cpp">new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list }</code></pre><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 虚函数</title>
      <link href="/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2021/04/20/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li><p>析构函数： 父类的后执行，子类的先执行</p></li><li><p>附加</p><blockquote><p>默认构造函数（无参构造函数），有参构造函数，拷贝构造函数，级别依次递增。当我们提供了后面的，前面的编译器就不会提供了。</p></blockquote></li></ul><h2 id="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"><a href="#构造函数不能定义为虚函数，析构函数一般需要定义为虚函数" class="headerlink" title="构造函数不能定义为虚函数，析构函数一般需要定义为虚函数"></a>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</h2><ul><li><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></li></ul><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><pre><code class="lang-cpp">virtual int A() = 0;</code></pre><h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文<strong>虚继承</strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p></blockquote><h1 id="虚函数指针与虚函数表"><a href="#虚函数指针与虚函数表" class="headerlink" title="虚函数指针与虚函数表"></a>虚函数指针与虚函数表</h1><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><blockquote><p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p></blockquote><ul><li>虚函数 C++对象的内存布局<ul><li>只有数据成员的对象</li><li>没有虚函数的对象</li><li>拥有仅一个虚函数的类对象</li><li>拥有多个虚函数的类对象</li><li>单继承且本身不存在虚函数的继承类的内存布局</li><li>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</li><li>定义了基类没有的虚函数的单继承的类对象布局</li><li>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</li><li>如果第1个直接基类没有虚函数(表)</li><li>What if 两个基类都没有虚函数表</li><li>如果有三个基类: 虚函数表分别是有, 没有, 有!</li></ul></li></ul><h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1><p>原因:虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。<br>目的：令某个类做出声明，承诺愿意共享它的基类<br>形式:</p><pre><code class="lang-cpp">//关键字public virtual的顺序随意class A:public virtual B;class C:virtual public B;</code></pre><ul><li><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p></li><li><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></li></ul><p><a href="https://blog.csdn.net/longlovefilm/article/details/80558879" target="_blank" rel="noopener">C++ 虚继承实现原理（虚基类表指针与虚基类表</a></p><h2 id="虚继承与虚函数"><a href="#虚继承与虚函数" class="headerlink" title="虚继承与虚函数"></a>虚继承与虚函数</h2><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h1 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h1><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h1 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h1><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数·</li></ul></li></ul><h1 id="继承、向上转型、向下转型时虚函数调用规则"><a href="#继承、向上转型、向下转型时虚函数调用规则" class="headerlink" title="继承、向上转型、向下转型时虚函数调用规则"></a>继承、向上转型、向下转型时虚函数调用规则</h1><blockquote><p>参考:<a href="https://blog.csdn.net/o1101574955/article/details/77771357" target="_blank" rel="noopener">继承、向上转型、向下转型时虚函数调用规则</a></p></blockquote><ul><li>函数调用具体看三个关键信息：内存块的类型，当前类型，以及是否为虚函数<ul><li>对于虚函数,主要看查找谁的虚函数表<ul><li>对于对象调用函数,查找当前类型的类的虚函数表</li><li>对于指针类型,看内存块的具体类型,查找它的类的虚函数表’</li></ul></li><li>对于非虚函数，不涉及到查虚函数表的问题，直接调用当前类型的类里的函数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式整理</title>
      <link href="/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/19/Recruitment/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>单例模式</li></ul><pre><code class="lang-cpp">// 懒汉式单例模式class Singleton{private:    Singleton() { }    static Singleton * pInstance;public:    static Singleton * GetInstance()    {        if (pInstance == nullptr)            pInstance = new Singleton();        return pInstance;    }};// 线程安全的单例模式class Singleton{private:    Singleton() { }    ~Singleton() { }    Singleton(const Singleton &amp;);    Singleton &amp; operator = (const Singleton &amp;);public:    static Singleton &amp; GetInstance()    {        // 编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例        static Singleton instance; //对对象使用static会调用默认构造函数        return instance;    }};</code></pre><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 宏</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li><li>不做类型检查，在预编译阶段制作一对一替换</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 引用</title>
      <link href="/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/"/>
      <url>/2021/04/19/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul><li>左值和右值<ul><li>辣鸡的C++ PRIMER解释<ul><li>左值(lvalue) : 是那些求值结果为对象或者函数的表达式，一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象。</li><li>右值(rvalue) : 是指一种表达式,其结果是值而非值所在的位置。 </li></ul></li><li>参考博客:<a href="https://blog.csdn.net/xuwqiang1994/article/details/79924310" target="_blank" rel="noopener">https://blog.csdn.net/xuwqiang1994/article/details/79924310</a><ul><li>左值(lvalue) : lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。</li><li>右值(rvalue) : rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是不在内存中占有确定位置的表达式。</li></ul></li><li>参考博客:<a href="https://blog.csdn.net/qq_24964575/article/details/52202989" target="_blank" rel="noopener">https://blog.csdn.net/qq_24964575/article/details/52202989</a><ul><li>左值可以当作右值使用,右值不能当左值用.</li><li>左值可以出现在=的任何一方,</li><li>出现在=右方的左值,是把左值当作右值使用,这是非常正常的.</li><li>右值,不能当作左值使用.</li><li>能够(单独)出现在=左方的是左值(实际是左右值,左值总是可以当作右值使用)</li><li>只能够出现在=右方的,是右值(纯粹的右值),不能当作左值使用.</li><li>左值代表地址单元,右值代表数据本身.</li><li>地址单元里的数据,是左值变量的右值的含义.</li><li>右值包括,纯数据,比如常数100,字符串常量”12345”等</li><li>以及地址单元中存储的数据.比如x ,这是左值当作右值使用代表的意义.</li><li>以及一些常变量(有确切地址的常量,可以象变量一样有个名字,其实就是变量,只是右值化了,不能当左值使用了)的含义.</li><li>左值代表存储器的一个单元.</li><li>这是一个物理概念,不仅仅是个地址(地址不过是个编号,是个数值而已),是个实实在在的东西.</li><li>右值代表数据,一个数值而已.</li></ul></li><li>参考博客:<a href="https://www.zhihu.com/question/382300648" target="_blank" rel="noopener">https://www.zhihu.com/question/382300648</a><ul><li>取地址符取到的是一个地址，没有实际存储在哪，所以是右值</li><li>如果是寄存器变量也没有地址，所以是右值</li></ul></li></ul></li></ul><blockquote><p>使用decltype时,左值返回引用类型，右值不返回引用类型。</p></blockquote><ul><li>对于自增自减（++i,i++）<ul><li>++i将对象本身作为左值返回</li><li>i++将对象原始值作为右值返回</li></ul></li></ul><h1 id="右值引用-c"><a href="#右值引用-c" class="headerlink" title="右值引用(c++)"></a>右值引用(c++)</h1><ul><li>定义 &amp;&amp;</li><li><p>右值引用只能引用到右值，不能引用到左值(const 例外)</p><blockquote><p>附加 <a href="https://www.zhihu.com/question/310966840" target="_blank" rel="noopener">为什么C++里const左值引用可以引用右值，这样做的考虑是什么？</a></p></blockquote></li><li><p>左值持久</p></li><li><p>右值短暂</p><ul><li>字面常量、临时对象</li><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul></li><li><p>引用右值的变量则是左值，不能再被右值引用</p></li></ul><pre><code class="lang-cpp">int &amp;&amp;rr1 = 42;//trueint &amp;&amp;rr2 = rr1;//error</code></pre><ul><li>move函数：获得绑定在左值上的右值引用<ul><li>调用move后，原变量除赋值和销毁外，不能再使用他</li></ul></li></ul><h2 id="右值引用作用"><a href="#右值引用作用" class="headerlink" title="右值引用作用"></a>右值引用作用</h2><ul><li>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul></li></ul><h1 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h1><p><a href="https://blog.csdn.net/zhangxiao93/article/details/74974546" target="_blank" rel="noopener">C++引用折叠</a></p><ul><li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li><li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 initializer_list初始化</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20initializer_list%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="含有可变（数量）形参的函数"><a href="#含有可变（数量）形参的函数" class="headerlink" title="含有可变（数量）形参的函数"></a>含有可变（数量）形参的函数</h1><ul><li><p><a href="https://blog.csdn.net/Clark_Sev/article/details/89500808?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">使用方法</a> </p></li><li><p>initializer_list 标准库类型</p><ul><li>成员永远是常量 </li><li>传递参数的时候用花括号括起来</li></ul></li><li><p>可变参模板</p><ul><li>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</li></ul></li></ul><p>initializer_list 使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;template &lt;class T&gt;struct S {    std::vector&lt;T&gt; v;    S(std::initializer_list&lt;T&gt; l) : v(l) {         std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list\n&quot;;    }    void append(std::initializer_list&lt;T&gt; l) {        v.insert(v.end(), l.begin(), l.end());    }    std::pair&lt;const T*, std::size_t&gt; c_arr() const {        return {&amp;v[0], v.size()};  // 在 return 语句中复制列表初始化                                   // 这不使用 std::initializer_list    }};template &lt;typename T&gt;void templated_fn(T) {}int main(){    S&lt;int&gt; s = {1, 2, 3, 4, 5}; // 复制初始化    s.append({6, 7, 8});      // 函数调用中的列表初始化    std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints:\n&quot;;    for (auto n : s.v)        std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    std::cout &lt;&lt; &quot;Range-for over brace-init-list: \n&quot;;    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    auto al = {10, 11, 12};   // auto 的特殊规则    std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#39;\n&#39;;//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，                             // 它无类型，故 T 无法推导    templated_fn&lt;std::initializer_list&lt;int&gt;&gt;({1, 2, 3}); // OK    templated_fn&lt;std::vector&lt;int&gt;&gt;({1, 2, 3});           // 也 OK}</code></pre><ul><li>省略符形参<ul><li>应该只用在c和c++通用的类型，不适用于大多数类类型</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 面向对象 -- 封装、继承、多态</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="https://gitee.com/huihut/interview/raw/master/images/面向对象基本特征.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>基类（父类）——&gt; 派生类（子类）<blockquote><p>继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p></blockquote></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><blockquote><p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p></blockquote><h3 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h3><p>函数重载</p><pre><code class="lang-cpp">class A{public:    void do(int a);    void do(int a, int b);};</code></pre><h3 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h3><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li></ul><p>动态多态使用</p><pre><code class="lang-cpp">class Shape                     // 形状类{public:    virtual double calcArea()    {        ...    }    virtual ~Shape();};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};class Rect : public Shape       // 矩形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    Shape * shape2 = new Rect(5.0, 6.0);    shape1-&gt;calcArea();         // 调用圆形类里面的方法    shape2-&gt;calcArea();         // 调用矩形类里面的方法    delete shape1;    shape1 = nullptr;    delete shape2;    shape2 = nullptr;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 成员初始化列表</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><p>形式</p><pre><code class="lang-cpp">class test{public:    test(int _a,int _b):a(_a),b(_b);private:    int a;    int b;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4面经</title>
      <link href="/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/04/17/Recruitment/UE4%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ai寻路怎么确保不跟其他ai撞等"><a href="#ai寻路怎么确保不跟其他ai撞等" class="headerlink" title="ai寻路怎么确保不跟其他ai撞等"></a>ai寻路怎么确保不跟其他ai撞等</h1><h1 id="抛物线模拟实现"><a href="#抛物线模拟实现" class="headerlink" title="抛物线模拟实现"></a>抛物线模拟实现</h1><h1 id="AI系统"><a href="#AI系统" class="headerlink" title="AI系统"></a>AI系统</h1><h2 id="UE4-NavMesh原理"><a href="#UE4-NavMesh原理" class="headerlink" title="UE4 NavMesh原理"></a>UE4 NavMesh原理</h2><ul><li><p>参考文章</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/74537236" target="_blank" rel="noopener">UE4 Navmesh寻路（一）Recast基础</a><br><a href="https://zhuanlan.zhihu.com/p/78873379" target="_blank" rel="noopener">UE4 Navmesh寻路（二）Detour寻路</a></p></blockquote></li><li><p>目前生成Navmesh数据主要有两种方式：多边形裁剪和体素化。</p><ul><li>多边形裁剪是直接对地形的多边形网格数据进行裁剪及合并，从而生成导航网格。方法比较直观，但难度更高，目前havok引擎使用了此方法。</li><li>体素化是对地形多边形网格进行栅格化，然后用这些“格子”重新生成导航网格，方法更复杂，但难度更低，Recast使用了此方案，而UE4使用了Recast。</li></ul></li></ul><h3 id="Recast"><a href="#Recast" class="headerlink" title="Recast"></a>Recast</h3><ul><li>Recast:将场景网格模型生成用于寻路的导航网格</li><li>Detour：利用导航网格进行寻路</li></ul><h1 id="UE4蓝图的意义"><a href="#UE4蓝图的意义" class="headerlink" title="UE4蓝图的意义"></a>UE4蓝图的意义</h1>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库整理</title>
      <link href="/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/17/Recruitment/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树-B-树-B-树-红黑树"><a href="#AVL树-B-树-B-树-红黑树" class="headerlink" title="AVL树/B-树/B+树/红黑树"></a>AVL树/B-树/B+树/红黑树</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul><li><p>1.结点是红色或黑色。</p></li><li><p>2.根结点是黑色。</p></li><li><p>3.每个叶子结点都是黑色的空结点（NIL结点）。</p></li><li><p>4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</p></li><li><p>5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="新结点（A）位于树根，没有父结点。"><a href="#新结点（A）位于树根，没有父结点。" class="headerlink" title="新结点（A）位于树根，没有父结点。"></a>新结点（A）位于树根，没有父结点。</h3></li><li>A直接变成黑色</li></ul><h3 id="新结点（B）的父结点是黑色。"><a href="#新结点（B）的父结点是黑色。" class="headerlink" title="新结点（B）的父结点是黑色。"></a>新结点（B）的父结点是黑色。</h3><ul><li>A不变</li></ul><h3 id="新结点（D）的父结点和叔叔结点都是红色。"><a href="#新结点（D）的父结点和叔叔结点都是红色。" class="headerlink" title="新结点（D）的父结点和叔叔结点都是红色。"></a>新结点（D）的父结点和叔叔结点都是红色。</h3><ul><li>爸爸叔叔变黑，爷爷变红，然后递归检查</li></ul><h3 id="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"><a href="#新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"></a>新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。</h3><h3 id="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"><a href="#新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"></a>新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。</h3><h3 id="4，5的镜像"><a href="#4，5的镜像" class="headerlink" title="4，5的镜像"></a>4，5的镜像</h3><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。"><a href="#如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。" class="headerlink" title="如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。"></a>如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。</h3><ul><li>类似二叉树，把右孩子的最大值放过来，并删除这个结点</li></ul><h3 id="根据待删除结点和其唯一子结点的颜色，分情况处理。"><a href="#根据待删除结点和其唯一子结点的颜色，分情况处理。" class="headerlink" title="根据待删除结点和其唯一子结点的颜色，分情况处理。"></a>根据待删除结点和其唯一子结点的颜色，分情况处理。</h3><ul><li>自身是红色，子结点是黑色：<ul><li>直接删</li></ul></li><li>自身是黑色，子结点是红色：<ul><li>直接删，子孩子变黑</li></ul></li><li>自身是黑色，子结点也是黑色<ul><li>子情况1，结点红黑树的根结点：<ul><li>直接删</li></ul></li><li>结点的父亲、兄弟、侄子结点都是黑色：<ul><li>把结点2的兄弟结点B改为红色，递归判断</li></ul></li><li>结点2的兄弟结点是红色：</li></ul></li></ul><h1 id="B-数"><a href="#B-数" class="headerlink" title="B-数"></a>B-数</h1><p><img src="b树b+树.png" alt></p><h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><ul><li><p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段</p></li><li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li></ul><h1 id="模式（schema）："><a href="#模式（schema）：" class="headerlink" title="模式（schema）："></a>模式（schema）：</h1><ul><li><p>模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p></li><li><p>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p></li><li><p>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</p></li></ul><h1 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h1><p>层次模型（hierarchical model）<br>网状模型（network model）<br>关系模型（relational model）</p><h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><ul><li><p>用于提升数据库的查找速度</p></li><li><p>顺序索引</p></li><li>B+ 树索引<blockquote><p>比哈希多个排序</p></blockquote></li><li>hash 索引</li></ul><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><ul><li><p>第一范式</p><blockquote><p>属性（字段）是最小单位不可再分</p></blockquote></li><li><p>第二范式</p><blockquote><p>满足 1NF，每个非主属性完全依赖于主键</p></blockquote></li><li><p>第三范式</p><blockquote><p>满足 2NF，任何非主属性不依赖于其他非主属性</p></blockquote></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li>是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li></ul><h2 id="事物的-ACID-特性"><a href="#事物的-ACID-特性" class="headerlink" title="事物的 ACID 特性"></a>事物的 ACID 特性</h2><ul><li><p>原子性、一致性、隔离性、持续性</p></li><li><p>事务是并发控制的基本单位。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 decltype</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20decltype/</url>
      
        <content type="html"><![CDATA[<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><ul><li>decltype 用于选择并返回操作数的数据类型</li></ul><blockquote><p>只推断类型，不计算表达式的值</p><p>decltype能返回包括顶层const和引用在内的类型</p></blockquote><pre><code class="lang-cpp">const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; // x is const intdecltype(cj) y = x; // y is const int&amp;,并初始化绑定xdecltype(cj) z;     // wrong 引用必须初始化</code></pre><ul><li>decltype与引用</li></ul><pre><code class="lang-cpp">int i = 42,*p=&amp;i,&amp;r=i;decltype(r)  //int&amp;decltype(r+0) //intdecltype(*p) //int&amp;</code></pre><ul><li>decltype((variable))的结果(即带括号的表达式)永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用的时候才是引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 enum</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20enum/</url>
      
        <content type="html"><![CDATA[<h1 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h1><pre><code class="lang-cpp">//限定作用域的枚举类型(c++11)enum class open_modes { input, output, append };//不限定作用域的枚举类型enum color { red, yellow, green };//不限定作用域的匿名枚举类型enum { floatPrec = 6, doublePrec = 10 };</code></pre><ul><li><p>匿名枚举类型用处</p><ul><li>在程序中需要<strong>数值的名字</strong>的时候使用<ul><li>宏定义的缺点:在预处理阶段只做简单替换不做安全检查</li><li>匿名的enum枚举:编译器会对其进行类型检查，若代码中其他地方有和该名字冲突的，会报错</li><li>静态变量: 作用域在本文件内,编译阶段检查，比匿名enum内存占用多<blockquote><p><a href="https://zhuanlan.zhihu.com/p/267401289" target="_blank" rel="noopener">c语言之枚举类型（enum）</a></p></blockquote></li></ul></li></ul></li><li><p>和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p></li><li>关键字是 enum class(等价enum struct)</li><li>限定作用域枚举类型，作用域外无法访问；不限定作用域的枚举类型，枚举成员的作用域和枚举类型本身的作用域一致</li></ul><pre><code class="lang-cpp">enum class /*struct*/ MyEnum { A = 0};        // 限定作用域的枚举enum class /*struct*/ MyEnum1 { A = 0 };    // 限定作用域的枚举可以有重复的名字，使用时也必须加上作用域enum MyEnum2 { B = 0 };                        // 不限定作用域的枚举enum MyEnum3 { B = 0 };                        // 不限定作用域的枚举不能有重复的名字enum {test = 0} t,t1;                        // 未命名的不限定作用域的枚举,只能在定义是就定义对象MyEnum::A;                                          //限定作用域的枚举要带上作用域B;                                                     //true</code></pre><ul><li><p>默认情况下，枚举值从0开始，依次加1，如果没有显示提供值，就在前一个枚举值的基础上加1。枚举成员是const的。</p></li><li><p>只要enum有名字，我们就能定义并初始化该类型的成员。想要初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。</p></li><li><p>一个不限定作用域的枚举类型的对象或枚举成员自动的转成整型</p></li><li><p>在C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。如果我们指定了潜在类型，则一旦超出范围将引发错误。对于限定作用域的枚举成员，其缺省为int类型</p></li><li><p>在C++11 新标准中，我们可以提前声明enum。enum的前置声明必须指定其成员的大小。</p><pre><code class="lang-cpp">enum test : long;    // 不限定作用域的，必须指定成员类型enum class test1;    // 限定作用域的枚举类型可以使用默认成员类型int</code></pre></li><li><p>int值不可以做以enmu为形参的函数的实参。对与不限定作用域的enum做形参时，enum的值提升成int或更大的整型（注意只会提升成对应整型，不会隐式转换为unsigned char之类），实际提升的结果由枚举类型的潜在类型决定。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 范围解析运算符</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><p>:: 使用</p><pre><code class="lang-cpp">int count = 11;         // 全局（::）的 countclass A {public:    static int count;   // 类 A 的 count（A::count）};int A::count = 21;void fun(){    int count = 31;     // 初始化局部的 count 为 31    count = 32;         // 设置局部的 count 的值为 32}int main() {    ::count = 12;       // 测试 1：设置全局的 count 的值为 12    A::count = 22;      // 测试 2：设置类 A 的 count 为 22    fun();                // 测试 3    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 friend友元</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20friend%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h1><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><pre><code class="lang-cpp">//声明方式class CLASS_NAME{    friend //函数声明    friend //类声明    public:        //...    private:        //...}</code></pre><h1 id="相同class的各个objects互为友元"><a href="#相同class的各个objects互为友元" class="headerlink" title="相同class的各个objects互为友元"></a>相同class的各个objects互为友元</h1><pre><code class="lang-cpp">class complex{public:    complex (double r = 0,double i = 0):re(r),ri(i){}    //相同class的各个objects互为友元    int func(const complex&amp; param){return param.re + param.ri;}private:    double re,im;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 using</title>
      <link href="/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/"/>
      <url>/2021/04/17/C++/C++%E5%A4%8D%E4%B9%A0%20using/</url>
      
        <content type="html"><![CDATA[<h1 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h1><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><pre><code class="lang-cpp">using namespace_name::name;</code></pre><h2 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><pre><code class="lang-cpp">class Derived : Base {public:    using Base::Base;    /* ... */};</code></pre><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><pre><code class="lang-cpp">Derived(parms) : Base(args) { }</code></pre><h2 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h2><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><pre><code class="lang-cpp">using namespace_name name;</code></pre><h2 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h2><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><p>using 使用</p><p>尽量少使用 <code>using 指示</code></p><pre><code class="lang-cpp">using namespace std;</code></pre><p>应该多使用 <code>using 声明</code></p><pre><code class="lang-cpp">int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl;</code></pre><p>或者</p><pre><code class="lang-cpp">using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl;</code></pre><h1 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using = (类型别名)"></a>using = (类型别名)</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using double = wages; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于复合类型的别名的声明语句要小心"><a href="#对于复合类型的别名的声明语句要小心" class="headerlink" title="对于复合类型的别名的声明语句要小心"></a>对于复合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 explicit关键字</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h1><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰类型转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li></ul><ul><li>转换构造函数</li></ul><blockquote><p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</p></blockquote><pre><code class="lang-cpp">Sales_data(std::string s) : Sales_data(s,0,0){} // 可以隐式(stirng -&gt; Sales_data)Sales_data(std::istream &amp;is) : Sales_data(){read(is,*this)} // 可以隐式（cin(istream) -&gt; Sales_data）</code></pre><h2 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h2><ul><li>对其他类型也只会允许一步类型转换</li></ul><pre><code class="lang-cpp">Sales_data::combine(&quot;99999&quot;); //error char* -&gt; string -&gt; Sales_data</code></pre><ul><li>可以显式隐式混用</li></ul><pre><code class="lang-cpp">Sales_data::combine(string(&quot;99999&quot;));Sales_data::combine(Sales_data(&quot;9999999&quot;));</code></pre><h2 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h2><ul><li><p>关键字 <font color="red">explicit</font></p></li><li><p>只能在类内的单个形参的构造函数前使用</p></li><li><p>并且explicit声明的构造函数只能用于直接初始化而不能用于拷贝初始化</p></li></ul><pre><code class="lang-cpp">Sales_data item1(null_book); //trueSales_data item2 = null_book; //error</code></pre><ul><li>explicit 使得构造函数不能用于隐式变换，但仍可以显式变换</li></ul><pre><code class="lang-cpp">item.combine(Sales_data(null_book));item.combine(Static_cast&lt;Sales_data&gt;(cin));</code></pre><h1 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h1><ul><li>形式</li></ul><pre><code class="lang-cpp">operator type() const;</code></pre><p>-</p><ul><li>type表示某种类型</li><li><p>可以面向除void以外的任意类型进行定义,并且要求能作为返回类型</p><ul><li>所以type不能是数组和函数，但可以是指向数组和函数的指针或绑定它们的引用</li><li>没有返回类型，没有形参，必须是成员函数</li></ul></li><li><p>显式的类型转换运算符(c++11新特性)</p><blockquote><p>即显示的类型转换运算符(c++11新特性)(explicit operator)</p><ul><li>通常与explicit一样</li><li>如果当表达式被用作条件，则编译其会将显式的类型转换自动应用于它。<ul><li>if、while、for 的控制表达式；</li><li>内建逻辑运算符 !、&amp;&amp; 和 || 的操作数；</li><li>条件运算符 ?: 的首个操作数；</li><li>static_assert 声明中的谓词；</li><li>noexcept 说明符中的表达式；</li><li>explicit 说明符中的表达式。(C++20 起)</li></ul></li></ul></blockquote></li></ul><ul><li>无论什么时候在条件中使用流对象，都会为IO类型定义operator bool的隐式转换</li></ul><h1 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h1><pre><code class="lang-cpp">struct A{    A(int) { }    operator bool() const { return true; }};struct B{    explicit B(int) {}    explicit operator bool() const { return true; }};void doA(A a) {}void doB(B b) {}int main(){    A a1(1);        // OK：直接初始化    A a2 = 1;        // OK：复制初始化    A a3{ 1 };        // OK：直接列表初始化    A a4 = { 1 };        // OK：复制列表初始化    A a5 = (A)1;        // OK：允许 static_cast 的显式转换     doA(1);            // OK：允许从 int 到 A 的隐式转换    if (a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a6(a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a7 = a1;        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换    bool a8 = static_cast&lt;bool&gt;(a1);  // OK ：static_cast 进行直接初始化    B b1(1);        // OK：直接初始化    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化    B b3{ 1 };        // OK：直接列表初始化    B b4 = { 1 };        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化    B b5 = (B)1;        // OK：允许 static_cast 的显式转换    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换    bool b8 = static_cast&lt;bool&gt;(b1);  // OK：static_cast 进行直接初始化    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习  c实现c++类</title>
      <link href="/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/"/>
      <url>/2021/04/16/C++/C++%E5%A4%8D%E4%B9%A0%20c%E5%AE%9E%E7%8E%B0c++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h1><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同(虚函数表见<a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a>)</li></ul><blockquote><p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经整理</title>
      <link href="/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/15/Recruitment/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/solthx/RBTtree" target="_blank" rel="noopener">RBTtree</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li><p>进程是资源调度、分配的独立单位</p></li><li><p>这个还是看面经好了</p></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</li></ul><h2 id="cpu调度算法-进程调度"><a href="#cpu调度算法-进程调度" class="headerlink" title="cpu调度算法(进程调度)"></a>cpu调度算法(进程调度)</h2><ul><li>先来先服务</li><li>最短作业</li><li>最短剩余时间</li><li>时间片轮转</li><li>优先级调度</li><li>多级反馈队列</li></ul><h2 id="线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？"><a href="#线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？" class="headerlink" title="线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？"></a>线程，进程，为什么进程切换消耗比较大，有多个协成是不是可以同步进行？</h2><h3 id="进程线程区别"><a href="#进程线程区别" class="headerlink" title="进程线程区别"></a>进程线程区别</h3><p>*Ⅰ 拥有资源</p><pre><code>- 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</code></pre><ul><li>Ⅱ 调度<ul><li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li></ul></li><li>Ⅲ 系统开销<ul><li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li></ul></li><li>Ⅳ 通信方面<ul><li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ul></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><p>协程 Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。</p></li><li><p>线程是被内核所调度，线程被调度切换到另一个线程上下文的时候，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作设计用户态到内核态转换，开销比较多。</p></li><li><p>协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销。</p></li></ul><h2 id="虚拟内存、物理内存"><a href="#虚拟内存、物理内存" class="headerlink" title="虚拟内存、物理内存"></a>虚拟内存、物理内存</h2><ul><li><p>物理内存（内存条）：当打开程序时，系统会将这些程序加载到物理内存上。</p></li><li><p>虚拟内存（硬盘）：虚拟的不是物理内存，而是代替物理内存行使存储的功能，物理内存的运行程序的功能是无法用虚拟内存来完成的。</p></li><li><p>物理内存与虚拟内存的关系：当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。</p></li></ul><h2 id="虚拟地址空间（用户空间、内核空间）"><a href="#虚拟地址空间（用户空间、内核空间）" class="headerlink" title="虚拟地址空间（用户空间、内核空间）"></a>虚拟地址空间（用户空间、内核空间）</h2><p><a href="https://blog.csdn.net/qq_41668705/article/details/107041614" target="_blank" rel="noopener">C / C++系列 （3）：heap vs. stack &amp; new vs. malloc</a></p><p><a href="https://blog.csdn.net/qq_41668705/article/details/107173143" target="_blank" rel="noopener">C / C++系列 （4）：malloc内存分配 &amp; linux虚拟地址空间布局</a></p><ul><li>虚拟地址空间（作用：解决物理内存稀缺问题）：系统为每个进程所分配的4GB虚拟地址空间（32位系统），用来存放进程的虚拟地址，再通过MMU（内存管理单元）将虚拟地址映射到物理内存地址。</li><li>虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。</li><li>内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)</li><li>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。</li></ul><p><img src="Linux下elf文件与虚拟地址空间的映射关系.png" alt="Linux下elf文件与虚拟地址空间的映射关系"></p><h3 id="变量内存的分配方式"><a href="#变量内存的分配方式" class="headerlink" title="变量内存的分配方式"></a>变量内存的分配方式</h3><ul><li>静态存储区<ul><li>全局变量 ，static变量 </li></ul></li><li>栈<ul><li>局部变量 </li></ul></li><li>堆（动态内存分配）<ul><li>程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。</li><li>malloc接触的内存空间是虚拟内存</li></ul></li></ul><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><h4 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h4><ul><li>局部变量存放的位置，函数调用会在占空间生成栈帧,由系统控制</li></ul><blockquote><p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p></blockquote><pre><code>- 为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。- 记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。- 临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</code></pre><blockquote><p>注意点：</p></blockquote><pre><code>- 持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再收缩。- Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。- 堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。- 堆栈的大小在运行时由内核动态调整。</code></pre><h4 id="共享库区域（内存映射段）"><a href="#共享库区域（内存映射段）" class="headerlink" title="共享库区域（内存映射段）"></a>共享库区域（内存映射段）</h4><ul><li>内核用于将硬盘文件的内容直接映射到内存,内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库</li></ul><h4 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h4><ul><li>动态分配的内存,由用户控制</li></ul><blockquote><p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</p><p>分配的堆内存是经过字节对齐的空间，以适合原子操作。</p><p>堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p><h4 id="可读可写段"><a href="#可读可写段" class="headerlink" title="可读可写段"></a>可读可写段</h4><h5 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h5><ul><li>未初始化或初值为0的全局变量和静态局部变量<h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5></li><li>已初始化且初值非0的全局变量和静态局部变量</li></ul></blockquote><hr><ul><li>BSS段和数据段的区别<ul><li>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间<ul><li>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</li></ul></li><li>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</li></ul></li></ul><h4 id="只读代码段"><a href="#只读代码段" class="headerlink" title="只读代码段"></a>只读代码段</h4><ul><li>可执行代码、字符串字面值、只读变量</li></ul><hr><ul><li>代码段也称正文段或文本段</li><li>通常用于存放程序执行代码(即CPU执行的机器指令)。</li><li>代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。</li></ul><h4 id="保留区"><a href="#保留区" class="headerlink" title="保留区"></a>保留区</h4><ul><li>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。</li></ul><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><ul><li>包括内核数据和内核栈等</li><li>用来存放操作系统内核代码和数据等<ul><li>内核代码和数据区在每个进程的地址空间中都相同</li><li>用户态不能访问内核区</li></ul></li></ul><h2 id="目标文件（elf）"><a href="#目标文件（elf）" class="headerlink" title="目标文件（elf）"></a>目标文件（elf）</h2>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 union联合体</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20union/</url>
      
        <content type="html"><![CDATA[<h1 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public（也可以有private和protected）</li><li>可以含有构造函数、析构函数(此处就是不加virtual的析构函数)</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><p>union 使用</p><pre><code class="lang-cpp">#include&lt;iostream&gt;union UnionTest {    UnionTest() : i(10) {};    int i;    double d;};static union {    int i;    double d;};int main() {    UnionTest u;    union {        int i;        double d;    };    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  // 输出 UnionTest 联合的 10    ::i = 20;    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  // 输出全局静态匿名联合的 20    i = 30;    std::cout &lt;&lt; i &lt;&lt; std::endl;    // 输出局部匿名联合的 30    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 struct和typedef struct</title>
      <link href="/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/"/>
      <url>/2021/04/12/C++/C++%E5%A4%8D%E4%B9%A0%20struct%E5%92%8Ctypedef%20struct/</url>
      
        <content type="html"><![CDATA[<h1 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h1><h2 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h2><pre><code class="lang-c">// ctypedef struct Student {    int age; } S;</code></pre><p>等价于</p><pre><code class="lang-c">// cstruct Student {     int age; };typedef struct Student S;</code></pre><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h2 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h2><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><pre><code class="lang-cpp">// cppstruct Student {     int age; };void f( Student me );       // 正确，&quot;struct&quot; 关键字可省略</code></pre><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><pre><code class="lang-cpp">typedef struct Student {     int age; } S;void Student() {}           // 正确，定义后 &quot;Student&quot; 只代表此函数//void S() {}               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名int main() {    Student();     struct Student me;      // 或者 &quot;S me&quot;;    return 0;}</code></pre><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><pre><code class="lang-cpp">typedef double wages; //wages是double的别名typedef wages base,*p;//base是double的别名,p是double*的别名</code></pre><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>c++11推荐用一下语法</li></ul><pre><code class="lang-cpp">using wages = double; //wages是double的别名//using 别名 = 类型</code></pre><h2 id="对于符合符合类型的别名的声明语句要小心"><a href="#对于符合符合类型的别名的声明语句要小心" class="headerlink" title="对于符合符合类型的别名的声明语句要小心"></a>对于符合符合类型的别名的声明语句要小心</h2><pre><code class="lang-cpp">typedef char *pstring;const pstring cstr = 0; // pstring是一个整体,是个指向char的指针。const修饰他。所以它本身是一个常量。所以它是常量指针(const pointer)const char *cstr; //而这里*修饰const char,所以它是指向char常量的指针,即指针常量(pointer to const)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 class和struct</title>
      <link href="/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/"/>
      <url>/2021/04/11/C++/C++%E5%A4%8D%E4%B9%A0%20class%E5%92%8Cstruct/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h1><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 extern C</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20extern%20C/</url>
      
        <content type="html"><![CDATA[<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><ul><li>extern “xxx”表示链接指示，用于c++调用其他语言编写的程序<blockquote><p>还要求c++编译器有权访问其他语言的编译器（包括c语言），并且兼容</p></blockquote></li></ul><blockquote><p>还可以链接其他语言的程序比如 extern “Ada”</p></blockquote><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><p>extern “C” 使用</p><pre><code class="lang-cpp">#ifdef __cplusplus//方式1extern &quot;C&quot; {#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus}#endif//方式2extern &quot;C&quot; size_t strlen(const char *);</code></pre><ul><li>当一个#include指示被放置在复合链接指示的花括号中，头文件中的所有普通函数声明都人未还是由链接指示的语言编写的。</li></ul><pre><code class="lang-cpp">extern &quot;C&quot; {    #include &lt;string.h&gt;}</code></pre><ul><li>链接指示可以嵌套</li></ul><h1 id="指向extern-“C”函数的指针"><a href="#指向extern-“C”函数的指针" class="headerlink" title="指向extern “C”函数的指针"></a>指向extern “C”函数的指针</h1><ul><li>使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示</li></ul><pre><code class="lang-cpp">//pf指向一个C函数，该函数接受一个int返回voidextern &quot;C&quot; void (*pf)(int);</code></pre><ul><li><font color="red">指向C函数的指针与指向C++函数的指针是不一样的类型</font>,不能用在初试化或赋值操作中</li></ul><pre><code class="lang-cpp">void (*pf1)(int); //指向c++函数void &quot;C&quot; void (*pf2)(int); //指向C函数pf1 = pf2;//error</code></pre><ul><li>链接指示对整个声明都有效<blockquote><p>链接指示不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效</p></blockquote></li></ul><pre><code class="lang-cpp">//f1是一个C函数，它的形参是一个指向C函数的指针extern &quot;C&quot; void fl(void(*)(int));</code></pre><ul><li>因为链接指示同时作用于声明语句中的所有函数，如果要给C++传入C函数指针，必须使用类型别名</li></ul><pre><code class="lang-cpp">//FC是一个指向C函数的指针extern &quot;C&quot; typedef void FC(int);//f2是一个C++函数，该函数的形参是指向C函数的指针void f2(FC *);</code></pre><ul><li>使用链接指示对函数进行定义，可以令C++函数在其他语言中调用<blockquote><p>但类型受到限制，比如c语言理解不了类</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; double calc(double dparm){    /*    ...    */}</code></pre><ul><li>链接指示对应的语言支持重置则<strong>可能</strong>可以重载<blockquote><p>c语言不支持重载，所以不能声明两个函数名相同的函数</p></blockquote></li></ul><pre><code class="lang-cpp">extern &quot;C&quot; void print(const char*);extern &quot;C&quot; void print(int);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 位域</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E4%BD%8D%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="不可移植性"><a href="#不可移植性" class="headerlink" title="不可移植性"></a>不可移植性</h1><ul><li><p>不可移植性：程序从一台机器转移到另一台机器时，通常需要重新编写该程序。</p><blockquote><p>比如算术类型的大小在不同机器上不一样</p></blockquote></li><li><p>相关概念</p><blockquote><p><a href>位域</a></p></blockquote></li></ul><blockquote><p><a href>Volatile</a></p><p><a href>链接指示:extern “C”</a></p></blockquote><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><pre><code class="lang-cpp">//位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，用于指定成员所占的二进制位数;Bit mode: 2;    // mode 占 2 位</code></pre><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，<font color="red">因为</font>带符号类型中的位域的行为将因具体实现而定</li><li><p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p></li><li><p>如果类内的连续定义的位域占用空间在同一个整数的相邻位，那么将会提供压缩，具体与机器相关</p></li><li><p>超过1位的位域通常使用内置的位运算符进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 数组 array vector</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E6%95%B0%E7%BB%84%20arrary%20vector/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-array-vector的区别"><a href="#数组-array-vector的区别" class="headerlink" title="数组 array vector的区别"></a>数组 array vector的区别</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/346838779" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/346838779</a></p></li><li><p>相同点：</p><ul><li>vector和array是容器；</li><li>三者均可以使用下表运算符对元素进行操作，即vector和array都针对下标运算符[]进行了重载；</li><li>三者在内存的方面都使用连续内存，即在vector和array的底层存储结构均使用数组 </li></ul></li></ul><ul><li>不同点：<ul><li>array 定义的时候必须定义数组的元素个数为常量表达式，而vector 可为变量表达式；</li><li>vector属于变长容器，即可以根据数据的插入删除重新构建容器容量；</li><li>但array和数组属于定长容量。vector和array在声明变量后，在生命周期完成后，会自动地释放其所占用的内存。对于数组，如果是采用new[]申请的内存空间，必须在使用delete[]完毕后手动释放其内存。</li><li>array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 pragma pack(n)</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20#pragma%20pack(n)/</url>
      
        <content type="html"><![CDATA[<h1 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h1><p>设定结构体、联合体以及类成员变量以 n 字节方式对齐</p><p><a href="https://blog.csdn.net/fuzhongmin05/article/details/59112081/" target="_blank" rel="noopener">C++成员函数在内存中的存储方式</a></p><ul><li>类成员函数和非成员函数代码存放在代码区</li></ul><h1 id="pragma-pack-n-使用"><a href="#pragma-pack-n-使用" class="headerlink" title="pragma pack(n) 使用"></a>pragma pack(n) 使用</h1><pre><code class="lang-cpp">#pragma pack(push)  // 保存对齐状态#pragma pack(4)     // 设定为 4 字节对齐struct test{    char m1;    double m4;    int m3;};#pragma pack(pop)   // 恢复对齐状态</code></pre><ul><li><p><a href="https://blog.csdn.net/aidem_brown/article/details/77540527" target="_blank" rel="noopener">补充</a></p><ul><li><h1 id="pragma-pack-n-作用：C编译器将按照n个字节对齐。"><a href="#pragma-pack-n-作用：C编译器将按照n个字节对齐。" class="headerlink" title="pragma pack (n)            作用：C编译器将按照n个字节对齐。"></a>pragma pack (n)            作用：C编译器将按照n个字节对齐。</h1></li><li><h1 id="pragma-pack-作用：取消自定义字节对齐方式。"><a href="#pragma-pack-作用：取消自定义字节对齐方式。" class="headerlink" title="pragma pack ()             作用：取消自定义字节对齐方式。"></a>pragma pack ()             作用：取消自定义字节对齐方式。</h1></li><li><h1 id="pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"><a href="#pragma-pack-push-1-作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐" class="headerlink" title="pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐"></a>pragma pack (push,1)       作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为1个字节对齐</h1></li><li><h1 id="pragma-pack-pop-作用：恢复对齐状态"><a href="#pragma-pack-pop-作用：恢复对齐状态" class="headerlink" title="pragma pack (pop)          作用：恢复对齐状态"></a>pragma pack (pop)          作用：恢复对齐状态</h1></li></ul></li><li><p>因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优，但是很多时候两者差别不大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 sizeof()</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20sizeof()/</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><ul><li>sizeof 运算符返回一条表达式或一个类型名字所占的字节数。<blockquote><p>满足右结合律<br>sizeof <em>p = sizeof(</em>p);</p></blockquote></li></ul><blockquote><p>返回值：size_t类型的常量表达式</p></blockquote><pre><code class="lang-cpp">//使用方法sizeof (type)sizeof expr //返回表达式结果类型的大小，不实际计算运算对象的值</code></pre><ul><li>不实际计算运算对象，即使对象是空指针也可以运行</li></ul><h2 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h2><ul><li>可以通过 作用域 符号来获取成员的大小</li></ul><pre><code class="lang-cpp">sizeof ClassName::ClassMember;//ClassName的ClassMember成员对应类型的大小</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对char或者类型为char的表达式，结果为1</li><li>对引用类型，结果为被引用对象所占空间的大小</li><li>对指针类型，结果为指针本身所占空间的大小</li><li>对解引用指针类型，结果为指向的对象所占空间的大小，指针不需要有效</li><li>对数组，结果为数组所占空间的大小，等价于数组中所有元素所占空间之和。sizeof不把数组转换为指针进行处理</li><li>对string和vector等，返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li></ul><h1 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h1><ul><li>这个宏会返回一个结构体成员相对于结构体开头的字节偏移量（<strong>经过结构对齐之后</strong>）<ul><li>type 结构体名称</li><li>结构体成员名称</li></ul></li><li>这个宏非常有用，由于结构体对齐的问题，整个结构体的大小并不是所有成员大小之和，往往要比他们的和大，（当然我们也可以执行结构体按一个字节进行对其），所以利用这个宏可以很好计算出每个结构体成员相对于结构体开头偏移的字节数。</li></ul><pre><code class="lang-cpp">#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;struct struct_test{    float fild1;    double fild2;    int fild3;    short fild4;    long long fild5;};int main(void){    printf(&quot;struct_test size is %lu \nfild1 offset %lu\nfild2 offset %lu \nfild3 offset %lu \nfild4 offset %lu \nfild5 offset %lu\n&quot;,                        sizeof(struct struct_test),                        offsetof(struct struct_test,fild1),                        offsetof(struct struct_test,fild2),                        offsetof(struct struct_test,fild3),                        offsetof(struct struct_test,fild4),                        offsetof(struct struct_test,fild5));    return 0;}/*struct_test size is 32 fild1 offset 0fild2 offset 8 fild3 offset 16 fild4 offset 20 fild5 offset 24*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 assert</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20assert/</url>
      
        <content type="html"><![CDATA[<h1 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h1><ul><li><p>由预处理器管理，可以直接使用</p></li><li><p>断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。</assert.h></cassert></assert.h></p></li></ul><blockquote><p>无需std或using声明</p></blockquote><h1 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h1><ul><li>NDEBUG可以决定assert是否启用。但是注意要定义在assert声明之前。具体看以下连接</li></ul><blockquote><p><a href="https://www.zhihu.com/question/23075111" target="_blank" rel="noopener">https://www.zhihu.com/question/23075111</a>  </p></blockquote><ul><li>一些局部静态变量，可以用于调试</li></ul><p><img src="局部静态变量.png" alt></p><pre><code class="lang-cpp">//assert() 使用#define NDEBUG          // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL );    // assert 不可用</code></pre><h1 id="UE4-断言"><a href="#UE4-断言" class="headerlink" title="UE4 断言"></a>UE4 <a href="https://docs.unrealengine.com/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assertions/index.html" target="_blank" rel="noopener">断言</a></h1><ul><li>源码位置<blockquote><p>Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h</p></blockquote></li></ul><h2 id="check族"><a href="#check族" class="headerlink" title="check族"></a>check族</h2><ul><li><p>Check族系最接近基础 assert，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。</p></li><li><p>检查宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 以保留一个true值（通常为 1），使Check宏可在所有版本中运行。</p><blockquote><p>此法在以下情况中十分实用：怀疑Check宏中的代码正在修改值；发现了仅存在于在发布版本中且难以追踪的bug，但认为现有Check宏能找到这些bug。项目发布时应将 USE_CHECKS_IN_SHIPPING 设为默认值 0。</p></blockquote></li></ul><h2 id="verify族"><a href="#verify族" class="headerlink" title="verify族"></a>verify族</h2><ul><li><p>在大部分版本中，Verify族系的行为与Check族系相同。但即便在禁用Check宏的版本中，Verify宏也会计算其表达式的值。这意味着仅当该表达式需要独立于诊断检查之外运行时，才应使用Verify宏。</p></li><li><p>验证宏在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中完整运行（以”Slow”结尾的宏除外，其仅在调试（Debug）版本中运行）。定义 USE_CHECKS_IN_SHIPPING 来保留一个true值（通常为 1），从而覆盖此行为。</p></li><li><p><strong>在所有其他情况下，Verify宏将计算其表达式，但不会停止执行或将文本输出到日志。</strong></p></li></ul><h2 id="ensure族"><a href="#ensure族" class="headerlink" title="ensure族"></a>ensure族</h2><ul><li><p>Ensure族系类似于Verify族系，但可在出现非致命错误时使用。若Ensure宏的表达式计算得出的值为false，引擎将通知崩溃报告器，但仍会继续运行。</p></li><li><p>为避免崩溃报告器收到太多通知，Ensure宏在每次引擎或编辑器会话中仅报告一次。若实际情况需要Ensure宏在每次表达式计算得值为false时都报告一次，则使用”Always”版本的宏。</p></li><li><p>Ensure宏在所有版本中计算其表达式的值，但仅在调试（Debug）、开发（Development）、测试（Test）和发布编辑器（Shipping Editor）版本中联系崩溃报告器。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 强制类型转换</title>
      <link href="/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/04/10/C++/C++%E5%A4%8D%E4%B9%A0%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h1><blockquote><p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p></blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>把空指针转换成目标类型的空指针。</li><li>把任何类型的表达式转换成void类型。</li><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安</li></ul></li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul><li>用于删除 const、volatile([ˈvɒlətaɪl]) 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h2 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h2><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><p>bad_cast 使用</p><pre><code class="lang-cpp">try {      Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape);   }  catch (bad_cast b) {      cout &lt;&lt; &quot;Caught: &quot; &lt;&lt; b.what();  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 volatile</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile-ˈvɑː-lə-t̬əl"><a href="#volatile-ˈvɑː-lə-t̬əl" class="headerlink" title="volatile[ /ˈvɑː.lə.t̬əl/]"></a>volatile[ /ˈvɑː.lə.t̬əl/]</h1><pre><code class="lang-cpp">volatile int i = 10;</code></pre><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p><blockquote><p>volatile跟const类似可以跟指针，引用等组合</p></blockquote></li></ul><blockquote><p>带有volatile的成员函数只能被volatile的对象调用。</p></blockquote><ul><li>合成的拷贝对volatile对象无效<blockquote><p>如果没有定义复制构造函数，编译器会自动合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数会对成员逐个进行初始化，将新对象初始化为原对象的副本。</p></blockquote></li></ul><blockquote><p>合成的成员接受的形参类型是常量（非 volatile）引用，以此不能把一个非volatile引用绑定到一个volatile，因此需要自定义。</p></blockquote><pre><code class="lang-cpp">class Foo{public:    //从一个volatile对象进行拷贝    Foo(const volatile Foo&amp;);    //将一个volatile对象赋值给一个*非*Volatile对象    Foo&amp; operator=(volatile const Foo&amp;);    //将一个volatile对象赋值给一个volatile对象    //这个没问题volatile表示这个函数只能被volatile对象调用，而这是个符号重载，所以左值一定是volatile类型    Foo&amp; operator=(volatile const Foo&amp;) volatile;    //Foo类的其他部分//}</code></pre><h1 id="注意与java等其他语言的volatile作区别"><a href="#注意与java等其他语言的volatile作区别" class="headerlink" title="注意与java等其他语言的volatile作区别"></a>注意与java等其他语言的volatile作区别</h1><ul><li>volatile 不能解决多线程中的问题。</li><li>按照 <a href="http://web.archive.org/web/20180120044239/http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" target="_blank" rel="noopener">Hans Boehm &amp; Nick Maclaren</a> 的总结，volatile 只在三种场合下是合适的。<ul><li>和信号处理（signal handler）相关的场合；</li><li>和内存映射硬件（memory mapped hardware）相关的场合；</li><li>和非本地跳转（setjmp 和 longjmp）相关的场合。</li></ul></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">谈谈 C/C++ 中的 volatile</a><blockquote><p>要注意C/C++的volatile无法解决多线程问题</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 inline内联函数</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20inline/</url>
      
        <content type="html"><![CDATA[<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>相当于把内联函数里面的内容写在调用内联函数处；//?</li><li>相当于不用执行进入函数的步骤，直接执行函数体；<blockquote><p>函数调用的时候，会在虚存中的栈区当前地址记录到帧指针寄存器，并生成该函数的上下文内容并执行相应的操作，调用结束后还会弹出该函数的数据，清理上下文信息。 </p></blockquote></li></ul><blockquote><p>感觉记得不准确，到时候重新看一下计算机系统中的函数调用过程</p><ul><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>inline 使用</p><pre><code class="lang-cpp">// 内联的声明可以不加inline// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) {/****/};// 类内定义，隐式内联class A {    int doA() { return 0; }         // 隐式内联}// 类外定义，需要显式内联class A {    int doA();}inline int A::doA() { return 0; }   // 需要显式内联</code></pre><h2 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h2><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h2><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>虚函数内联使用</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  using namespace std;class Base{public:    inline virtual void who()    {        cout &lt;&lt; &quot;I am Base\n&quot;;    }    virtual ~Base() {}};class Derived : public Base{public:    inline void who()  // 不写inline时隐式内联    {        cout &lt;&lt; &quot;I am Derived\n&quot;;    }};int main(){    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.who();    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr = new Derived();    ptr-&gt;who();    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr = nullptr;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 this指针</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h1><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针： //??<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复习 Static</title>
      <link href="/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/"/>
      <url>/2021/04/09/C++/C++%E5%A4%8D%E4%B9%A0%20Static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p></li></ul><blockquote><p>既可以是public也是private</p></blockquote><ul><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ul><blockquote><p>类的静态成员函数不包括this指针,所以静态成员函数不能设置为const</p><p><a href="https://blog.csdn.net/u010476094/article/details/38959265" target="_blank" rel="noopener">C++静态成员函数不能声明为const、volatile、virtual的原因 与 C++的对象模型</a></p></blockquote><ul><li>在类外定义静态成员，不用再重复声明static关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++整理</title>
      <link href="/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/"/>
      <url>/2021/03/01/Recruitment/C++%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="析构函数为什么最好是虚函数"><a href="#析构函数为什么最好是虚函数" class="headerlink" title="析构函数为什么最好是虚函数"></a><span id="destructor">析构函数为什么最好是虚函数</span></h2><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li></ul><p>虚析构函数使用</p><pre><code class="lang-cpp">class Shape{public:    Shape();                    // 构造函数不能是虚函数    virtual double calcArea();    virtual ~Shape();           // 虚析构函数};class Circle : public Shape     // 圆形类{public:    virtual double calcArea();    ...};int main(){    Shape * shape1 = new Circle(4.0);    shape1-&gt;calcArea();        delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。    shape1 = NULL;    return 0；}</code></pre><p><a href="https://www.zhihu.com/question/268022905/answer/1284256261" target="_blank" rel="noopener">为什么有了虚析构函数，就能先调用子类的析构函数？</a></p><h2 id="子类和父类执行构造函数和析构函数的顺序"><a href="#子类和父类执行构造函数和析构函数的顺序" class="headerlink" title="子类和父类执行构造函数和析构函数的顺序"></a>子类和父类执行构造函数和析构函数的顺序</h2><ul><li>构造函数：  父类的先执行，子类的后执行</li><li><p>析构函数： 父类的后执行，子类的先执行</p></li><li><p>附加</p><blockquote><p>默认构造函数（无参构造函数），有参构造函数，拷贝构造函数，级别依次递增。当我们提供了后面的，前面的编译器就不会提供了。</p></blockquote></li></ul><h2 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/103384358" target="_blank" rel="noopener">C++ 类在内存中的存储方式(一)</a></li></ul><h2 id="new-delete-与new-delete之间的差别，以及具体实现"><a href="#new-delete-与new-delete之间的差别，以及具体实现" class="headerlink" title="new[]/delete[]与new/delete之间的差别，以及具体实现"></a>new[]/delete[]与new/delete之间的差别，以及具体实现</h2><ul><li><a href="https://wetest.qq.com/lab/view/318.html" target="_blank" rel="noopener">c++ new delete 常踩的坑</a></li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul><li><p>引用必须被初始化，指针不必。</p></li><li><p>引用初始化以后不能被改变，指针可以改变所指的对象。</p></li><li><p>不存在指向空值的引用，但是存在指向空值的指针。</p></li></ul><h2 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h2><blockquote><p>不同的对象调用同一个函数，表现出不同的状态，称为多态。</p></blockquote><ul><li><p>一是增加程序的灵活性</p><blockquote><p>不同继承自父类的子类，对同一函数可以有不同的表现</p></blockquote></li><li><p>二是增加程序的可扩展性</p><blockquote><p>新增子类，只需修改需要重写的函数</p></blockquote></li></ul><h2 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new/delete和malloc/free的区别"></a>new/delete和malloc/free的区别</h2><ul><li><a href="https://blog.csdn.net/nyist_zxp/article/details/80810742" target="_blank" rel="noopener">C++ new和malloc的区别</a></li></ul><h2 id="define的底层实现"><a href="#define的底层实现" class="headerlink" title="#define的底层实现"></a>#define的底层实现</h2><ul><li><h1 id="define是一条预处理命令，它的作用就是定义宏。"><a href="#define是一条预处理命令，它的作用就是定义宏。" class="headerlink" title="define是一条预处理命令，它的作用就是定义宏。"></a>define是一条预处理命令，它的作用就是定义宏。</h1></li><li><p>宏并不是函数,宏并不是语句,宏并不是类型定义。</p></li><li><p>预处理时进行宏展开，把宏名替换成文本，这个文本可以是字符串，代码等。</p></li></ul><h2 id="const-int-p和int-const-p的区别"><a href="#const-int-p和int-const-p的区别" class="headerlink" title="const int p和int const p的区别"></a>const int <em>p和int</em> const p的区别</h2><ul><li><p>对于const和指针结合的变量，要从右往左看</p></li><li><p>int* const p 是常量指针，指的是p本身是个常量，p的值不能边，但p指向的内容可以改变，这是个顶层cosnt</p></li><li><p>const int *p 是指针常量，指的是指向常量的指针，p的值能改变，p指向的内容不能改变，这个个底层const</p></li></ul><h2 id="c-的编译过程"><a href="#c-的编译过程" class="headerlink" title="c++的编译过程"></a>c++的编译过程</h2><ul><li>预处理、编译、汇编、链接<blockquote><p><a href="https://www.cnblogs.com/ericling/articles/11736681.html" target="_blank" rel="noopener">C/C++完整编译过程详解</a></p></blockquote></li></ul><h2 id="python为什么效率低"><a href="#python为什么效率低" class="headerlink" title="python为什么效率低"></a>python为什么效率低</h2><ul><li>动态语言：运行时可以改变程序结构</li><li>解释运行：先转换为字节码再解释字节码</li><li>一切都是对象：需要维护引用计数<!-- * GIL：全局解释器锁 --></li><li>垃圾回收：自动垃圾回收中断当前程序</li></ul><h2 id="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"><a href="#定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector" class="headerlink" title="定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector"></a>定义了两个vector，vector里面存的是对象，是否可以直接使用memcpy去复制vector</h2><ul><li>不能 不是POD类型 ，memcpy只能进行浅拷贝 </li></ul><h2 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h2><ul><li><p>构造函数不能定义为虚函数，析构函数一般需要定义为虚函数</p><blockquote><p><a href="https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html" target="_blank" rel="noopener">构造函数为什么不能是虚函数</a></p></blockquote></li><li><p><a href="#destructor">析构函数为什么最好是虚函数</a></p></li></ul><h2 id="调试的时候打断点的原理"><a href="#调试的时候打断点的原理" class="headerlink" title="调试的时候打断点的原理"></a>调试的时候打断点的原理</h2><p><a href="https://zhuanlan.zhihu.com/p/34003929" target="_blank" rel="noopener">调试程序时，设置断点的原理是什么？</a></p><h2 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h2><ul><li><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></li></ul><h2 id="vector-list区别和相关内容"><a href="#vector-list区别和相关内容" class="headerlink" title="vector,list区别和相关内容"></a>vector,list区别和相关内容</h2><p><a href="https://zhuanlan.zhihu.com/p/270527588" target="_blank" rel="noopener">C++ vector和list的区别</a></p><h2 id="emplace-back和push-back有什么区别"><a href="#emplace-back和push-back有什么区别" class="headerlink" title="emplace_back和push_back有什么区别"></a>emplace_back和push_back有什么区别</h2><p><a href="https://zhuanlan.zhihu.com/p/183861524" target="_blank" rel="noopener">C++姿势点: push_back和emplace_back</a></p><h1 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h1><ul><li><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p></li><li><p>预处理</p><blockquote><p>预处理主要是处理各种宏展开；删除注释；保留编译器用到的编译器指令等。</p></blockquote></li></ul><blockquote><p>添加行号和文件标识符，为编译器产生调试信息提供便利；</p></blockquote><ul><li><p>编译</p><blockquote><p>编译是在预处理文件基础上经过一系列词法分析、语法分析及优化后生成汇编代码。</p></blockquote></li><li><p>汇编</p><blockquote><p>汇编是将汇编代码转化为机器可以执行的指令。</p></blockquote></li><li><p>链接</p><blockquote><p>将汇编生成的目标文件链接生成可执行文件</p></blockquote></li></ul><h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><ul><li><p>库:成熟的可复用代码</p></li><li><p>静态库(.a,.lib)动态库(.so,.dll)</p></li></ul><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><ul><li><p>在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p></li><li><p>特点：</p><blockquote><p>静态库对函数库的链接是放在<strong>编译时期</strong>完成的。</p></blockquote></li></ul><blockquote><p>程序在运行时与函数库再无瓜葛，移植方便。</p><p>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p></blockquote><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><ul><li><p>目的：为解决静态库浪费空间；对程序的更新、部署和发布会带来麻烦。</p></li><li><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p></li><li><p>特点：</p><blockquote><p>动态库把对一些库函数的链接载入推迟到程序运行的时期。</p></blockquote></li></ul><blockquote><p>可以实现进程之间的资源共享。（因此动态库也称为共享库）</p><p>将一些程序升级变得简单。</p><p>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。</p></blockquote><h1 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h1><p><a href="https://zhuanlan.zhihu.com/p/30007037" target="_blank" rel="noopener">C/C++内存对齐详解</a></p><h1 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h1><h2 id="静态存储区域"><a href="#静态存储区域" class="headerlink" title="静态存储区域"></a>静态存储区域</h2><ul><li>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2></li><li>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。效率很高，但是分配的内存容量有限。<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2></li><li>亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</li></ul><h1 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h1><ul><li><p>对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。过多的递归就会导致栈溢出</p></li><li><p>栈溢出的危害</p><blockquote><p>缓冲区溢出攻击，原因程序没有对作为缓冲区的数组进行越界检查</p></blockquote></li></ul><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><ul><li>重写是子类继承父类，可以对父类中声明为虚函数的函数进行重新定义，屏蔽父类的定义。</li><li>重载是指c++可以声明函数名相同，函数签名不同的函数，可以通过传入形参的不同来调用不同的函数</li></ul><h1 id="虚表指针是存在类里面还是对象里面"><a href="#虚表指针是存在类里面还是对象里面" class="headerlink" title="虚表指针是存在类里面还是对象里面"></a>虚表指针是存在类里面还是对象里面</h1><ul><li>对象</li></ul><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><ul><li>接口是一个概念。它在C++中用抽象类来实现</li><li><p>接口类应该是只提供方法声明，而自身不提供方法定义的抽象类。接口类自身不能实例化，接口类的方法定义/实现只能由接口类的子类来完成。</p></li><li><p>而对于C++，其接口类一般具有以下特征：</p><blockquote><p>最好不要有成员变量，但可以有静态常量（static const或enum）</p></blockquote></li></ul><blockquote><p>要有纯虚接口方法</p><p>要有虚析构函数，并提供默认实现</p><p>不要声明构造函数</p></blockquote><h1 id="参数为什么要从右往做压榨"><a href="#参数为什么要从右往做压榨" class="headerlink" title="参数为什么要从右往做压榨"></a>参数为什么要从右往做压榨</h1><ul><li><p>进一步发现，Pascal语言不支持可变长参数，而C语言支持这种特色，正是这个原因使得C语言函数参数入栈顺序为从右至左。具体原因为：C方式参数入栈顺序(从右至左)的好处就是可以动态变化参数个数。通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。</p></li><li><p>因此，C语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式。换句话说，如果不支持这个特色，C语言完全和Pascal一样，采用自左向右的参数入栈方式。</p></li></ul><h1 id="lambda表达式，引用捕获"><a href="#lambda表达式，引用捕获" class="headerlink" title="lambda表达式，引用捕获"></a>lambda表达式，引用捕获</h1><ul><li>lambda表达式表示一个可调用的代码单元，类似于一个匿名的内联函数</li></ul><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><ul><li>拷贝，要求变量可以被拷贝</li><li>与参数不同lambda的拷贝是在创建时拷贝，而不是在调用时拷贝<h2 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h2></li><li>类似普通引用</li></ul><h1 id="C-的GC机制"><a href="#C-的GC机制" class="headerlink" title="C++的GC机制"></a>C++的GC机制</h1><ul><li>csapp</li><li><a href="https://www.cnblogs.com/QG-whz/p/5079638.html" target="_blank" rel="noopener">C++垃圾回收机制</a></li><li>而C++ 0x则提供了基于引用计数算法的智能指针进行内存管理</li></ul><h1 id="array-vector，数组"><a href="#array-vector，数组" class="headerlink" title="array,vector，数组"></a>array,vector，数组</h1><p><a href="https://blog.csdn.net/alidada_blog/article/details/83029438?from=singlemessage" target="_blank" rel="noopener">array和vector，数组三者区别和联系</a></p><ul><li>共同点<ul><li>（1.）都和数组相似，都可以使用标准数组的表示方法来访问每个元素（array和vector都对下标运算符[ ]进行了重载）</li><li>（2.）三者的存储都是连续的，可以进行随机访问</li></ul></li><li>不同点<ul><li>（0.）数组是不安全的，array和vector是比较安全的（有效的避免越界等问题）</li><li>（1.）array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</li><li>（2.）array可以将一个对象赋值给另一个array对象，但是数组不行</li><li>（3.）vector属于变长的容器，即可以根据数据的插入和删除重新构造容器容量；但是array和数组属于定长容器</li><li>（4.）vector和array提供了更好的数据访问机制，即可以使用front()和back()以及at()（at()可以避免a[-1]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误</li><li>（5.）vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器</li><li>（6.）vector和array提供了size()和Empty()，而数组只能通过sizeof()/strlen()以及遍历计数来获取大小和是否为空</li><li>（7.）vector和array提供了两个容器对象的内容交换，即swap()的机制，而数组对于交换只能通过遍历的方式逐个交换元素</li><li>（8 .）array提供了初始化所有成员的方法fill（）</li><li>（9.）由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题</li><li>（10.）vector和array在声明变量后，在声明周期完成后，会自动地释放其所占用的内存。对于数组如果用new[ ]/malloc申请的空间，必须用对应的delete[ ]和free来释放内存</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Recruitment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recruitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/28/Menu/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer刷题笔记"><a href="#剑指Offer刷题笔记" class="headerlink" title="剑指Offer刷题笔记"></a>剑指Offer刷题笔记</h1><ul><li>2021年2月末，为准备研三的秋招，开始算法题的康复运动<blockquote><p>(“&hearts;” 表示刷的时候做出了最优解)</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>#</th><th>Title</th><th>Solution</th><th>Tag</th><th>Difficulty</th><th>最优时间复杂度&amp;&amp;空间复杂度</th><th>最优解</th></tr></thead><tbody><tr><td>剑指 Offer 03</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></td><td><a href="https://sanctorum003.github.io/2021/02/26/LeetCode/[%E5%89%91%E6%8C%87Offer]%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>数组 &amp;&amp; 哈希表</td><td>Easy</td><td>O(N) &amp;&amp; O(1)</td><td></td></tr><tr><td>剑指 Offer 09</td><td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></td><td><a href="https://sanctorum003.github.io/2021/02/28/LeetCode/[%E5%89%91%E6%8C%87Offer]%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">C++</a></td><td>栈 &amp;&amp; 设计</td><td>Hard</td><td></td><td></td></tr><tr><td>剑指 Offer 11</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></td><td><a href="https://sanctorum003.github.io/2021/03/01/LeetCode/[%E5%89%91%E6%8C%87Offer]%2011.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">C++</a></td><td>二分查找</td><td>Easy(Hard)</td><td>O(lgN) &amp;&amp; O(1)</td><td></td></tr><tr><td>303</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Easy</td><td>建立O(N) &amp; 调用O(1)</td><td></td></tr><tr><td>304</td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">二维区域和检索 - 矩阵不可变</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td>&hearts;</td></tr><tr><td>338</td><td><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特网计数</a></td><td><a href>c++</a></td><td>DP</td><td>Medium</td><td></td><td></td></tr><tr><td>300</td><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a></td><td><a href>c++</a></td><td>Medium</td><td>DP &amp;&amp; 二分</td><td>O(NlogN) &amp;&amp; O(N)</td><td></td></tr><tr><td>354</td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">俄罗斯套娃信封问题</a></td><td><a href>c++</a></td><td>Hard</td><td>DP &amp;&amp; 二分</td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> menu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 06.从尾到头打印链表</title>
      <link href="/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/28/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2006.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><h1 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h1><ul><li>正序输出 + 翻转数组</li></ul><h1 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h1><ul><li>正序输入栈 + 从栈输入Vector</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><pre><code class="lang-cpp">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head) {        if(!head) return {};        vector&lt;int&gt; t = reversePrint(head-&gt;next);        t.push_back(head-&gt;val);        return t;    }};</code></pre><ul><li>时间复杂度:O(N)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LinkList </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 07.重建二叉树</title>
      <link href="/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/27/LeetCode/%5B%E5%89%91%E6%8C%87Offer%5D%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></li></ul><h1 id="分治（不带index辅助）"><a href="#分治（不带index辅助）" class="headerlink" title="分治（不带index辅助）"></a>分治（不带index辅助）</h1><ul><li><p>这个自己写的，空间复杂度较高</p><pre><code class="lang-cpp">/*** Definition for a binary tree node.* struct TreeNode {*     int val;*     TreeNode *left;*     TreeNode *right;*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}* };*/class Solution {public:  TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {      if(preorder.empty() || inorder.empty()) return NULL;      //1. find root                              3      //2. split into left &amp; right                9 | 3 | 15 20 7      //3. 分治      int rootVal = preorder[0];      TreeNode* root = new TreeNode(rootVal);      vector&lt;int&gt;::iterator inorderRootPos;      inorderRootPos = find(inorder.begin(),inorder.end(),rootVal);      vector&lt;int&gt; inorderLeft(inorder.begin(),inorderRootPos);//注意范围      vector&lt;int&gt; inorderRight(inorderRootPos+1,inorder.end());      // //  inorder  L ROOT R      // //  preorder Root L R      int leftElemtNum = inorderRootPos-inorder.begin();      vector&lt;int&gt; preorderLeft(preorder.begin()+1,preorder.begin()+leftElemtNum+1);      vector&lt;int&gt; preorderRight(preorder.begin()+leftElemtNum+1,preorder.end());      TreeNode* LeftChild = buildTree(preorderLeft,inorderLeft);      TreeNode* RightChild = buildTree(preorderRight,inorderRight);      root-&gt;left = LeftChild;      root-&gt;right = RightChild;      return root;  }};</code></pre></li><li>时间复杂度:O(N)</li><li>空间复杂度:O(N+h)=O(N) [h为构造的树的高度,这里还有多次的创建数组的空间]</li></ul><h1 id="分治（利用index优化空间复杂度）"><a href="#分治（利用index优化空间复杂度）" class="headerlink" title="分治（利用index优化空间复杂度）"></a>分治（利用index优化空间复杂度）</h1><ul><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> Tree </tag>
            
            <tag> Divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集总结</title>
      <link href="/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/04/LeetCode/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h1><pre><code class="lang-cpp">const int N=30005;int fa[N],s[N],h[N];void Init(int n){    for(int i=1;i&lt;=n;++i)        fa[i]=i,ran[i]=0;    //刚开始每个人都是自己的老大，每个人都没有手下}int Find(int x){    return x==fa[x]?x:fa[x]=Find(fa[x]);}void Merge(int x,int y){    int fx=Find(x);    int fy=Find(y);    if(fx==fy)  return;    if(ran[fx]&lt;ran[fy])        fa[fx]=fy;    else    {        fa[fy]=fx;        if(ran[fx]==ran[fy])            ran[fx]++;    }}</code></pre><ul><li>模板引用来源:<a href="https://www.cnblogs.com/StungYep/p/12254027.html" target="_blank" rel="noopener">https://www.cnblogs.com/StungYep/p/12254027.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 200.无重复字符的最长子串</title>
      <link href="/2021/01/16/LeetCode/%5BLC%5D%20200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>/2021/01/16/LeetCode/%5BLC%5D%20200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>基础DFS题</li></ul><pre><code class="lang-cpp">class Solution {public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i ,int j)    {        if(i&lt;0 || i &gt;= grid.size() || j&lt;0 || j &gt;= grid[0].size()  || grid[i][j]==&#39;0&#39;) return;        //通过将&#39;1&#39;改为&#39;0&#39;来说明该位置已经被遍历过        grid[i][j] = &#39;0&#39;;        dfs(grid,i-1,j);        dfs(grid,i+1,j);        dfs(grid,i,j-1);        dfs(grid,i,j+1);    }    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int m = grid.size();        int n = grid[0].size();        int res = 0;        for(int i = 0; i &lt; m; ++i)        {            for(int j = 0; j &lt; n; ++j)            {                if(grid[i][j] == &#39;1&#39;)                {                       dfs(grid,i,j);                    res++;                }            }        }        return res;    }};</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(MN)$</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>基础BFS题</li></ul><pre><code class="lang-cpp">class Solution {public:    bool isIsland(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i ,int j)    {        if(i&lt;0 || i &gt;= grid.size() || j &lt; 0 || j&gt;= grid[0].size() || grid[i][j] == &#39;0&#39; ) return false;        grid[i][j] = &#39;0&#39;;        return true;    }    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int res = 0;        int m = grid.size();        int n = grid[0].size();        queue&lt;pair&lt;int,int&gt;&gt; q;        for(int i = 0; i &lt;m;++i)        {            for(int j = 0; j &lt; n;++j)            {                if(grid[i][j] == &#39;1&#39; )                {                    q.push(make_pair(i,j));                    res++;                }                while(!q.empty())                {                    pair&lt;int,int&gt; p = q.front();                    q.pop();                    int x = p.first;                    int y = p.second;                    if(isIsland(grid,x+1,y)) q.push(make_pair(x+1,y));                    if(isIsland(grid,x-1,y)) q.push(make_pair(x-1,y));                    if(isIsland(grid,x,y+1)) q.push(make_pair(x,y+1));                    if(isIsland(grid,x,y-1)) q.push(make_pair(x,y-1));                }            }        }        return res++;    }};</code></pre><ul><li>时间复杂度:$O(MN)$</li><li>空间复杂度:$O(???)$<blockquote><p>这个的空间复杂度有歧义，leetcode官方的答案写的是O(min(M,N)),我认为是O(max(m,n))</p></blockquote></li></ul><blockquote><p>x x x [1]<br>x x [1] 1<br>[1] [1] 1 1<br>x为已经遍历的位置,[1]为在队列里的位置</p></blockquote><p>但是看了这个<a href="https://stackoverflow.com/questions/50901203/dfs-and-bfs-time-and-space-complexities-of-number-of-islands-on-leetcode/50912382#50912382" target="_blank" rel="noopener">帖子</a>，时间复杂度应该是O(MN)</p><blockquote><p>PS:基本没人问这个问题，也没什么人提，一堆人刷题从来不管空间复杂度，时间复杂度的。。。。</p></blockquote><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul><li><p>简单的并查集学习</p><ul><li><a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93647900</a></li></ul></li><li><p>看了这篇文章做的这个题，感觉写的太复杂了，将并查集扩展到了2维</p><pre><code class="lang-cpp">class Solution {public:  void Init(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt;&amp; rank,int m,int n)  {      for(int i = 0; i &lt; m ;++i)      {          for(int j = 0; j &lt; n; ++j)          {              v[i][j] = make_pair(i,j);              rank[i][j] = 1;          }      }  }  pair&lt;int,int&gt; Find(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,pair&lt;int,int&gt; x)  {      int a = x.first;      int b = x.second;      return x == v[a][b] ? x : (v[a][b] = Find(v,v[a][b]));  }  void Merge(vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt;&amp; rank,pair&lt;int,int&gt; i,pair&lt;int,int&gt; j)  {      pair&lt;int,int&gt; x = Find(v,i), y = Find(v,j);      int a = x.first;      int b = x.second;      int c = y.first;      int d = y.second;      if (rank[a][b] &lt;= rank[c][d])          v[a][b] = y;      else          v[c][d] = x;      if (rank[a][b] == rank[c][d] &amp;&amp; x != y)          rank[c][d]++;  }  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {      int m = grid.size();      int n = grid[0].size();      vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; v(m,vector&lt;pair&lt;int,int&gt;&gt;(n,make_pair&lt;int,int&gt;(0,0)));      vector&lt;vector&lt;int&gt;&gt; rank(m,vector&lt;int&gt;(n,0));      Init(v,rank,m,n);      for(int i = 0;i &lt;m;++i)      {          for(int j = 0; j &lt; n; ++j)          {              if(grid[i][j] == &#39;1&#39;)              {                  if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == &#39;1&#39;)   Merge(v,rank,make_pair(i-1,j),make_pair(i,j));                  if(i+1&lt;m &amp;&amp; grid[i+1][j] == &#39;1&#39;)    Merge(v,rank,make_pair(i+1,j),make_pair(i,j));                  if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == &#39;1&#39;)   Merge(v,rank,make_pair(i,j-1),make_pair(i,j));                  if(j+1&lt;n &amp;&amp; grid[i][j+1] == &#39;1&#39;)    Merge(v,rank,make_pair(i,j+1),make_pair(i,j));              }          }      }      set&lt;pair&lt;int,int&gt;&gt; s;      for(int i = 0; i &lt; m; ++i)      {          for(int j = 0; j &lt; n;++j)          {              if(grid[i][j] == &#39;1&#39;)                  s.insert(Find(v,make_pair(i,j)));          }      }      return s.size();  }};</code></pre></li></ul><ul><li>时间复杂度：T T <blockquote><p>不太懂，证明可以看算法导论，我这里直接拉一下leetcode上的说明</p></blockquote></li></ul><blockquote><p>时间复杂度：$O(MN * \alpha(MN))$，其中 M 和 N 分别为行数和列数。注意当使用路径压缩（见 find 函数）和按秩合并（见数组 rank）实现并查集时，单次操作的时间复杂度为 $\alpha(MN)$，其中 $\alpha(x)$ 为反阿克曼函数，当自变量 x 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 $\alpha(x)$的值不会超过 5，因此也可以看成是常数时间复杂度。</p><ul><li>空间复杂度：$O(MN)$</li></ul></blockquote><ul><li>写法简化版本<br>```cpp</li></ul><p>```</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5.最长回文子串</title>
      <link href="/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/13/LeetCode/%5BLC%5D%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的关键点：初始条件和状态转换方程。<br>设：s[l][r]表示字符串中下标L到R的位置<br>则有如下转态转换方程<br>    s[l][r] = s[l+1][r-1] &amp;&amp; (s[l] == s[r])<br>那初始状态呢<br>    s[l][l] = ture<br>    s[l][l+1] = (s[l] == s[l+1])</p><pre><code class="lang-cpp">class Solution {public:    string longestPalindrome(string s) {        vector&lt;vector&lt;bool&gt;&gt; v(s.size(),vector&lt;bool&gt;(s.size(),false));        string res;        for(int i = 0; i &lt; v.size();++i)        {            for(int j = i; j &lt; v.size();++j)            {                if(i == j)                    v[i][j] = true;                else if(j-i == 1)                    v[i][j] = s[i] == s[j] ? true : false;            }        }        //这里需要注意一点的是从后往前遍历，因为v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);会优先用到数组尾部的数据        for(int i = v.size()-1; i &gt;= 0;--i)        {            for(int j = i; j &lt; v.size();++j)            {                if(j-i &gt; 1)                    v[i][j] = v[i+1][j-1] &amp;&amp; (s[i] == s[j]);                if(v[i][j] == true &amp;&amp; j-i+1 &gt; res.size())                    res = s.substr(i,j-i+1);              }        }        return res;    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3.无重复字符的最长子串</title>
      <link href="/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/12/LeetCode/%5BLC%5D%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_longest-substring-without-repeating-characters.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>子串和子序列的区别<ul><li>子串是是连续的</li><li>子序列可以不是连续的<ul><li>比如”pwwkew”中,”pwke”是最长子序列,”wke”是最长子串</li></ul></li></ul></li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>通过两个指针$i$,$j$，维护一个区间，保证这个区间的子串中无重复元素。</li><li>每次迭代的时候$j$向后移动，判断当前j指针的元素在上一次迭代的区间中是否存在。<ul><li>不存在，$i$不动</li><li>存在，$i = find_pos(nums[j]) + 1$</li></ul></li><li>每次迭代时更新最长无重复的子串长度。</li></ul><p>对于在元素中查询方式有以下三种方法。</p><h3 id="朴素循环"><a href="#朴素循环" class="headerlink" title="朴素循环"></a>朴素循环</h3><ul><li><p>在判断是否有重复元素时遍历一遍区间内的元素</p><pre><code class="lang-cpp">class Solution {public:  int lengthOfLongestSubstring(string s) {      if(s.size() == 0)  return 0;      int i = 0;      int j = 0;      int res = 0;      do      {          for(int k =  i; k &lt;j ; ++k)          {              if(s[k] == s[j])              {                  i = k+1;                  break;              }          }          res = max(res,j-i+1);           ++j;      }while(i &lt; s.size() &amp;&amp; j &lt; s.size());      return res;  }};</code></pre></li><li>时间复杂度:$O(n^{2})$</li><li>空间复杂度:$O(1)$</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="eg.png" alt></p><ul><li>这里需要注意判断元素所对应的下标是否还在当前滑动窗口范围内</li></ul><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        unordered_map&lt;char,int&gt; m;        int i =0;        int j = 0;        int res = 0;        do        {            if( m.find(s[j])!= m.end() &amp;&amp; m[s[j]] &gt;= i ) //这里主要要求找到的值要大于等于i            {                i = m[s[j]]+1;                m[s[j]] = j;            }            else             {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:unordered_map:O(n)</li><li>空间复杂度:O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="lang-cpp">class Solution {public:    int lengthOfLongestSubstring(string s) {        if(s.size() == 0) return 0;        int m[128]; //利用ascii来存储下标        fill(m,m+128,-1);        int i =0;        int j = 0;        int res = 0;        do        {            if(m[s[j]] &gt;= i)  //这里主要要求找到的值要大于等于i            {                              i = m[s[j]] + 1;                m[s[j]] = j;            }            else            {                m[s[j]] = j;            }            res = max(res,j-i+1);            ++j;        }while(i &lt; s.size() &amp;&amp; j &lt; s.size());        return res;    }};</code></pre><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> HashMap </tag>
            
            <tag> DoublePointer </tag>
            
            <tag> String </tag>
            
            <tag> SlidingWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/07/11/LeetCode/%5BLC%5D%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="Q_two-sum.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>注意点<ul><li>数组无序</li><li>返回<strong>下标</strong></li></ul></li></ul><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><ul><li><p>二重循环</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; v;      for(int i = 0; i &lt; nums.size();++i)          for(int j = i+1; j &lt; nums.size();++j)              if(nums[i] + nums[j] == target)              {                  v.push_back(i);                  v.push_back(j);              }      return v;  }};</code></pre></li><li><p>时间复杂度:O($n^{2}$)</p></li><li>空间复杂度 O(1)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>排序($nlog(n)$)之后使用双指针($O(n)$)找出所求的值</li><li>所求的是原数组中的下标，所以排序前复制一份。之后利用找到的值来找到下标</li><li><p>需要注意从原数组找下标时，下标大小和数值重复的问题。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      vector&lt;int&gt; tmp = nums;      sort(tmp.begin(),tmp.end());      int i = 0;      int j = tmp.size()-1;      while(i &lt; j)      {          if(tmp[i] + tmp[j] &gt; target) --j;          else if(tmp[i] + tmp[j] &lt; target) ++i;          else break;      }      bool bi = false;      bool bj = false;      for(int k = 0; k &lt; nums.size();++k)      {          if(!bi &amp;&amp; nums[k] == tmp[i] )          {              i=k;              bi = true;              continue;          }          if(!bj &amp;&amp; nums[k] == tmp[j])          {              j = k;              bj = true;              continue;          }      }      if(i &gt; j)          swap(i,j);      return {i,j};  }};</code></pre></li><li><p>时间复杂度: $O(nlog(n) + n + n) = O(nlog(n))$</p></li><li>空间复杂度: $O(n)$</li></ul><h2 id="两遍哈希"><a href="#两遍哈希" class="headerlink" title="两遍哈希"></a>两遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。<ul><li>这里会注意到一点，可能数组中的值会重复，导致一个值关联多个下标，而实际代码中的结果会使得最后一个重复值关联相应下标。</li><li>但是这并不会影响结果。如此考虑，因为<strong>结果唯一</strong>，所以结果要取重复值，则数组中该结果对应的重复值有且仅有2个，不然不满足结果唯一。</li><li>所以在查找的时候，用的是原数组进行迭代，所以重复的第一个值要找的就是重复的后一个值，所以上述正好满足我们的要求</li></ul></li><li><p>利用原数组进行查找 target - nums[i] 是否在map中,map::find为O(log(n))，其基于红黑树。unordered_map::find()为O(1),其基于哈希表</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)          m[nums[i]] = i;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)              return {i,m[target-nums[i]]};      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(n)</li></ul><h2 id="一遍哈希"><a href="#一遍哈希" class="headerlink" title="一遍哈希"></a>一遍哈希</h2><ul><li>利用map或unordered_map将数组中的值和下标关联在一起。</li><li><p>在这里直接循环原数组，查找map中否有target - nums[i]。没有的话加入map中。</p><pre><code class="lang-cpp">class Solution {public:  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {      unordered_map&lt;int,int&gt; m;      for(int i =0; i &lt; nums.size();++i)      {          if(m.find(target-nums[i]) != m.end())          {              return {m[target-nums[i]],i};          }          else          {              m[nums[i]] = i;          }      }      return {};  }};</code></pre></li><li>时间复杂度:map:$O(nlog(n))$、unordered_map:$O(n)$</li><li>空间复杂度:o(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Marching</title>
      <link href="/2020/01/10/CG/Render/Render-RayMarching/"/>
      <url>/2020/01/10/CG/Render/Render-RayMarching/</url>
      
        <content type="html"><![CDATA[<p><img src="raytrace.png" alt="from &quot;Ray tracing&quot; on Wikipedia"></p><ul><li>Ray Marching和Ray Tracing有一些相似之处。看上图，可以看出来他们都说从摄像机的位置开始,遍历屏幕上的所有像素，通过从摄像机穿过像素的射线来计算出该点像素的颜色。</li><li>对于Ray Marching来说，通过使用SDF函数来判断是否碰撞到物体。SDF函数就是signed distance function，比如说对于球体。  </li></ul><script type="math/tex; mode=display">SDF(P)=||\vec{p}-\vec{c}||-r \left\{\begin{aligned}< & 0, 在球体内部 \\= & 0, 在球体边上 \\> & 0, 在球体外部\end{aligned}\right.</script><ul><li>上述就是一个球体的SDF函数,而求得的SDF函数的值就是点P到球体的最短距离。</li></ul><script type="math/tex; mode=display">p = eye + depth * raydirection</script><ul><li>对于测试点P的depth来说,增加SPF(p)的大小肯定是不会发生碰撞的。然后考虑到如果该射线最终能撞到物体,那么depth肯定是一个固定值,而如果不撞到其他物体的话,那么depth = + $\infty$。所以需要设置p的最小值(初试值),最大值(超过这个值认为没有hit),depth的最小值(小于这个值认为ray marching结束),ray marching步长(超过这个值认为ray marching结束)</li></ul><p><img src="spheretrace.jpg" alt="From GPU Gems 2: Chapter 8."></p><ul><li>可以拿上图举例,从点P0开始,计算场景中所有SDF的值,并取最小值,那么depth加上这个值肯定不会发生碰撞。</li></ul><script type="math/tex; mode=display">SDF(p) = min(SDF_{1}(p),SDF_{2}(p),...)</script><pre><code class="lang-cpp">//Shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){    float tp1 = CircleSDF(vec3(0,0,0),1.f,tp);    float tp2 = CircleSDF(vec3(1,1,0),1.f,tp);    return min(tp1,tp2);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    //因为屏幕的原点在中心,而fragCoord的原点在左上角，进行变换    dir.xy = fragCoord - size/2.f;    //通过fov来设置视野范围       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    //注意一定要标准化    return normalize(dir);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &lt; MAX_DIS - E)    {        fragColor = vec4(1,0.75,0.79,1.f);        return;    }      fragColor = vec4(0.f,0.f,0.f,1.f); }</code></pre><h1 id="表面法线"><a href="#表面法线" class="headerlink" title="表面法线"></a>表面法线</h1><ul><li>梯度的值 == 法线的值</li></ul><script type="math/tex; mode=display">∇f=( \frac{​∂f}{​∂x},\frac{​∂f}{​∂y},\frac{​∂f}{​∂z})</script><ul><li>上面的式子可以用下面的式子来近似<blockquote><p>But no need to break out the calculus chops here. Instead of taking the real derivative of the function, we’ll do an approximation by sampling points around the point on the surface, much like how you learned to calculate slope in a function as over rise-over-run before you learned how to do derivatives.</p></blockquote></li></ul><script type="math/tex; mode=display">\vec{n} = \left[ \begin{matrix}​f(x+ε,y,z)−f(x−ε,y,z) \\​f(x,y+ε,z)−f(x,y−ε,z) \\​f(x,y,z+ε)−f(x,y,z−ε) \\\end{matrix} \right]​​</script><pre><code class="lang-cpp">//shadertoy// co:circle origin// tp:test pointfloat CircleSDF(vec3 co,float radius,vec3 tp){    return length(co-tp)-radius;}float SceneSDF(vec3 tp){     return CircleSDF(vec3(0,0,0),1.f,tp);}float Scene(vec3 eye,vec3 dir, int MAX_STRIDE,float E,float MIN_DIS,float MAX_DIS){    float depth = MIN_DIS;    for(int i = 0; i &lt; MAX_STRIDE;++i)    {        float inc = SceneSDF(eye+depth*dir);        if(inc &lt; E)            return depth;        depth += inc;        if(depth &gt; MAX_DIS)            return MAX_DIS;    }       return depth;}vec3 GetRayDirection(float fov,vec2 size, vec2 fragCoord){    vec3 dir;    dir.xy = fragCoord - size/2.f;       dir.z = - ((size.y/2.f)/tan(radians(fov)/2.f));    return normalize(dir);}vec3 estimateNormal(vec3 p,float EPSILON) {    return normalize(vec3(        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))    ));}vec3 GetColor(vec3 p){    return estimateNormal(p,0.01f);}void mainImage( out vec4 fragColor, in vec2 fragCoord ){        const float MAX_DIS = 100.f;    const float MIN_DIS = 0.f;    const float E = 0.1f;    const int MAX_STRIDE = 255;    vec3 eye = vec3(0.f,0.f,5.f);    vec3 dir = GetRayDirection(45.f,iResolution.xy,fragCoord.xy);    float depth = Scene(eye,dir,MAX_STRIDE,E,MIN_DIS,MAX_DIS);    if(depth &gt; MAX_DIS - E)    {        fragColor = vec4(0.f,0.f,0.f,1.f);        return;    }    fragColor = vec4(GetColor(eye + depth * dir),1.f);}</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/" target="_blank" rel="noopener">http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a><br><a href="https://zhuanlan.zhihu.com/p/36759481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36759481</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-CoordinateSystems</title>
      <link href="/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/"/>
      <url>/2020/01/04/CG/Opengl/LearnOpengl-CoordinateSystems/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Transformations</title>
      <link href="/2019/12/04/CG/Opengl/LearnOpengl-Transformations/"/>
      <url>/2019/12/04/CG/Opengl/LearnOpengl-Transformations/</url>
      
        <content type="html"><![CDATA[<ul><li>单位向量 $\hat{n}$</li></ul><h1 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h1><ul><li>它允许我们在3D向量上进行位移</li><li>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ul><li>用于避免万向结死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Textures</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Textures/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Textures/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h1><ul><li><p>纹理坐标中,左下角位(0,0),右上角位(1,1)<br><img src="tex_coords.png" alt></p></li><li><p>使用纹理坐标获取纹理颜色叫做<strong>采样(Sampling)</strong></p></li></ul><h1 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h1><ul><li>原文讲的够好了<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a></li></ul><h1 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h1><ul><li><p>产生原因:纹理坐标可以取任意浮点值，所以纹理元素与纹理坐标无法一一对应</p></li><li><p>纹理元素(Texel)</p></li></ul><blockquote><p>而纹素是纹理图片空间的基本单元，可以看成是纹理的组成“像素”</p></blockquote><ul><li>纹理过滤（Texture Filtering)</li></ul><blockquote><p>一个像素一般不会正好对应于一个纹元（texel)。所以像素的颜色无法直接得到，需要经过一定的运算，这个过程就是纹理过滤。<br>参考网址：<a href="https://zhuanlan.zhihu.com/p/91208143" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91208143</a></p></blockquote><ul><li>有两种常见的纹理过滤的方式:GL_NEAREST和GL_LINEAR</li></ul><blockquote><p>邻近过滤:选择中心点最接近纹理坐标的那个像素<br>线性过滤:基于纹理坐标附近的纹理像素，计算出一个插值。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。<br>具体项目可见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/</a>  </p></blockquote><ul><li>如何设置过滤方式</li></ul><pre><code class="lang-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><blockquote><p>GL_TEXTURE_MAG_FILTTER:纹理元素的数量 &lt; 图元像素的数量。比如texture为256*256，图元为512*512。相当于纹理元素被放大，一个纹理元素的颜色决定多个图元像素的颜色</p><p>GL_TEXTURE_MIN_FILTER 纹理元素的数量 &gt; 图元像素的数量。比如texture为512*512,图元为256*256。相当于纹理被缩小，一个图元像素的颜色由多个纹理像素决定。</p></blockquote><h1 id="多级渐远纹理-Mipmap"><a href="#多级渐远纹理-Mipmap" class="headerlink" title="多级渐远纹理(Mipmap)"></a>多级渐远纹理(Mipmap)</h1><ul><li><p>产生原因:我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段(像素)，OpenGL从高分辨率纹理中为这些片段（像素）获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段（像素）只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p></li><li><p>多级渐远纹理：简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一</p></li><li><p>距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 </p></li><li><p>Mipmap的例子如下<br><img src="mipmaps.png" alt></p></li><li><p>可以在GL_TEXTURE_MIN_FILTER中使用多级渐远纹理过滤选项，但是在GL_TEXTURE_MAG_FILTER中无法使用，纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p></li></ul><h1 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><pre><code class="lang-cpp">int width, height, nrChannels;//地址、宽度、高度、颜色通道的个数、期望通道数（得到的data中的数据的通道数目）unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</code></pre><h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><pre><code class="lang-cpp">unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    //用于生成2D纹理    // 参数一：设置纹理目标，一般为GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D    // 参数二：Mipmap级别,手动设置每个的话这里设0    // 参数三：纹理存储格式    // 参数四：宽度    // 参数五：长度    // 0    // 参数六：image的的存储格式    // 参数七：图像数据    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    //为当前绑定的纹理自动生成所有需要的多级渐远纹理。    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}//释放图像的内存stbi_image_free(data);</code></pre><h1 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h1><ul><li>在定点数组中添加纹理坐标</li><li>在VS中声明纹理坐标属性</li><li>利用glVertexAttribPointer给定点数组中的纹理坐标解释，并启用该定点属性</li><li>在PS中获取VS中的纹理坐标，声明sampler2D变量</li><li>glActiveTexture激活对应的纹理单元</li><li>利用texture(ourTexture, TexCoord)使用之前设置的纹理参数对相应的颜色值进行采样</li></ul><h1 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h1><ul><li>uniform sampler2D MySampler存放纹理的位置称为纹理单元。</li><li>opengl有GL_TEXTURE0 - GL_TEXTURE15总共16个纹理单元。</li><li>使用方式如下</li></ul><pre><code class="lang-cpp">// 设置着色器采样器使用哪个纹理单元ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置</code></pre><pre><code class="lang-cpp">//激活纹理单元glActiveTexture(GL_TEXTURE0);//绑定时会自动使用当前激活的纹理单元 glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);</code></pre><ul><li>纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</li></ul><h1 id="图片翻转问题"><a href="#图片翻转问题" class="headerlink" title="图片翻转问题"></a>图片翻转问题</h1><ul><li>纹理可能上下颠倒，这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。</li></ul><pre><code class="lang-cpp">//解决方法stbi_set_flip_vertically_on_load(true);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl-Shaders</title>
      <link href="/2019/11/21/CG/Opengl/LearnOpengl-Shaders/"/>
      <url>/2019/11/21/CG/Opengl/LearnOpengl-Shaders/</url>
      
        <content type="html"><![CDATA[<ul><li><p>很多都是概念性的东西，教程里整理的很好<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_1</a></p></li><li><p>layout (location = 0)</p><blockquote><p>为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。</p></blockquote></li><li><p>如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）</p></li></ul><h1 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h1><ul><li>uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</li><li>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4Live_RenderProcess</title>
      <link href="/2019/10/08/CG/UE4/UE4Live-RenderProcess/"/>
      <url>/2019/10/08/CG/UE4/UE4Live-RenderProcess/</url>
      
        <content type="html"><![CDATA[<p>视频地址 <a href="https://www.bilibili.com/video/av35615021?t=3626" target="_blank" rel="noopener">https://www.bilibili.com/video/av35615021?t=3626</a><br>相关图片 <a href="https://blog.csdn.net/jli_family/article/details/86584208" target="_blank" rel="noopener">https://blog.csdn.net/jli_family/article/details/86584208</a></p><p><img src="UE4Live_RenderProcess.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloTriangle</title>
      <link href="/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/"/>
      <url>/2019/10/08/CG/Opengl/LearnOpengl-HelloTriangle/</url>
      
        <content type="html"><![CDATA[<ul><li><p>通过opengl绘制图形，需要通过opengl的渲染管线，这一过程实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p></li><li><p>对于利用opengl画出一个三角形，归纳为以下步骤</p></li></ul><h1 id="build-and-compile-our-shader-program"><a href="#build-and-compile-our-shader-program" class="headerlink" title="build and compile our shader program"></a>build and compile our shader program</h1><p><img src="Opengl_ShaderCreate.png" alt></p><ul><li>在OpenGL的渲染管线中，我们必须要配置VS和FS(PS)两个着色器,可以选择配置GS。</li></ul><pre><code class="lang-cpp">//创建着色器的方式/***  * 创建一个指定类型的着色器，返回指向这个着色器的在显存地址的引用***/int MyShader = glCreateShader(TYPE_OF_SHADER);</code></pre><ul><li>着色器程序运行的着色器语言，在opengl中使用的是GLSL。所以我们需要编写GLSL,并且将其绑定到我们创建的着色器上</li></ul><pre><code class="lang-cpp">/***  * MyShaderSource中写入待绑定的GLSL程序***/const char *MyShaderSource = &quot;#version 330 core\n&quot;    &quot;out vec4 FragColor;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;    &quot;}\n\0&quot;;/***  * 将GLSL程序与Shader进行绑定  * Shader显存地址/程序数量/字符串(数组)/字符串数组长度***/glShaderSource(MyShader, 1, &amp;MyShaderSource, NULL);</code></pre><ul><li>进行着色器编译并显示Debug信息</li></ul><pre><code class="lang-cpp">glCompileShader(vertexShader);// check for shader compile errorsint success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success){    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}</code></pre><ul><li>到这里我们的着色器就编译好了，接下来我们需要将编译好的着色器链接成一个着色器对象。这个着色器对象就是我们将数据渲染到屏幕所使用的的渲染管线。</li></ul><pre><code class="lang-cpp">unsigned int shaderProgram;shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) {    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGTRAM::LINK_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}/***  * 在之后可以调用glUseProgram(shaderProgram)来使用这个我们已经链接好的着色器程序对象。***///别忘了垃圾回收，这两个这时候已经没用了glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h1 id="set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes"><a href="#set-up-vertex-data-and-buffer-s-and-configure-vertex-attributes" class="headerlink" title="set up vertex data (and buffer(s)) and configure vertex attributes"></a>set up vertex data (and buffer(s)) and configure vertex attributes</h1><ul><li>我们要画图形的话，需要几样的东西，首先是需要在内存中准备顶点，然后传输到显存中。</li></ul><h2 id="VBO-vertex-buffer-objects-顶点缓冲对象"><a href="#VBO-vertex-buffer-objects-顶点缓冲对象" class="headerlink" title="VBO(vertex buffer objects):顶点缓冲对象"></a>VBO(vertex buffer objects):顶点缓冲对象</h2><pre><code class="lang-cpp">unsigned int VBO;//这里用&amp;，是因为直接改变VBO指向内存单元的数据，执行完后VBO保存一个显存地址glGenBuffers(1, &amp;VBO);//这一步将显存地址与GL_ARRAY_BUFFER绑定，这样之后所有对GL_ARRAY_BUFFER，其实就是在操作VBO所指的显存区域。glBindBuffer(GL_ARRAY_BUFFER, VBO);//这一步是用于将内存中的数据传输到显存中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><ul><li>上述代码用于创建一个叫做VBO缓冲对象的东西，这个用于存储将来从内存传输过来的定点数据。</li></ul><h2 id="解释显存中的缓存数据"><a href="#解释显存中的缓存数据" class="headerlink" title="解释显存中的缓存数据"></a>解释显存中的缓存数据</h2><ul><li>在显存中的数据，我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。</li></ul><pre><code class="lang-cpp">//该函数用于让OpenGL知道该如何解析顶点数据//第一个参数表示该数据希望传输到VS的哪一个参数。比如//  layout (location = 0) in vec3 aPos;//  layout (location = 1) in vec3 bPos;//第一个参数设为0则该数据传入aPos,1则传入bPos//第二个参数表示该定点属性的大小，这里是3//第三个参数表示大小为3，每个部分的类型为float//第四个参数表示是否要标准化设备坐标(Normalized Device Coordinates, NDC)//第五个参数表示每个顶点属性的总大小,对于紧密排列的数据可以用0代替//第六感参数表示位置数据在缓冲中起始位置的偏移量(Offset)，比如sizeof(float)，则偏移一个float值，3*sizeof(float)，则偏移一个定点glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</code></pre><ul><li>接下来我们应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</li></ul><pre><code class="lang-cpp">glEnableVertexAttribArray(0);</code></pre><h2 id="VAO-Vertex-Array-Objec-顶点数组对象"><a href="#VAO-Vertex-Array-Objec-顶点数组对象" class="headerlink" title="VAO(Vertex Array Objec):顶点数组对象"></a>VAO(Vertex Array Objec):顶点数组对象</h2><ul><li>一个顶点数组对象会储存以下这些内容：<blockquote><p>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</p></blockquote></li></ul><blockquote><p>通过glVertexAttribPointer设置的顶点属性配置。</p><p>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</p></blockquote><ul><li>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</li><li>也就是说我们对VBO的所有配置都会保存在我们所绑定的VAO中，如果之后想要使用这一配置，只需要重新绑定它就行了。</li></ul><pre><code class="lang-cpp">//VAO绑定unsigned int VAO;glGenVertexArrays(1, &amp;VAO);glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO解绑glBindVertexArray(VAO);</code></pre><pre><code class="lang-cpp">//VAO使用glBindVertexArray(VAO);</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code class="lang-cpp">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..// 1. bind Vertex Array ObjectglBindVertexArray(VAO);// 2. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. then set our vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);  //glBindVertexArray(0);...// ..:: Drawing code (in render loop) ::..// 4. draw the objectglUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();</code></pre><h1 id="render-loop"><a href="#render-loop" class="headerlink" title="render loop"></a>render loop</h1><ul><li>如何使用我们所自定义的着色器和配置好的定点属性呢?</li></ul><pre><code class="lang-cpp">// draw our first triangleglUseProgram(shaderProgram);glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organizedglDrawArrays(GL_TRIANGLES, 0, 3);// glBindVertexArray(0); // no need to unbind it every time</code></pre><ul><li>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象</li><li>在glBindVertexArray函数调用之后，会使用VAO中所保存的顶点数据配置</li><li>glDrawArray函数用于绘制图元，第一个函数是图元类型，第二个参数指定了顶点数组的起始索引，第三是顶点个数。绘制glVertexAttribPointer绑定后的第几个位置开始的几个定点。注意这里是定点的偏移，比如这里上下文中大小为 3*sizeof(float)</li><li>需要区分在glVertexAttribPointer中的offset和这里的索引</li></ul><h1 id="EBO-Element-Buffer-Object-引缓冲对象"><a href="#EBO-Element-Buffer-Object-引缓冲对象" class="headerlink" title="EBO(Element Buffer Object):引缓冲对象"></a>EBO(Element Buffer Object):引缓冲对象</h1><ul><li>用于指定定点的绘制顺序</li></ul><pre><code class="lang-cpp">unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</code></pre><pre><code class="lang-cpp">//这里改用这glDrawElements来画三角形glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><ul><li>注意VAO也会保存EBO的数组配置信息，glDrawElements会使用我们绑定的EBO中的索引顺序,所以要注意解绑VAO的顺序</li></ul><h1 id="绘制最终流程"><a href="#绘制最终流程" class="headerlink" title="绘制最终流程"></a>绘制最终流程</h1><pre><code class="lang-cpp">// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染编程 - 资源操作</title>
      <link href="/2019/10/07/CG/UE4/UE4Render-ResourceOperation/"/>
      <url>/2019/10/07/CG/UE4/UE4Render-ResourceOperation/</url>
      
        <content type="html"><![CDATA[<h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><ul><li>Compute Shader<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/compute-shader-stage--cs-</a><br><a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Compute_Shader</a></li></ul><h1 id="UAV"><a href="#UAV" class="headerlink" title="UAV"></a>UAV</h1><ul><li>Unordered Access view<br><a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/shader-resource-view--srv-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在shader文件中添加第二个颜色变量</title>
      <link href="/2019/10/06/CG/UE4/UE4Render-addParams/"/>
      <url>/2019/10/06/CG/UE4/UE4Render-addParams/</url>
      
        <content type="html"><![CDATA[<h1 id="在shader文件中添加第二个颜色变量"><a href="#在shader文件中添加第二个颜色变量" class="headerlink" title="在shader文件中添加第二个颜色变量"></a>在shader文件中添加第二个颜色变量</h1><p><a href="https://zhuanlan.zhihu.com/p/36635394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36635394</a><br><a href="https://zhuanlan.zhihu.com/p/36695496" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36695496</a><br>在看了shader编程的第二第三章后,觉的似懂非懂。再上面添加点东西,便于很深入的理解</p><h2 id="MyShader-usf"><a href="#MyShader-usf" class="headerlink" title="MyShader.usf"></a>MyShader.usf</h2><ul><li>我们从目标要求开始,这里我想要使得输出颜色变为两个颜色的和，比如可以让颜色变成R+G,R+B等等</li><li>这里我们现在usf文件中做如下添加和修改</li></ul><pre><code class="lang-cpp">// MyShader.usf#include &quot;/Engine/Public/Platform.ush&quot;float4 SimpleColor;// 增加一个颜色采样的变量float4 SimpleColor2;void MainVS( in float4 InPosition : ATTRIBUTE0, out float4 OutPosition : SV_POSITION ){ // screenspace position from vb    OutPosition = InPosition;}void MainPS(    out float4 OutColor : SV_Target0    ){    // 输出颜色变为两种颜色的叠加    OutColor = (SimpleColor + SimpleColor2);}</code></pre><h2 id="MyShaderTest-h"><a href="#MyShaderTest-h" class="headerlink" title="MyShaderTest.h"></a>MyShaderTest.h</h2><ul><li>因为添加了一个颜色变量，我们得将相关数据传进去。首先想到的是在蓝图中增加一个引脚</li></ul><pre><code class="lang-cpp">// MyShaderTest.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;UObject/ObjectMacros.h&quot;#include &quot;Classes/Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;MyShaderTest.generated.h&quot;UCLASS(MinimalAPI, meta = (ScriptName = &quot;TestShaderLibrary&quot;))class UTestShaderBlueprintLibrary : public UBlueprintFunctionLibrary{    GENERATED_UCLASS_BODY()        UFUNCTION(BlueprintCallable, Category = &quot;ShaderTestPlugin&quot;, meta = (WorldContext = &quot;WorldContextObject&quot;))        // 在这里增加一个FLinearColor的形参就是增加一个引脚        static void DrawTestShaderRenderTarget(class UTextureRenderTarget2D* OutputRenderTarget, AActor* AC, FLinearColor MyColor,FLinearColor MyColor2);};</code></pre><h2 id="MyShaderTest-cpp"><a href="#MyShaderTest-cpp" class="headerlink" title="MyShaderTest.cpp"></a>MyShaderTest.cpp</h2><h3 id="DrawTestShaderRenderTarget"><a href="#DrawTestShaderRenderTarget" class="headerlink" title="DrawTestShaderRenderTarget"></a>DrawTestShaderRenderTarget</h3><ul><li>为此我们需要进入cpp文件中,添加相应的形参。这个函数是在逻辑线程中调用。</li><li>ENQUEUE_RENDER_COMMAND向渲染线程压入一个渲染命令， 调用DrawTestShaderRenderTarget_RenderThread</li><li>我们需要在lambda表达式中增加我们需要传的变量给渲染线程。<blockquote><p>DrawTestShaderRenderTarget中主要是对数据的获取和传递,一般不需要修改东西，只需要增加你要传递的各类数据。</p></blockquote></li></ul><pre><code class="lang-cpp">// MyShaderTest.cppvoid UTestShaderBlueprintLibrary::DrawTestShaderRenderTarget(    UTextureRenderTarget2D* OutputRenderTarget,    AActor* Ac,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInGameThread());    if (!OutputRenderTarget)    {        return;    }    FTextureRenderTargetResource* TextureRenderTargetResource = OutputRenderTarget-&gt;GameThread_GetRenderTargetResource();    UWorld* World = Ac-&gt;GetWorld();    ERHIFeatureLevel::Type FeatureLevel = World-&gt;Scene-&gt;GetFeatureLevel();    FName TextureRenderTargetName = OutputRenderTarget-&gt;GetFName();    ENQUEUE_RENDER_COMMAND(CaptureCommand)(        [TextureRenderTargetResource, FeatureLevel, MyColor,MyColor2, TextureRenderTargetName](FRHICommandListImmediate&amp; RHICmdList)    {        DrawTestShaderRenderTarget_RenderThread(RHICmdList, TextureRenderTargetResource, FeatureLevel, TextureRenderTargetName, MyColor,MyColor2);    }    );}</code></pre><h3 id="FMyShaderTest"><a href="#FMyShaderTest" class="headerlink" title="FMyShaderTest"></a>FMyShaderTest</h3><ul><li>因为给DrawTestShaderRenderTarget_RenderThread添加了一个数据，所以需要修改其函数，但是这个比较复杂我们先看简单的。</li><li>渲染管线中VS和PS是一定要自己配置的,所以创建自定义的VS和PS,需要从FGlobalShader继承。然后需要使用</li></ul><pre><code class="lang-cpp">IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><p>这个语句来使相关类和Vertex Shader或Pixel Shader文件绑定，这样渲染管线中将会使用我们自定义的定点着色器和像素着色器</p><ul><li>因为在VS和PS中有些配置是一样的,所以我们可以先从FGlobalShader派生一个FMyShaderTest的类,然后再从FMyShaderTest派生出我们的FShaderTestVS和FShaderTestPS。</li></ul><pre><code class="lang-cpp">// MyShaderTest.cppclass FMyShaderTest : public FGlobalShader{public:    FMyShaderTest() {}    FMyShaderTest(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FGlobalShader(Initializer)    {        SimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));        SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));    }    static bool ShouldCache(EShaderPlatform Platform)    {        return true;    }    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters)    {        //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);          return true;    }    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment)    {        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);        OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);    }    void SetParameters(        FRHICommandListImmediate&amp; RHICmdList,        const FLinearColor &amp;MyColor,        const FLinearColor &amp;MyColor2    )    {        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);        SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);    }    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }private:    FShaderParameter SimpleColorVal;    FShaderParameter SimpleColorVal2;};</code></pre><p>其中</p><pre><code class="lang-cpp">// MyShaderTest.cppSimpleColorVal.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor&quot;));SimpleColorVal2.Bind(Initializer.ParameterMap, TEXT(&quot;SimpleColor2&quot;));// MyShader.usffloat4 SimpleColor;float4 SimpleColor2;</code></pre><ul><li>这是将FMyShaderTest中的私有变量与MyShader.usf中变量进行绑定。</li><li><p>但是我们注意到我们还没有将颜色输入到FMyShaderTest中的私有变量。因此我们需要写一个函数用于把我们的颜色信息传到shader里。。</p><pre><code class="lang-cpp">// MyShaderTest.cppvoid SetParameters(  FRHICommandListImmediate&amp; RHICmdList,  const FLinearColor &amp;MyColor,  const FLinearColor &amp;MyColor2){  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal, MyColor);  SetShaderValue(RHICmdList, GetPixelShader(), SimpleColorVal2, MyColor2);}</code></pre></li><li><p>因为这些参数在PS中使用到，所以此处使用GetPixelShader()参数</p></li></ul><pre><code class="lang-cpp">    virtual bool Serialize(FArchive&amp; Ar) override    {        bool bShaderHasOutdatedParameters = FGlobalShader::Serialize(Ar);        Ar &lt;&lt; SimpleColorVal;        Ar &lt;&lt; SimpleColorVal2;        return bShaderHasOutdatedParameters;    }</code></pre><ul><li>虚幻序列化，用于读取磁盘上的渲染数据，这里需要将我们所需要的SimpleColorVal，SimpleColorVal2;</li></ul><pre><code class="lang-cpp">static bool ShouldCache(EShaderPlatform Platform){    return true;}static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters){    //return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM4);      return true;}static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment){    FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);    OutEnvironment.SetDefine(TEXT(&quot;TEST_MICRO&quot;), 1);}</code></pre><ul><li>剩下这些可以暂时不用管。<h3 id="VS-和-PS"><a href="#VS-和-PS" class="headerlink" title="VS 和 PS"></a>VS 和 PS</h3></li></ul><pre><code class="lang-cpp">class FShaderTestVS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestVS, Global);public:    FShaderTestVS() {}    FShaderTestVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};class FShaderTestPS : public FMyShaderTest{    DECLARE_SHADER_TYPE(FShaderTestPS, Global);public:    FShaderTestPS() {}    FShaderTestPS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer)        : FMyShaderTest(Initializer)    {    }};IMPLEMENT_SHADER_TYPE(, FShaderTestVS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainVS&quot;), SF_Vertex)IMPLEMENT_SHADER_TYPE(, FShaderTestPS, TEXT(&quot;/Plugin/ShadertestPlugin/Private/MyShader.usf&quot;), TEXT(&quot;MainPS&quot;), SF_Pixel)</code></pre><ul><li>这里从FMyShaderTest派生两个类分别利用IMPLEMENT_SHADER_TYPE宏指定为VS和PS</li></ul><pre><code class="lang-cpp">DECLARE_SHADER_TYPE(FShaderTestVS, Global);</code></pre><ul><li>该宏用于把该Shader加入全局shadermap中，在运行前会将shadermap中的所以shader进行编译。</li></ul><h3 id="DrawTestShaderRenderTarget-RenderThread"><a href="#DrawTestShaderRenderTarget-RenderThread" class="headerlink" title="DrawTestShaderRenderTarget_RenderThread"></a>DrawTestShaderRenderTarget_RenderThread</h3><pre><code class="lang-cpp">static void DrawTestShaderRenderTarget_RenderThread(    FRHICommandListImmediate&amp; RHICmdList,    FTextureRenderTargetResource* OutputRenderTargetResource,    ERHIFeatureLevel::Type FeatureLevel,    FName TextureRenderTargetName,    FLinearColor MyColor,    FLinearColor MyColor2){    check(IsInRenderingThread());#if WANTS_DRAW_MESH_EVENTS      FString EventName;    TextureRenderTargetName.ToString(EventName);    SCOPED_DRAW_EVENTF(RHICmdList, SceneCapture, TEXT(&quot;ShaderTest %s&quot;), *EventName);#else      SCOPED_DRAW_EVENT(RHICmdList, DrawUVDisplacementToRenderTarget_RenderThread);#endif      //设置渲染目标      SetRenderTarget(        RHICmdList,        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        FTextureRHIRef(),        ESimpleRenderTargetMode::EUninitializedColorAndDepth,        FExclusiveDepthStencil::DepthNop_StencilNop    );    //设置视口      //FIntPoint DrawTargetResolution(OutputRenderTargetResource-&gt;GetSizeX(), OutputRenderTargetResource-&gt;GetSizeY());      //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      TShaderMap&lt;FGlobalShaderType&gt;* GlobalShaderMap = GetGlobalShaderMap(FeatureLevel);    TShaderMapRef&lt;FShaderTestVS&gt; VertexShader(GlobalShaderMap);    TShaderMapRef&lt;FShaderTestPS&gt; PixelShader(GlobalShaderMap);    // Set the graphic pipeline state.      FGraphicsPipelineStateInitializer GraphicsPSOInit;    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);    GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI();    GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI();    GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI();    GraphicsPSOInit.PrimitiveType = PT_TriangleList;    GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GetVertexDeclarationFVector4();    GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader);    GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader);    SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit);    //RHICmdList.SetViewport(0, 0, 0.0f, DrawTargetResolution.X, DrawTargetResolution.Y, 1.0f);      PixelShader-&gt;SetParameters(RHICmdList, MyColor,MyColor2);    // Draw grid.      //uint32 PrimitiveCount = 2;      //RHICmdList.DrawPrimitive(PT_TriangleList, 0, PrimitiveCount, 1);      FVector4 Vertices[4];    Vertices[0].Set(-1.0f, 1.0f, 0, 1.0f);    Vertices[1].Set(1.0f, 1.0f, 0, 1.0f);    Vertices[2].Set(-1.0f, -1.0f, 0, 1.0f);    Vertices[3].Set(1.0f, -1.0f, 0, 1.0f);    static const uint16 Indices[6] =    {        0, 1, 2,        2, 1, 3    };    //DrawPrimitiveUP(RHICmdList, PT_TriangleStrip, 2, Vertices, sizeof(Vertices[0]));      DrawIndexedPrimitiveUP(        RHICmdList,        PT_TriangleList,        0,        ARRAY_COUNT(Vertices),        2,        Indices,        sizeof(Indices[0]),        Vertices,        sizeof(Vertices[0])    );    // Resolve render target.      RHICmdList.CopyToResolveTarget(        OutputRenderTargetResource-&gt;GetRenderTargetTexture(),        OutputRenderTargetResource-&gt;TextureRHI,        false, FResolveParams());}</code></pre><ul><li>这是渲染线程中执行的函数</li><li>这里只要在形参中添加MyColor2，以及SetParameters中添加MyColor2</li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpengl_HelloWindow</title>
      <link href="/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/"/>
      <url>/2019/09/21/CG/Opengl/LearnOpengl-HelloWindow/</url>
      
        <content type="html"><![CDATA[<ul><li><p>glfwMakeContextCurrent(window)</p><blockquote><p>用于在当前线程上载入window的上下文。</p></blockquote></li><li><p>需要在使用opengl函数前加载glad用于定于函数地址</p><pre><code class="lang-cpp">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){  std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;  return -1;}</code></pre><p>疑问:必须在glfwMakeContextCurrent(window)之后才能初始化GLAD,为什么？</p><blockquote><p>我做了一些尝试,glViewport的操作,如果不初始化GLAD,将无法使用。而要初始化GLAD,要在当前线程载入window上下文—190921 </p></blockquote></li></ul><ul><li><p>glViewport()<br>最终显示的内容由glViewport和glfwCreateWindow的参数共同决定：不会超过glfwCreateWindow的大小,小于的话会由部分不加载出来</p><blockquote><p>如果glfwCreateWindow:800*600,glViewport:1600*600,最终 800*600<br>如果glfwCreateWindow:800*600,glViewport:400*300,最终 400*300</p></blockquote></li><li><p>glfwSetFramebufferSizeCallback()<br>这是一个回调绑定函数,他会相应窗口变化，并传递宽高给回调函数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第三章:变换</title>
      <link href="/2019/09/09/CG/DirextX/D3DTransform/"/>
      <url>/2019/09/09/CG/DirextX/D3DTransform/</url>
      
        <content type="html"><![CDATA[<h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>满足以下性质为线性变换<blockquote><p>1.$\tau(u+v) = \tau(u) + \tau(v)$<br>2.$\tau(ku) = k\tau(u)$<br>其中u,v为任意三维向量，k为标量 </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第四章:渲染管线</title>
      <link href="/2019/09/09/CG/DirextX/D3DInit/"/>
      <url>/2019/09/09/CG/DirextX/D3DInit/</url>
      
        <content type="html"><![CDATA[<h1 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h1><ul><li>我们必须使用特定的函数活其他的COM接口方法来获取指向COM接口的指针,而不能用<strong>new</strong>  </li><li>释放用其基类IUnkown的Release,而不能用<strong>delete</strong>  </li><li>COM接口都以<strong>I</strong>为前缀,例如ID3D11Texture2D  </li></ul><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><ul><li>2D纹理是一种数据元素矩阵，可以用于存储图像数据，每个元素存储一个像素颜色。也可以存储纹理法线  </li><li>纹理只支持特定格式的数据类型。有DXGI_FORMAT枚举类型描述  </li><li>存在一种弱类型（typeless），预先分配空间，但不解释类型。</li></ul><h1 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h1><ul><li><strong>离屏</strong>(off-screen) =&gt; <strong>后台缓冲区</strong>(back buffer)</li><li><strong>前台缓冲区</strong>(front buffer)</li><li>前后缓冲区互换的行为为<strong>呈现</strong>(presenting)<blockquote><p>这一操作只是交换两者指针指向的位置，所以速度很快<br><img src="SwapBuffer.png" alt></p></blockquote></li><li>前后缓冲区组成一个<strong>交换链</strong>(swap chain)</li></ul><h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><ul><li>深度缓冲区与后台缓冲区大小一样</li><li>D3D11 判断前后遮挡使用 深度缓存(depth buffering)或Z缓存(z-buffering)</li></ul><h1 id="纹理资源视图"><a href="#纹理资源视图" class="headerlink" title="纹理资源视图"></a>纹理资源视图</h1><ul><li><p>纹理可以被绑定到渲染管线（rendering pipeline）的不同阶段（stage）。  </p><blockquote><p>将纹理作为渲染目标（即，Direct3D渲染到纹理,在渲染结果暂存在纹理中），使用标志D3D11_BIND_RENDER_TARGET<br>着色器资源（即，在着色器中对纹理进行采样），使用标志D3D10_BIND_SHADER_RESOURCE</p></blockquote></li><li><p>纹理不能直接绑定到渲染管线，只能把与资源关联的资源视图绑定到不同的管线阶段  </p></li><li>Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图</strong>（resource view），渲染目标视图（ID3D11RenderTargetView）和着色器资源视图（ID3D11ShaderResourceView） </li><li>创建资源时一定要指定绑定标志值，不然将无法创建资源视图 <h2 id="资源视图的作用"><a href="#资源视图的作用" class="headerlink" title="资源视图的作用"></a>资源视图的作用</h2></li><li>（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</li><li>（2）如果在创建资源时指定的是弱类型（typeless）格式，那么在为它创建资源视图时就必须指定明确的资源类型。对于弱类型格式，纹理元素可能会在一个管线阶段中视为浮点数，而在另一个管线阶段中视为整数。</li></ul><h1 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h1><ul><li>超级采样（supersampling）:比如4x ssaa,将屏幕分别率提高4倍，然后每4个像素采样后取平均值。相当于深度缓存和后台缓存都扩大4倍。</li><li>多重采样（multisampling）:比如4x msaa,只在三角形的边缘进行处理。且每一个像素分为4个子像素。深度缓存和后台缓存也会扩大4倍。</li></ul><h1 id="特征等级"><a href="#特征等级" class="headerlink" title="特征等级"></a>特征等级</h1><ul><li>特征等级定义了一系列支持不同d3d功能的相应的等级，用意即如果一个用户的硬件不支持某一特征等级，程序可以选择较低的等级。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://enjoyphysics.cn/Article1513" target="_blank" rel="noopener">https://enjoyphysics.cn/Article1513</a></p>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染模块</title>
      <link href="/2019/09/05/CG/UE4/UE4RenderModule/"/>
      <url>/2019/09/05/CG/UE4/UE4RenderModule/</url>
      
        <content type="html"><![CDATA[<p>原文:<a href="https://zhuanlan.zhihu.com/p/72509370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72509370</a></p><h1 id="UE4场景和场景管理-Scene-、SceneManager"><a href="#UE4场景和场景管理-Scene-、SceneManager" class="headerlink" title="UE4场景和场景管理(Scene 、SceneManager)"></a>UE4场景和场景管理(Scene 、SceneManager)</h1><h2 id="Scene与UWorld和FScene"><a href="#Scene与UWorld和FScene" class="headerlink" title="Scene与UWorld和FScene"></a>Scene与UWorld和FScene</h2><ul><li>UE4 Scene有UWorld和FScene组成  </li><li>UWorld用于游戏线程，包括用户的主动行为，如物体的创建和删除。</li><li>FScene用于渲染线程，包括物体的被动行为。</li><li>UWorld和FScene一一对应</li></ul><h2 id="UWorld和ULevel和ULevelStraming"><a href="#UWorld和ULevel和ULevelStraming" class="headerlink" title="UWorld和ULevel和ULevelStraming"></a>UWorld和ULevel和ULevelStraming</h2><ul><li>UWorld由持久关卡(ULevel)和子关卡组成。子关卡可以动态加卸载，也被称为流关卡(ULevelStreaming)</li><li>流关卡(ULevelStreaming)加载和卸载由UWorldComposition负责。由基于视点距离和流关卡卡包围盒的简单的加载策略实现</li><li>具体物体放置在关卡活流关卡中，而不是在UWorld中</li></ul><h2 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h2><ul><li>FScene不具备复杂的场景管理功能</li><li>FScene有以下结构<blockquote><p>数组:用于管理各种可渲染对象和灯光<br>Octree:用于灯光和可渲染对象的快速查找<br>DrawList:用于Cache各个渲染指令</p></blockquote></li></ul><h1 id="SceneObject"><a href="#SceneObject" class="headerlink" title="SceneObject"></a>SceneObject</h1><ul><li>将具体物体放入场景(即关卡和流关卡)中的时候，各个独立物体是由AActor及其子类的对象实例来建模表达</li><li>AActor和其子类不直接持有渲染数据，具体的渲染相关的数据均在UActorComponent及其子类的实例中。</li><li>渲染相关的主要Component类结构层次如下<br><img src="ComponentClassLevel.jpg" alt></li></ul><h1 id="UE4渲染API封装"><a href="#UE4渲染API封装" class="headerlink" title="UE4渲染API封装"></a>UE4渲染API封装</h1><ul><li>UE4中的渲染API封装是个独立的模块(Module)，他们把它命名为RHI（Render Hardware Interface）</li><li>RHI的转发实现在RHICommandList.h文件里，除了基本的条件判断，大都是直接 转调渲染API实现的RHI子模块里的渲染指令。</li></ul><h1 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h1><ul><li>UE4对材质系统的封装可以理解为RenderPipeline输入的所有数据中除了几何体数据之外的所有其它数据。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li>材质分为材质模块(UMaterial)和材质实例(UMaterialInstance),两者继承自UMaterialInterface</li><li>UMaterial材质模板带有可编辑的节点图并可据此生成对应的Shader组合</li><li>UMaterialInstance材质实例则只需要引用UMaterial对应的Shader且只能修改材质模板暴露出来的材质参数。</li></ul><h2 id="FMaterialResource"><a href="#FMaterialResource" class="headerlink" title="FMaterialResource"></a>FMaterialResource</h2><ul><li>没关UMaterial中含有多个FMaterialResource，其继承自FMateriale。其负责为各个渲染API和材质所支持的各种质量等级生成对应的Shader组合</li></ul><h2 id="FMaterialRenderProxy"><a href="#FMaterialRenderProxy" class="headerlink" title="FMaterialRenderProxy"></a>FMaterialRenderProxy</h2><ul><li>FMaterialRenderProxy是FMaterial用于渲染线程的代理,它可以透过FMaterail和UMaterialInterface访问到Shader、渲染状态，光照模型等所有用户设置好的材质参数。</li></ul><hr><ul><li>UE4的材质中光照模型是不可定制的，除非修改源码</li></ul><h1 id="UE4中Shader生成"><a href="#UE4中Shader生成" class="headerlink" title="UE4中Shader生成"></a>UE4中Shader生成</h1><ul><li>UE4的shader基类为FShader,其有两个主要的子类FGlobalShader和FMaterialShader</li><li>FGlobalShader:全局Shader,会自动注册到全局ShaderCache中</li><li>FMaterialShader:用于材质(编辑器）的Shader，所有的后处理、UI、用于模型渲染的Shader都是它的子类。 </li><li>UE4 Shader生成分两部分<blockquote><p>第一部分是把材质编辑器中的节点图编译成HLSL代码，这一部分是通过FHLSLMaterialTranslator来完成的。<br>第二部分是把HLSL生成多平台的Shader代码，如Windows上的HLSL,Android上的GLSL,IOS上的MetalShader。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第五章:渲染管线</title>
      <link href="/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2019/08/19/CG/DirextX/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉"><a href="#三维视觉" class="headerlink" title="三维视觉"></a>三维视觉</h1><ul><li>渲染管线:在给定一个3D场景的几何描述及一架已确定位置和方向的虚拟摄像机时，根据虚拟摄像机的视角生成2D图像的一系列步骤<blockquote><p>渲染管线由许多步骤组成，每个步骤称为一个阶段</p></blockquote></li></ul><p><img src="5-1.jpg" alt></p><ul><li>线性透视（linear perspective）:在2d画布上两条平行的线不断向远处延伸，最终会相交到一点。这个点是零点（vanishing point）<br><img src="5-2.jpg" alt></li><li>景深现象（depth phenomenon）:物体的大小会随着深度的增加而减小<br><img src="5-3.jpg" alt></li><li>物体重叠（object overlap）:一个不透明的物体会挡住它后面的其他物体的一部分（或全部）<br><img src="5-4.jpg" alt></li><li>光照（lighting）和阴影（shading）:表现物体立体感和体积感<br><img src="5-5.jpg" alt><blockquote><p>阴影具有两个关键作用：一是告诉我们场景中的光源位置，二是告诉我们飞船距离地面的高度。<br><img src="5-6.jpg" alt></p></blockquote></li></ul><h1 id="模型的表现形式"><a href="#模型的表现形式" class="headerlink" title="模型的表现形式"></a>模型的表现形式</h1><ul><li>三角形是构成物体模型的基本单位</li></ul><h1 id="基本计算机颜色"><a href="#基本计算机颜色" class="headerlink" title="基本计算机颜色"></a>基本计算机颜色</h1><h2 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h2><ul><li><p>0.5(1, 1,1) = (0.5, 0.5, 0.5)</p><blockquote><p>将白色乘以0.5，得到一个中等强度的灰色</p></blockquote></li><li><p>分量乘法（componentwise multiplication）。</p><blockquote><p>$(c_{r},c_{g},c_{b}) ⨂ (k_{r},k_{g},k_{b}) = (c_{r}k_{r},c_{g}k_{g},c_{b}k_{b})$<br>(r,g,b)⨂(0.5,0.75,0.25) = (0.5r,0.75g,0.25b)<br>常用于光照方程,比如上述式子可以表示：光线照射物体时，反射50%红光，75%绿光，25%蓝光</p></blockquote></li></ul><h2 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h2><ul><li><p>alpha值：用于表示物体的不透明度</p><blockquote><p>alpha == 0 完全透明；alpha == 1 完全不透明</p></blockquote></li><li><p>r,g,b,a各用32位浮点型，所以这种表达方式共128位</p></li></ul><h2 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h2><ul><li><p>r,g,b,a分别用8位表示，每个分量又256种强度。</p></li><li><p>32位于128位互相转换</p><blockquote><p>32-&gt;128: 各分量除以256，转换为float<br>128-&gt;32: 各分量乘以256, 转换为int</p></blockquote></li><li><p>通常，许多颜色运算（例如，在像素着色器中）使用的都是128位颜色值；通过这一方式，我们可以有足够多的二进制位来保证计算的精确度，减少算术错误的累积。不过，最终的像素颜色通常是存储在后台缓冲区的32位颜色值中；目前的物理显示设备还不能充分利用更高的分辨率颜色。</p></li></ul><h1 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h1><p><img src="5-7.jpg" alt></p><blockquote><p>内存到阶段的箭头表示阶段从内存种读数据<br>内存到阶段的箭头表示阶段在内存种写数据</p></blockquote><h1 id="输入装配阶段-Input-Assembler-Stage"><a href="#输入装配阶段-Input-Assembler-Stage" class="headerlink" title="输入装配阶段(Input Assembler Stage)"></a>输入装配阶段(Input Assembler Stage)</h1><p>输入装配（Input Assembler，简称IA）阶段从内存读取几何数据（顶点和索引）并将这些数据组合为几何图元（例如，三角形、直线）。</p><blockquote><p>索引规定了顶点的组织形式，解释了该以何种方式组成图元。</p></blockquote><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><ul><li>Direct3D中的顶点由空间位置和各种附加属性组成。比如添加法线向量实现光照，添加纹理坐标实现纹理等等</li></ul><h2 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h2><ul><li>顶点缓冲区:在连续内存中存储了的一个顶点列表</li><li>图元拓扑:用来指定如何组织顶点缓冲区的顶点。例如每两个组成一条直线，每三个组成一个三角形</li></ul><h3 id="基本图元"><a href="#基本图元" class="headerlink" title="基本图元"></a>基本图元</h3><p><img src="5-8.png" alt></p><blockquote><p>(a)为点列表  D3D11_PRIMITIVE_TOPOLOGY_POINTLIST<br>(b)为线带 D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP<br>(c)为线列表 D3D11_PRIMITIVE_TOPOLOGY_LINELIST<br>(d)为三角形带 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 三角形带不会造成顶点的重复存储  </p></blockquote><p><img src="5-9.png" alt></p><blockquote><p>(a)为三角形列表 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST</p></blockquote><h3 id="带邻接信息的图元"><a href="#带邻接信息的图元" class="headerlink" title="带邻接信息的图元"></a>带邻接信息的图元</h3><ul><li>如上图(b)主要用于某些几何着色器的的算法 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ<blockquote><p>邻接图元顶点只能作为几何着色器的输入数据且不会被绘制出来</p></blockquote></li></ul><h3 id="控制点面片列表"><a href="#控制点面片列表" class="headerlink" title="控制点面片列表"></a>控制点面片列表</h3><ul><li>见13章  D3D11_PRIMITIVE_TOPOLOGY_N_CONTRIL_POINT_PATCHLIST<blockquote><p>用于图形渲染管线的细分阶段</p></blockquote></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>问题：通过三角形构造其他图形的时候，如果使用三角形列表，将会造成大量的顶点的重复。</p></li><li><p>产生影响: 1.增加内存需求量。2.增加图形硬件的处理负担。</p></li><li><p>方法一：使用三角形带。但是顶点必须按照带状组织，不灵活。</p></li><li><p>方法二：引入索引。</p><pre><code class="lang-cpp">//create a quadVertex v[4] = {v0, v1, v2, v3}; UINT indexList[6] = {0, 1, 2,    //Triangle0   0, 2, 3}; // Triangle 1 };</code></pre><blockquote><p>当顶点列表中的唯一顶点得到处理之后，显卡可以使用索引列表把顶点放在一起构成三角形。我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为：<br>1．索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。<br>2．通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p></blockquote></li></ul><h1 id="顶点着色器阶段-vertex-shader-Stage"><a href="#顶点着色器阶段-vertex-shader-Stage" class="headerlink" title="顶点着色器阶段(vertex shader Stage)"></a>顶点着色器阶段(vertex shader Stage)</h1><p>顶点着色器将IA阶段的输出的顶点实现相关效果再输出（例如变换，光照，置换贴图映射等）。此外此阶段还可以访问内存种的纹理和其他数据（变换矩阵和场景灯光）。可以概念性地认为在硬件上执行了如下代码：</p><pre><code class="lang-cpp">for(UINT i = 0; i &lt; numVertices; ++i)    outputVertex[i] = VertexShader(inputVertex[i]);</code></pre><h2 id="局部空间和世界空间"><a href="#局部空间和世界空间" class="headerlink" title="局部空间和世界空间"></a>局部空间和世界空间</h2><ul><li>世界变换:局部空间-&gt;世界空间</li></ul><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><ul><li>观察变换:世界空间-&gt;观察空间</li></ul><h2 id="齐次裁剪控件"><a href="#齐次裁剪控件" class="headerlink" title="齐次裁剪控件"></a>齐次裁剪控件</h2><p><a href="https://gameinstitute.qq.com/community/detail/117556" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/117556</a></p><h2 id="规范化设备坐标-NDC"><a href="#规范化设备坐标-NDC" class="headerlink" title="规范化设备坐标(NDC)"></a>规范化设备坐标(NDC)</h2><ul><li>将坐标都映射到[-1,1]，目的是消除设备差异性</li></ul><h1 id="曲面细分阶段"><a href="#曲面细分阶段" class="headerlink" title="曲面细分阶段"></a>曲面细分阶段</h1><ul><li>可选阶段,详见13章</li></ul><h1 id="几何着色器阶段"><a href="#几何着色器阶段" class="headerlink" title="几何着色器阶段"></a>几何着色器阶段</h1><ul><li>接收完整的图元数据</li><li>用于创建和销毁几何体<blockquote><p>根据接收到的图元数据来扩展图元或根据某些条件来拒绝输出某些图元数据<br>常用于将一个点扩展为一个四边形，或者将一条线扩展为一个四边形</p></blockquote></li><li>顶点位置在离开几何着色器之前，必须被变换到齐次裁剪空间。</li></ul><h1 id="裁剪阶段"><a href="#裁剪阶段" class="headerlink" title="裁剪阶段"></a>裁剪阶段</h1><ul><li>完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。</li><li>三角形被裁剪后会变成四边形，这需要重新划分三角形</li><li>Sutherland-Hodgeman裁剪法:</li></ul><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><ul><li>齐次裁剪空间-&gt;规范化设备空间-&gt;后台缓冲区的视口区域（此时x,y以像素为单位）</li><li>z值还要被深度缓存使用。</li></ul><h2 id="背面消隐"><a href="#背面消隐" class="headerlink" title="背面消隐"></a>背面消隐</h2><h3 id="判断三角形正反面"><a href="#判断三角形正反面" class="headerlink" title="判断三角形正反面"></a>判断三角形正反面</h3><ul><li>设三角形的定点排列为$v_{0},v_{1},v_{2}$</li><li>可以计算出三角形的法线，方法如下:<blockquote><p>$\vec{e_{0}} = v_{1} - v_{0}$<br>$\vec{e_{1}} = v_{2} - v_{1}$<br>$\vec{n} = \frac{\vec{e_{0}} × \vec{e_{1}}}{|| \vec{e_{0}} × \vec{e_{1}} ||}$</p></blockquote></li><li>带有法线向量的面为正面，而另一个面为背面<blockquote><p>当观察者看到三角形的正面时，我们说三角形是朝前的；当观察者看到三角形的背面时， 我们说三角形是朝后的。<br>因为按照我们选择的约定（即，我们计算三角形法线的方式），按顺时针方向环绕的三角形（相对于观察者）是朝前的，而按逆时针方向环绕的三角形（相对于观察者）是朝后的。</p></blockquote></li><li>D3D 顺时针</li></ul><h3 id="背面消隐-backface-culling"><a href="#背面消隐-backface-culling" class="headerlink" title="背面消隐(backface culling)"></a>背面消隐(backface culling)</h3><ul><li>背面消隐（backface culling）是指让管线放弃对朝后的三角形的处理。这可以将所要处理的三角形的数量降低到原数量的一半。</li><li>以下为2D和3D场景消隐前后的表现<br><img src="backfaceCulling2D.png" alt><br><img src="backfaceCulling3D.png" alt></li></ul><h2 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h2><ul><li>一条3D线被投影到投影窗口上（在屏幕空间中投影是一条2D线）。我们看到，在3D线上取等距离的点，在2D屏幕空间上的投影点却不是等距离的。所以，我们在3D空间中执行线性插值，在屏幕空间需要执行非线性插值。</li></ul><h1 id="像素着色器阶段"><a href="#像素着色器阶段" class="headerlink" title="像素着色器阶段"></a>像素着色器阶段</h1><ul><li>像素着色器（Pixel shader）是由我们编写的在GPU上执行的程序。像素着色器会处理每个像素片段（pixel fragment），它的输入是插值后的顶点属性，由此计算出一个颜色。像素着色器可以非常简单地输出一个颜色，也可以很复杂，例如实现逐像素光照、反射和阴影等效果。</li></ul><h1 id="输出合并阶段"><a href="#输出合并阶段" class="headerlink" title="输出合并阶段"></a>输出合并阶段</h1><ul><li>当像素片段由像素着色器生成之后，它们会被传送到渲染管线的输出合并（output<br>merger，简称OM）阶段。在该阶段中，某些像素片段会被丢弃（例如，未能通过深度测试或模板测试）。未丢弃的像素片段会被写入后台缓冲区。混合（blending）工作是在该阶段中完成的，一个像素可以与后台缓冲区中的当前像素进行混合，并以混合后的值作为该像素的最终颜色。某些特殊效果，比如透明度，就是通过混合来实现的；我们会在第9章专门讲解混合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之JSON学习</title>
      <link href="/2019/08/07/CG/UE4/JSON/"/>
      <url>/2019/08/07/CG/UE4/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>JSON格式</li><li>解析JSON文件</li><li>修改JSON文件</li></ul><h1 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/29119549" target="_blank" rel="noopener">十分钟搞定JSON和JSON对象</a></li></ul><p>想要使用JSO相关工具，必须在<strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;,         &quot;Json&quot;,         &quot;JsonUtilities&quot;    });</code></pre><h1 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h1><ul><li>我们在 \Content\Res\Data.json中天下如下测试例子</li></ul><pre><code class="lang-json">/** Data.json **/[    {        &quot;1-1&quot;:&quot;1-1&quot;,        &quot;1-2&quot;:&quot;1-2&quot;    },    {        &quot;2-1&quot;:&quot;2-1&quot;    },    {        &quot;3-1&quot;:        [            {                &quot;1&quot;:&quot;3-1-1&quot;            },            {                &quot;2&quot;:&quot;3-1-2&quot;            }        ]    }]</code></pre><ul><li>我们要首先得将他以字符串的形式读入<blockquote><p>FPaths::GameContentDir() 能获取 */Content/ 的位置<br>FFileHelper::LoadFileToString() Load a text file to an FString.</p></blockquote></li></ul><pre><code class="lang-cpp">bool MyJsonHandle::LoadStringFromFile(FString &amp; RelativePathName, FString &amp; FileName, FString &amp; ResultString){    if (!FileName.IsEmpty())    {        FString AbsloutePathName = FPaths::GameContentDir() + RelativePathName + FileName;        if (FPaths::FileExists(AbsloutePathName))        {            if (FFileHelper::LoadFileToString(ResultString, *AbsloutePathName))            {                return true;            }        }    }    return false;}`</code></pre><ul><li>接下来我们来解析我们所获取到的FString</li></ul><pre><code class="lang-cpp">/** MyJsonHandle.cpp **/bool MyJsonHandle::RecordDataJsonRead(){    FString result;    //这是我们上面自定义的函数    LoadStringFromFile(RelativePathName, DataFileName, result);    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse;    TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(result);    if (FJsonSerializer::Deserialize(JsonReader, JsonParse))    { //这样解析后的节点全部存在JsonParse中        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-1&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-2&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[1]-&gt;AsObject()-&gt;GetStringField(FString(&quot;2-1&quot;)));        //如果对象是嵌套的，则需要再声明一次TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt;来获取        TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse3 = JsonParse[2]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;3-1&quot;));        if (JsonParse3.IsValidIndex(0))        {            for (int cnt = 1; cnt &lt;= JsonParse3.Num(); ++cnt)            {                UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse3[cnt-1]-&gt;AsObject()-&gt;GetStringField(FString::FromInt(cnt)));            }        }        else        {            UE_LOG(LogTemp, Warning, TEXT(&quot;error JsonParse3&quot;));        }        return true;    }    return false;}</code></pre><h1 id="修改JSON文件"><a href="#修改JSON文件" class="headerlink" title="修改JSON文件"></a>修改JSON文件</h1><h2 id="设置单个属性"><a href="#设置单个属性" class="headerlink" title="设置单个属性"></a>设置单个属性</h2><ul><li>通过下面的代码生成一个<pre><code class="lang-cpp">/*** A Json Object is a structure holding an unordered set of name/value pairs.* In a Json file, it is represented by everything between curly braces {}.*/TSharedPtr&lt;FJsonObject&gt; Object1 = MakeShareable(new FJsonObject);Object1-&gt;SetStringField(&quot;1-1&quot;, &quot;1--1&quot;);Object1-&gt;SetStringField(&quot;1-2&quot;, &quot;1--2&quot;);TSharedPtr&lt;FJsonValueObject&gt; CultureValue = MakeShareable(new FJsonValueObject(CultureObject));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4学习</title>
      <link href="/2019/08/07/Menu/UE4Menu/"/>
      <url>/2019/08/07/Menu/UE4Menu/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&amp;_bid=167&amp;_wv=3&amp;ADUIN=1076613110&amp;ADSESSION=1556776713&amp;ADTAG=CLIENT.QQ.5611_.0&amp;ADPUBNO=26886&amp;taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><p><a href="https://sanctorum003.github.io/2019/08/02/HUD/" target="_blank" rel="noopener">虚幻4之Slate学习一 —— HUD</a><br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a><br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a><br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a><br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/CG/UE4/DelegateAndMacro/"/>
      <url>/2019/08/06/CG/UE4/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><div class="table-container"><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table></div><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="lang-CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="lang-cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="lang-cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="lang-cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="lang-cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="lang-cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="lang-cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li>事件原型<pre><code class="lang-cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="lang-cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li>FReply 告诉引擎如何处理事件<blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li>FReply::Handled() 告诉引擎事件处理完<blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p></li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.h **/public:    //注意SOverlay::FOverlaySlot 是内部类    SOverlay::FOverlaySlot* MySlot;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>我们尝试编写图片的点击效果，来使用委托和宏。SImage默认不带这个效果。</li><li>首先我们创建一个继承于SlateWidget的C++类命名为MyImage</li><li>创建一个委托，用于与SLATE_EVENT绑定。相当于自定义一个需要单击会触发函数的函数原型</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/DECLARE_DELEGATE_RetVal(FReply,FImageOnClicked)</code></pre><ul><li>创建一个SLATE_EVENT,将之前创建的委托与该SLATE_EVENT绑定</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/SLATE_BEGIN_ARGS(SMyHUDWidget){}SLATE_EVENT(FImageOnClicked, ImageOnClicked)SLATE_END_ARGS()</code></pre><ul><li>然后在原来的SMyHUDWidget将SImage换成SMyImage并且可以调用ImageOnClicked()</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            /**              * TSharedPtr&lt;SMyImage&gt; MyImage;            **/            SAssignNew(MyImage, SMyImage)            //.ImageOnClicked()        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        .Expose(MySlot)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    //删除原来语句    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><ul><li>在SMyImage中添加图片</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/#include &quot;SMyImage.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SImage.h&quot;#include &quot;Public/UI/MySlateWidgetStyle.h&quot;#include &quot;Public/UI/MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyImage::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>此时效果如下<br><img src="MyImage.png" alt></p><ul><li>接着我们需要创建一个回调函数用于ImageOnClicked()，传入后event对应FImageOnClicked就绑定该函数了</li></ul><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::ImageClicked(){    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, &quot;Suceess&quot;);    return FReply::Handled();}</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **//**    * TSharedPtr&lt;SMyImage&gt; MyImage;**/SAssignNew(MyImage, SMyImage).ImageOnClicked(this, &amp;SMyHUDWidget::ImageClicked)</code></pre><ul><li>但是这时候会发现，单击并没有什么效果。这是因为程序并不知道要根据单击触发。</li><li>我们需要在MyImage中重写鼠标相关函数</li></ul><pre><code class="lang-cpp">/** SMyImage.h **/public:    FImageOnClicked ImageOnClick;    virtual FReply OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual FReply OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual void OnMouseLeave(const FPointerEvent&amp; MouseEvent) override;    bool BIsMouseButtonDown = false;</code></pre><ul><li>我们这时候需要在鼠标按下时调用委托，使用我们必须事先获取到这个委托，<em>FImageOnClicked ImageOnClick</em>就是用来声明该委托。</li><li>在构造中,通过InArgs._*可以来获取SLATE_BEGIN_ARGS(SMyHUDWidget)和SLATE_END_ARGS()之间的属性。</li></ul><pre><code class="lang-cpp">/** SMyImage.cpp **/void SMyImage::Construct(const FArguments&amp; InArgs){    ImageOnClick = InArgs._ImageOnClicked;    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}</code></pre><ul><li>这样我们就可以重写鼠标事件，让其在点击时调用相关委托</li></ul><pre><code class="lang-cpp">FReply SMyImage::OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = true;    return FReply::Handled();}FReply SMyImage::OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    if (BIsMouseButtonDown == true)    {        BIsMouseButtonDown = false;        ImageOnClick.Execute();    }    return FReply::Handled();}void SMyImage::OnMouseLeave(const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = false;}</code></pre><ul><li>到此就完成了，点击图片时会显示<strong>SUCCEESS</strong><br><img src="Success.png" alt><blockquote><p>如果不成功可以尝试将播放模式设成模拟<br><img src="Simulation.png" alt></p></blockquote></li></ul><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/CG/UE4/SlateWidget/"/>
      <url>/2019/08/04/CG/UE4/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="lang-cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="lang-cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/CG/UE4/WidgetStyle/"/>
      <url>/2019/08/03/CG/UE4/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="lang-cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="lang-cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="lang-cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="lang-cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="lang-cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="lang-cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/CG/UE4/HUD/"/>
      <url>/2019/08/02/CG/UE4/HUD/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li><li>设置光标的相关属性</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="lang-cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="lang-cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="lang-cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="lang-cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将控件从视口删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将视口中的全部控件删除<pre><code class="lang-cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="设置光标"><a href="#设置光标" class="headerlink" title="设置光标"></a>设置光标</h1><ul><li>这里光标是默认的，我们需要让光标一直显示，不然对后面会有影像。</li><li>我们创建继承于PlayerController的MyController类。</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/AMyController::AMyController(){    /** Whether the mouse cursor should be displayed. */    bShowMouseCursor = true;}</code></pre><ul><li>我们还可以设置光标的移动范围</li></ul><pre><code class="lang-cpp">/** MyController.cpp **/void AMyController::BeginPlay(){    /** Data structure used to setup an input mode that allows only the UI to respond to user input. */    FInputModeUIOnly InputMode;    /** Sets the mouse locking behavior of the viewport */    InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::LockAlways);    SetInputMode(InputMode);}</code></pre><ul><li>在Gamemode中应用，这样光标一直显示，且不能移出视口</li></ul><pre><code class="lang-cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;#include &quot;Public\MyController.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();    PlayerControllerClass = AMyController::StaticClass();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码</p><pre><code class="lang-cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/Algorithm/KMP/"/>
      <url>/2019/08/01/Algorithm/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p><p>3) 求当next数组当前位置<strong>j</strong></p><pre><code class="lang-cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>1) next[1]=0</p><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p><p>规则2：右移一位，最左边添-1，最右边自然溢出</p><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
