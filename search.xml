<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Transform</title>
      <link href="/2019/09/09/Transform/"/>
      <url>/2019/09/09/Transform/</url>
      
        <content type="html"><![CDATA[<h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>满足以下性质为线性变换<blockquote><p>1.$\tau(u+v) = \tau(u) + \tau(v)$<br>2.$\tau(ku) = k\tau(u)$<br>其中u,v为任意三维向量，k为标量 </p></blockquote></li></ul><h2 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h2><ul><li>设向量 $\vec{u} = (x,y,z)$<br>$$\vec{u} = (x,y,z) = x \vec{i} +y \vec{j} + z \vec{k}$$<blockquote><p>$\vec{i}$,$\vec{j}$,$\vec{k}$称为${ℝ}^{3}$的标准基向量（standard basis vectors）（${ℝ}^{3}$表示所有3D坐标向量$(x,y,z)$的集合）</p></blockquote></li></ul><p>$$\vec{u} = x(1,0,0)+y(0,1,0)+z(0,0,1) =<br> \begin{bmatrix}<br>   x &amp; y &amp; z<br>  \end{bmatrix}<br> \begin{bmatrix}<br>   1 &amp; 0 &amp; 0 \<br>   0 &amp; 1 &amp; 0 \<br>   0 &amp; 0 &amp; 1<br>  \end{bmatrix}<br>$$</p><ul><li><p>设一线性变换$\tau(u)$<br>$$\tau(u) = \tau(x\vec{i}+y\vec{j}+z\vec{k}) = x\tau(\vec{i})+y\tau(\vec{j})+z\tau(\vec{k})$$<br>$$\tau(u) = \vec{u}A =<br>\begin{bmatrix}<br> x &amp; y &amp; z<br>\end{bmatrix}<br>\begin{bmatrix}<br> 1 &amp; 0 &amp; 0 \<br> 0 &amp; 1 &amp; 0 \<br> 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>\leftarrow &amp; \tau(\vec{i}) &amp; \rightarrow \<br>\leftarrow &amp; \tau(\vec{j}) &amp; \rightarrow \<br>\leftarrow &amp; \tau(\vec{k}) &amp; \rightarrow \<br>\end{bmatrix}<br>=<br> \begin{bmatrix}<br> x &amp; y &amp; z<br>\end{bmatrix}<br>\begin{bmatrix}<br>A_{11} &amp; A_{12} &amp; A_{13} \<br>A_{21} &amp; A_{22} &amp; A_{23} \<br>A_{31} &amp; A_{32} &amp; A_{33} \<br>\end{bmatrix}<br>$$<br>由上面推导，我们把A称为线性变换$\tau$的矩阵描述</p></li><li><p>S是线性的  $\leftrightarrow$ S存在一个矩阵描述</p><h2 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h2></li><li><p>缩放变换是一个线性变换<br>$$ S(x,y,z) = (S_{x}x,S_{y}y,S_{z}z) =<br>\begin{bmatrix}<br>x &amp; y &amp; z \<br>\end{bmatrix}<br>\begin{bmatrix}<br>S_{x} &amp; 0     &amp; 0     \<br>0     &amp; S_{y} &amp; 0     \<br>0     &amp; 0     &amp; S_{z} \<br>\end{bmatrix}<br>$$</p></li><li><p>缩放变换矩阵为<br>$$<br>\begin{bmatrix}<br>S_{x} &amp; 0     &amp; 0     \<br>0     &amp; S_{y} &amp; 0     \<br>0     &amp; 0     &amp; S_{z} \<br>\end{bmatrix}<br>$$</p></li><li><p>缩放变换逆矩阵为<br>$$<br>\begin{bmatrix}<br>\frac{1}{S_{x}} &amp; 0     &amp; 0     \<br>0     &amp; \frac{1}{S_{y}} &amp; 0     \<br>0     &amp; 0     &amp; \frac{1}{S_{z}} \<br>\end{bmatrix}<br>$$</p></li></ul><h2 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h2><ul><li>推导有点复杂，暂时略。</li><li>旋转矩阵<br><img src="Rotate.png" alt></li><li>旋转矩阵是个正交矩阵，所以转置和逆相同<br><img src="RotateReverse.png" alt></li><li>我们常用绕X,Y,Z旋转<br><img src="RotateXYZ.png" alt></li></ul><h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul><li>用(x,y,z,0)表示向量，这样在平移过程中不会改变坐标</li><li>用(x,y,z,1)表示点<blockquote><p>这样两点相减位向量，点加向量为点。符合定义</p></blockquote></li></ul><h2 id="仿射变换-1"><a href="#仿射变换-1" class="headerlink" title="仿射变换"></a>仿射变换</h2><ul><li>定义: 线性变换 + 平移<br>$$ a(u) = \tau(u) + b $$<br>矩阵表示为:<br>$$<br>a(u) = uA + b =<br>\begin{bmatrix}<br>  x &amp; y &amp; z\<br>\end{bmatrix}<br>\begin{bmatrix}<br>A_{11} &amp; A_{12} &amp; A_{13} \<br>A_{21} &amp; A_{22} &amp; A_{23} \<br>A_{31} &amp; A_{32} &amp; A_{33} \<br>\end{bmatrix} +<br>\begin{bmatrix}<br>  b_{x} &amp; b_{y} &amp; b_{z}<br>\end{bmatrix}<br>=<br>  \begin{bmatrix}<br>  x’ &amp; y’ &amp; z’\<br>\end{bmatrix}<br>$$<br>也可以用齐次坐标的形式:<br>$$<br>  a(u) =<br>  \begin{bmatrix}<br>  x &amp; y &amp; z &amp; 1<br>  \end{bmatrix}<br>  \begin{bmatrix}<br>  A_{11} &amp; A_{12} &amp; A_{13} &amp; 0\<br>  A_{21} &amp; A_{22} &amp; A_{23} &amp; 0\<br>  A_{31} &amp; A_{32} &amp; A_{33} &amp; 0\<br>  b_{x}  &amp; b_{y}  &amp; b_{z}  &amp; 1\<br>  \end{bmatrix} =<br>  \begin{bmatrix}<br>  b_{x} &amp; b_{y} &amp; b_{z} &amp; 1<br>  \end{bmatrix}<br>$$<blockquote><p>上述 4*4 矩阵为仿射变换矩阵</p></blockquote></li></ul><h2 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h2><p>$$ \tau{u} = uI + b $$</p><blockquote><p>I为单位矩阵</p><ul><li>平移变换仿射变换矩阵<br>$$<br>  \begin{bmatrix}<br>  1 &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; 1 &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  b_{x} &amp; b_{y} &amp; b_{z} &amp; 1 \<br>  \end{bmatrix}<br>$$</li><li>其逆矩阵为<br>$$<br>  \begin{bmatrix}<br>  1 &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; 1 &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>   -b_{x} &amp; -b_{y} &amp; -b_{z} &amp; 1 \<br>  \end{bmatrix}<br>$$</li></ul></blockquote><h2 id="缩放和旋转的仿射矩阵"><a href="#缩放和旋转的仿射矩阵" class="headerlink" title="缩放和旋转的仿射矩阵"></a>缩放和旋转的仿射矩阵</h2><p><img src="RS_Affine.png" alt></p><h2 id="仿射变换矩阵的几何解释"><a href="#仿射变换矩阵的几何解释" class="headerlink" title="仿射变换矩阵的几何解释"></a>仿射变换矩阵的几何解释</h2><ul><li>放射变换其实是对基向量的变换。这样同样的线性组合在不同的基向量下表达不一样。达到了变换的作用</li></ul><h1 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h1><ul><li>先旋转后平移 和 先平移后旋转是不同的。因为所有变换都是相对于原点进行的。<br><img src="zuhe.png" alt><br>(a)先旋转再平移。(b)先平移再旋转。</li></ul><h1 id="坐标转换变换"><a href="#坐标转换变换" class="headerlink" title="坐标转换变换"></a>坐标转换变换</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><img src="Transform%5CCoordinateVector.png" alt><br>$$P_{A} = |x| \vec{x} + |y| \vec{y}$$<br>$$P_{B} = |x| \vec{u} + |y| \vec{v}$$</p><ul><li>其中$\vec{u},\vec{v}$方向与FrameA中基底相同，然后可以知道$\vec{P}$的表示了</li><li>$P_{B}=x\vec{u_{B}}+y\vec{v_{B}}+z\vec{w_{B}}$<br>其中u、v、w是单位向量，它们所指向的方向分别与参考系A的x轴、y轴、z轴方向相同。</li></ul><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><ul><li>因为点具有位置信息</li><li>$P_{B}=x\vec{u_{B}}+y\vec{v_{B}}+z\vec{w_{B}}+Q_{B}$<br>其中u、v、w是单位向量，它们所指的方向分别与参考系A的x轴、y轴、z轴方向相同，Q是参考系A的原点。</li></ul><h2 id="矩阵表示-1"><a href="#矩阵表示-1" class="headerlink" title="矩阵表示"></a>矩阵表示</h2><p><img src="Matrix.png" alt></p><ul><li>其中$Q_{B}=(Q_{x},Q_{y},Q_{z},1)、u_{B}= (u_{x},u_{y},u_{z},0)、v_{B}=(vx,vy,vz,0)、w_{B}=(w_{x},w_{y},w_{z},0)$均为齐次坐标，它们描述了参考系A相对于参考系B的原点位置和坐标轴方向。我们将方程3.9中的4×4矩阵称为坐标转换矩阵或参考系转换矩阵，它可以将参考系A的坐标转换（或映射）为参考系B的坐标。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://enjoyphysics.cn/Article1630" target="_blank" rel="noopener">https://enjoyphysics.cn/Article1630</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>D3DInit</title>
      <link href="/2019/09/09/D3DInit/"/>
      <url>/2019/09/09/D3DInit/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4渲染模块</title>
      <link href="/2019/09/05/UE4RenderModule/"/>
      <url>/2019/09/05/UE4RenderModule/</url>
      
        <content type="html"><![CDATA[<p>原文:<a href="https://zhuanlan.zhihu.com/p/72509370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72509370</a></p><h1 id="UE4场景和场景管理-Scene-、SceneManager"><a href="#UE4场景和场景管理-Scene-、SceneManager" class="headerlink" title="UE4场景和场景管理(Scene 、SceneManager)"></a>UE4场景和场景管理(Scene 、SceneManager)</h1><h2 id="Scene与UWorld和FScene"><a href="#Scene与UWorld和FScene" class="headerlink" title="Scene与UWorld和FScene"></a>Scene与UWorld和FScene</h2><ul><li>UE4 Scene有UWorld和FScene组成  </li><li>UWorld用于游戏线程，包括用户的主动行为，如物体的创建和删除。</li><li>FScene用于渲染线程，包括物体的被动行为。</li><li>UWorld和FScene一一对应</li></ul><h2 id="UWorld和ULevel和ULevelStraming"><a href="#UWorld和ULevel和ULevelStraming" class="headerlink" title="UWorld和ULevel和ULevelStraming"></a>UWorld和ULevel和ULevelStraming</h2><ul><li>UWorld由持久关卡(ULevel)和子关卡组成。子关卡可以动态加卸载，也被称为流关卡(ULevelStreaming)</li><li>流关卡(ULevelStreaming)加载和卸载由UWorldComposition负责。由基于视点距离和流关卡卡包围盒的简单的加载策略实现</li><li>具体物体放置在关卡活流关卡中，而不是在UWorld中</li></ul><h2 id="FScene"><a href="#FScene" class="headerlink" title="FScene"></a>FScene</h2><ul><li>FScene不具备复杂的场景管理功能</li><li>FScene有以下结构<blockquote><p>数组:用于管理各种可渲染对象和灯光<br>Octree:用于灯光和可渲染对象的快速查找<br>DrawList:用于Cache各个渲染指令</p></blockquote></li></ul><h1 id="SceneObject"><a href="#SceneObject" class="headerlink" title="SceneObject"></a>SceneObject</h1><ul><li>将具体物体放入场景(即关卡和流关卡)中的时候，各个独立物体是由AActor及其子类的对象实例来建模表达</li><li>AActor和其子类不直接持有渲染数据，具体的渲染相关的数据均在UActorComponent及其子类的实例中。</li><li>渲染相关的主要Component类结构层次如下<br><img src="ComponentClassLevel.jpg" alt></li></ul><h1 id="UE4渲染API封装"><a href="#UE4渲染API封装" class="headerlink" title="UE4渲染API封装"></a>UE4渲染API封装</h1><ul><li>UE4中的渲染API封装是个独立的模块(Module)，他们把它命名为RHI（Render Hardware Interface）</li><li>RHI的转发实现在RHICommandList.h文件里，除了基本的条件判断，大都是直接 转调渲染API实现的RHI子模块里的渲染指令。</li></ul><h1 id="UE4的材质系统"><a href="#UE4的材质系统" class="headerlink" title="UE4的材质系统"></a>UE4的材质系统</h1><ul><li>UE4对材质系统的封装可以理解为RenderPipeline输入的所有数据中除了几何体数据之外的所有其它数据。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li>材质分为材质模块(UMaterial)和材质实例(UMaterialInstance),两者继承自UMaterialInterface</li><li>UMaterial材质模板带有可编辑的节点图并可据此生成对应的Shader组合</li><li>UMaterialInstance材质实例则只需要引用UMaterial对应的Shader且只能修改材质模板暴露出来的材质参数。</li></ul><h2 id="FMaterialResource"><a href="#FMaterialResource" class="headerlink" title="FMaterialResource"></a>FMaterialResource</h2><ul><li>没关UMaterial中含有多个FMaterialResource，其继承自FMateriale。其负责为各个渲染API和材质所支持的各种质量等级生成对应的Shader组合</li></ul><h2 id="FMaterialRenderProxy"><a href="#FMaterialRenderProxy" class="headerlink" title="FMaterialRenderProxy"></a>FMaterialRenderProxy</h2><ul><li>FMaterialRenderProxy是FMaterial用于渲染线程的代理,它可以透过FMaterail和UMaterialInterface访问到Shader、渲染状态，光照模型等所有用户设置好的材质参数。</li></ul><hr><ul><li>UE4的材质中光照模型是不可定制的，除非修改源码</li></ul><h1 id="UE4中Shader生成"><a href="#UE4中Shader生成" class="headerlink" title="UE4中Shader生成"></a>UE4中Shader生成</h1><ul><li>UE4的shader基类为FShader,其有两个主要的子类FGlobalShader和FMaterialShader</li><li>FGlobalShader:全局Shader,会自动注册到全局ShaderCache中</li><li>FMaterialShader:用于材质(编辑器）的Shader，所有的后处理、UI、用于模型渲染的Shader都是它的子类。 </li><li>UE4 Shader生成分两部分<blockquote><p>第一部分是把材质编辑器中的节点图编译成HLSL代码，这一部分是通过FHLSLMaterialTranslator来完成的。<br>第二部分是把HLSL生成多平台的Shader代码，如Windows上的HLSL,Android上的GLSL,IOS上的MetalShader。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX11龙书-第五章:渲染管线</title>
      <link href="/2019/08/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2019/08/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉"><a href="#三维视觉" class="headerlink" title="三维视觉"></a>三维视觉</h1><ul><li>渲染管线:在给定一个3D场景的几何描述及一架已确定位置和方向的虚拟摄像机时，根据虚拟摄像机的视角生成2D图像的一系列步骤<blockquote><p>渲染管线由许多步骤组成，每个步骤称为一个阶段</p></blockquote></li></ul><p><img src="5-1.jpg" alt></p><ul><li>线性透视（linear perspective）:在2d画布上两条平行的线不断向远处延伸，最终会相交到一点。这个点是零点（vanishing point）<br><img src="5-2.jpg" alt></li><li>景深现象（depth phenomenon）:物体的大小会随着深度的增加而减小<br><img src="5-3.jpg" alt></li><li>物体重叠（object overlap）:一个不透明的物体会挡住它后面的其他物体的一部分（或全部）<br><img src="5-4.jpg" alt></li><li>光照（lighting）和阴影（shading）:表现物体立体感和体积感<br><img src="5-5.jpg" alt><blockquote><p>阴影具有两个关键作用：一是告诉我们场景中的光源位置，二是告诉我们飞船距离地面的高度。<br><img src="5-6.jpg" alt></p></blockquote></li></ul><h1 id="模型的表现形式"><a href="#模型的表现形式" class="headerlink" title="模型的表现形式"></a>模型的表现形式</h1><ul><li>三角形是构成物体模型的基本单位</li></ul><h1 id="基本计算机颜色"><a href="#基本计算机颜色" class="headerlink" title="基本计算机颜色"></a>基本计算机颜色</h1><h2 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h2><ul><li><p>0.5(1, 1,1) = (0.5, 0.5, 0.5)</p><blockquote><p>将白色乘以0.5，得到一个中等强度的灰色</p></blockquote></li><li><p>分量乘法（componentwise multiplication）。</p><blockquote><p>$(c_{r},c_{g},c_{b}) ⨂ (k_{r},k_{g},k_{b}) = (c_{r}k_{r},c_{g}k_{g},c_{b}k_{b})$<br>(r,g,b)⨂(0.5,0.75,0.25) = (0.5r,0.75g,0.25b)<br>常用于光照方程,比如上述式子可以表示：光线照射物体时，反射50%红光，75%绿光，25%蓝光</p></blockquote></li></ul><h2 id="128位颜色"><a href="#128位颜色" class="headerlink" title="128位颜色"></a>128位颜色</h2><ul><li><p>alpha值：用于表示物体的不透明度</p><blockquote><p>alpha == 0 完全透明；alpha == 1 完全不透明</p></blockquote></li><li><p>r,g,b,a各用32位浮点型，所以这种表达方式共128位</p></li></ul><h2 id="32位颜色"><a href="#32位颜色" class="headerlink" title="32位颜色"></a>32位颜色</h2><ul><li><p>r,g,b,a分别用8位表示，每个分量又256种强度。</p></li><li><p>32位于128位互相转换</p><blockquote><p>32-&gt;128: 各分量除以256，转换为float<br>128-&gt;32: 各分量乘以256, 转换为int</p></blockquote></li><li><p>通常，许多颜色运算（例如，在像素着色器中）使用的都是128位颜色值；通过这一方式，我们可以有足够多的二进制位来保证计算的精确度，减少算术错误的累积。不过，最终的像素颜色通常是存储在后台缓冲区的32位颜色值中；目前的物理显示设备还不能充分利用更高的分辨率颜色。</p></li></ul><h1 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h1><p><img src="5-7.jpg" alt></p><blockquote><p>内存到阶段的箭头表示阶段从内存种读数据<br>内存到阶段的箭头表示阶段在内存种写数据</p></blockquote><h1 id="输入装配阶段-Input-Assembler-Stage"><a href="#输入装配阶段-Input-Assembler-Stage" class="headerlink" title="输入装配阶段(Input Assembler Stage)"></a>输入装配阶段(Input Assembler Stage)</h1><p>输入装配（Input Assembler，简称IA）阶段从内存读取几何数据（顶点和索引）并将这些数据组合为几何图元（例如，三角形、直线）。</p><blockquote><p>索引规定了顶点的组织形式，解释了该以何种方式组成图元。</p></blockquote><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><ul><li>Direct3D中的顶点由空间位置和各种附加属性组成。比如添加法线向量实现光照，添加纹理坐标实现纹理等等</li></ul><h2 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h2><ul><li>顶点缓冲区:在连续内存中存储了的一个顶点列表</li><li>图元拓扑:用来指定如何组织顶点缓冲区的顶点。例如每两个组成一条直线，每三个组成一个三角形</li></ul><h3 id="基本图元"><a href="#基本图元" class="headerlink" title="基本图元"></a>基本图元</h3><p><img src="5-8.png" alt></p><blockquote><p>(a)为点列表  D3D11_PRIMITIVE_TOPOLOGY_POINTLIST<br>(b)为线带 D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP<br>(c)为线列表 D3D11_PRIMITIVE_TOPOLOGY_LINELIST<br>(d)为三角形带 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 三角形带不会造成顶点的重复存储  </p></blockquote><p><img src="5-9.png" alt></p><blockquote><p>(a)为三角形列表 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST</p></blockquote><h3 id="带邻接信息的图元"><a href="#带邻接信息的图元" class="headerlink" title="带邻接信息的图元"></a>带邻接信息的图元</h3><ul><li>如上图(b)主要用于某些几何着色器的的算法 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ<blockquote><p>邻接图元顶点只能作为几何着色器的输入数据且不会被绘制出来</p></blockquote></li></ul><h3 id="控制点面片列表"><a href="#控制点面片列表" class="headerlink" title="控制点面片列表"></a>控制点面片列表</h3><ul><li>见13章  D3D11_PRIMITIVE_TOPOLOGY_N_CONTRIL_POINT_PATCHLIST<blockquote><p>用于图形渲染管线的细分阶段</p></blockquote></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>问题：通过三角形构造其他图形的时候，如果使用三角形列表，将会造成大量的顶点的重复。</p></li><li><p>产生影响: 1.增加内存需求量。2.增加图形硬件的处理负担。</p></li><li><p>方法一：使用三角形带。但是顶点必须按照带状组织，不灵活。</p></li><li><p>方法二：引入索引。</p><pre><code class="cpp">//create a quadVertex v[4] = {v0, v1, v2, v3}; UINT indexList[6] = {0, 1, 2,    //Triangle0   0, 2, 3}; // Triangle 1 };</code></pre><blockquote><p>当顶点列表中的唯一顶点得到处理之后，显卡可以使用索引列表把顶点放在一起构成三角形。我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为：<br>1．索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。<br>2．通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p></blockquote></li></ul><h1 id="顶点着色器阶段-vertex-shader-Stage"><a href="#顶点着色器阶段-vertex-shader-Stage" class="headerlink" title="顶点着色器阶段(vertex shader Stage)"></a>顶点着色器阶段(vertex shader Stage)</h1><p>顶点着色器将IA阶段的输出的顶点实现相关效果再输出（例如变换，光照，置换贴图映射等）。此外此阶段还可以访问内存种的纹理和其他数据（变换矩阵和场景灯光）。可以概念性地认为在硬件上执行了如下代码：</p><pre><code class="cpp">for(UINT i = 0; i &lt; numVertices; ++i)    outputVertex[i] = VertexShader(inputVertex[i]); </code></pre>]]></content>
      
      
      <categories>
          
          <category> CG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
            <tag> directx11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之JSON学习</title>
      <link href="/2019/08/07/JSON/"/>
      <url>/2019/08/07/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>JSON格式</li><li>解析JSON文件</li><li>修改JSON文件</li></ul><h1 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/29119549" target="_blank" rel="noopener">十分钟搞定JSON和JSON对象</a></li></ul><p>想要使用JSO相关工具，必须在<strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;,         &quot;Json&quot;,         &quot;JsonUtilities&quot;    });</code></pre><h1 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h1><ul><li>我们在 \Content\Res\Data.json中天下如下测试例子</li></ul><pre><code class="json">/** Data.json **/[    {        &quot;1-1&quot;:&quot;1-1&quot;,        &quot;1-2&quot;:&quot;1-2&quot;    },    {        &quot;2-1&quot;:&quot;2-1&quot;    },    {        &quot;3-1&quot;:        [            {                &quot;1&quot;:&quot;3-1-1&quot;            },            {                &quot;2&quot;:&quot;3-1-2&quot;            }        ]    }]</code></pre><ul><li>我们要首先得将他以字符串的形式读入<blockquote><p>FPaths::GameContentDir() 能获取 */Content/ 的位置<br>FFileHelper::LoadFileToString() Load a text file to an FString.</p></blockquote></li></ul><pre><code class="cpp">bool MyJsonHandle::LoadStringFromFile(FString &amp; RelativePathName, FString &amp; FileName, FString &amp; ResultString){    if (!FileName.IsEmpty())    {        FString AbsloutePathName = FPaths::GameContentDir() + RelativePathName + FileName;        if (FPaths::FileExists(AbsloutePathName))        {            if (FFileHelper::LoadFileToString(ResultString, *AbsloutePathName))            {                return true;            }        }    }    return false;}</code></pre><ul><li>接下来我们来解析我们所获取到的FString</li></ul><pre><code class="cpp">/** MyJsonHandle.cpp **/bool MyJsonHandle::RecordDataJsonRead(){    FString result;    //这是我们上面自定义的函数    LoadStringFromFile(RelativePathName, DataFileName, result);    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse;    TSharedRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(result);    if (FJsonSerializer::Deserialize(JsonReader, JsonParse))    { //这样解析后的节点全部存在JsonParse中        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-1&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[0]-&gt;AsObject()-&gt;GetStringField(FString(&quot;1-2&quot;)));        UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse[1]-&gt;AsObject()-&gt;GetStringField(FString(&quot;2-1&quot;)));        //如果对象是嵌套的，则需要再声明一次TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt;来获取        TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; JsonParse3 = JsonParse[2]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;3-1&quot;));        if (JsonParse3.IsValidIndex(0))        {            for (int cnt = 1; cnt &lt;= JsonParse3.Num(); ++cnt)            {                UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *JsonParse3[cnt-1]-&gt;AsObject()-&gt;GetStringField(FString::FromInt(cnt)));            }        }        else        {            UE_LOG(LogTemp, Warning, TEXT(&quot;error JsonParse3&quot;));        }        return true;    }    return false;}</code></pre><h1 id="修改JSON文件"><a href="#修改JSON文件" class="headerlink" title="修改JSON文件"></a>修改JSON文件</h1><h2 id="设置单个属性"><a href="#设置单个属性" class="headerlink" title="设置单个属性"></a>设置单个属性</h2><ul><li>通过下面的代码生成一个<pre><code class="cpp">/*** A Json Object is a structure holding an unordered set of name/value pairs.* In a Json file, it is represented by everything between curly braces {}.*/TSharedPtr&lt;FJsonObject&gt; Object1 = MakeShareable(new FJsonObject);Object1-&gt;SetStringField(&quot;1-1&quot;, &quot;1--1&quot;);Object1-&gt;SetStringField(&quot;1-2&quot;, &quot;1--2&quot;);TSharedPtr&lt;FJsonValueObject&gt; CultureValue = MakeShareable(new FJsonValueObject(CultureObject));</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4学习</title>
      <link href="/2019/08/07/UE4Menu/"/>
      <url>/2019/08/07/UE4Menu/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据<a href="https://ke.qq.com/course/301049?from=iosapp&_bid=167&_wv=3&ADUIN=1076613110&ADSESSION=1556776713&ADTAG=CLIENT.QQ.5611_.0&ADPUBNO=26886&taid=2114631443453945" target="_blank" rel="noopener">UE4纯C++与Slate开发沙盒游戏</a>的内容归纳成笔记。以及参考<a href="https://blog.csdn.net/qq_20309931/article/details/53289032" target="_blank" rel="noopener">Unreal Engine 4 C++ Slate 介绍</a>的博客</p><h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><p><a href="https://sanctorum003.github.io/2019/08/02/HUD/" target="_blank" rel="noopener">虚幻4之Slate学习一 —— HUD</a><br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a><br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a><br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a><br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Menu </category>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
            <tag> json </tag>
            
            <tag> menu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习四 —— 委托与宏</title>
      <link href="/2019/08/06/DelegateAndMacro/"/>
      <url>/2019/08/06/DelegateAndMacro/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>了解虚幻4委托</li><li>了解Slate相关宏</li><li>了解Slate控件的相关回调函数</li></ul><h1 id="虚幻4委托"><a href="#虚幻4委托" class="headerlink" title="虚幻4委托"></a>虚幻4委托</h1><ul><li>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。</li><li>简单来说，delegate实现了将一个方法传递给其他类，使得其他的类在编译时期内不需要了解具体是什么方法被调用，而只是知道这个被调用方法的函数签名。有点类似于C++中函数指针的存在。</li></ul><h2 id="Delegate宏"><a href="#Delegate宏" class="headerlink" title="Delegate宏"></a>Delegate宏</h2><ul><li>虚幻4用c++封装了自定义的委托，提供各种参数和返回值可供使用。</li></ul><table><thead><tr><th>函数签名</th><th>声明宏</th></tr></thead><tbody><tr><td>void Function()</td><td>DECLARE_DELEGATE( DelegateName )</td></tr><tr><td>void Function( <param1> )</param1></td><td>DECLARE_DELEGATE_OneParam( DelegateName, Param1Type )</td></tr><tr><td>void Function( <param1>, <param2>, … )</param2></param1></td><td>DECLARE_DELEGATE_<num>Params( DelegateName, Param1Type, Param2Type, … )</num></td></tr><tr><td><retval> Function()</retval></td><td>DECLARE_DELEGATE_RetVal( RetValType, DelegateName )</td></tr><tr><td><retval> Function( <param1> )</param1></retval></td><td>DECLARE_DELEGATE_RetVal_OneParam( RetValType, DelegateName, Param1Type )</td></tr><tr><td><retval> Function( <param1>, <param2>, …  )</param2></param1></retval></td><td>DECLARE_DELEGATE_RetVal_<num>Params( RetValType, DelegateName, Param1Type, Param2Type, … )</num></td></tr></tbody></table><h2 id="声明Delegate变量"><a href="#声明Delegate变量" class="headerlink" title="声明Delegate变量"></a>声明Delegate变量</h2><ul><li>利用刚定义的宏声明一个Delegate变量，注意变量类型是上述的DelegateName。</li><li>这个成员变量就是未来我们可以用来动态绑定其他和之前在宏声明的一样的函数签名的方法</li></ul><pre><code class="CPP">DelegateName MyDelegate</code></pre><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>Bind()<blockquote><p>直接Bind一个已经存在的Delegate</p></blockquote></li><li>BindRaw()<blockquote><p>绑定c++原生指针，非smart指针</p></blockquote></li><li>BindUobject()<blockquote><p>绑定继承自UObject的类</p></blockquote></li><li>BindUFUCNTION()<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li><li>BindSP<blockquote><p>绑定智能指针</p></blockquote></li><li>BindStatic<blockquote><p>绑定的类成员方法是UFUNCTION</p></blockquote></li></ul><h2 id="调用代理方法"><a href="#调用代理方法" class="headerlink" title="调用代理方法"></a>调用代理方法</h2><ul><li><p>调用代理的方法就相对的简单，我们只需要使用下方方法即可。当然如果这个delegate是含参数的，可以在其中添加参数。这样所绑定的方法就会被调用，类似于通过函数指针来调用。</p><pre><code class="cpp">MyDelegateMemVar.Execute(）</code></pre><pre><code class="cpp">MyDelegateMemVar.Execute(Param1, Param2 ...)</code></pre></li><li><p>IsBound()用于判断委托是否绑定</p><pre><code class="cpp">MyDelegateMemVar.IsBound()</code></pre></li><li><p>ExecuteIfBound(…)用于如果绑定特定内容则执行</p><pre><code class="cpp">MyDelegateMemVar.ExecuteIfBound(...)</code></pre></li></ul><h1 id="Slate宏（macro）"><a href="#Slate宏（macro）" class="headerlink" title="Slate宏（macro）"></a>Slate宏（macro）</h1><ul><li>Slate框架结合了声明式语法，并且提供了一套完整的宏来简化声明及创建新控件的过程。下面就来学习一下slate创建中一些常见的宏：</li></ul><h2 id="SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS"><a href="#SLATE-BEGIN-ARGS-WidgetType-和SLATE-END-ARGS" class="headerlink" title="SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()"></a>SLATE_BEGIN_ARGS(WidgetType)和SLATE_END_ARGS()</h2><ul><li>Widgets的创建者可以使用SLATE_BEGIN_ARGS和SLATE_END_ARGS来声明和构建一个Widget,使得Widget可以通过SNew()和SAssignNew()来创建一个Widget,从而可以添加到用户视口.</li><li>其内部可放置相关参数<pre><code class="cpp">SLATE_BEGIN_ARGS(SSlAiMenuItemWidget){} SLATE_ATTRIBUTE(FText, ItemText) SLATE_EVENT(FItemClicked, MyOnClicked) SLATE_ATTRIBUTE(EMenuItem::Type,ItemType)SLATE_END_ARGS()</code></pre>定义上述参数后，可以进行赋值等操作<pre><code class="cpp">SNew(SSlAiMenuItemWidget).ItemText(NSLOCTEXT(&quot;SlAiMenu&quot;,&quot;StartGame&quot;,&quot;StartGame&quot;)).ItemType(EMenuItem::StartGame).MyOnClicked(this,&amp;SSlAiMenuWidget::MenuItemOnClicked)</code></pre></li></ul><h2 id="SLATE-ATTRIBUTE（AttrType-AttrName）"><a href="#SLATE-ATTRIBUTE（AttrType-AttrName）" class="headerlink" title="SLATE_ATTRIBUTE（AttrType,AttrName）"></a>SLATE_ATTRIBUTE（AttrType,AttrName）</h2><ul><li>Use this macro to add a attribute to the declaration of your widget.</li><li>An attribute can be a value or a function.<blockquote><p>使用这个宏可以为你正在声明的Widget添加一个属性(TAttribute&lt;&gt;类型).</p></blockquote></li></ul><blockquote><p>一个属性可以是一个值或者方法参数</p></blockquote><blockquote><p>AttrType：属性类型，可以是任意数据类型<br>AttrName：属性名</p></blockquote><h2 id="SLATE-ARGUMENT-ArgType-ArgName"><a href="#SLATE-ARGUMENT-ArgType-ArgName" class="headerlink" title="SLATE_ARGUMENT(ArgType, ArgName)"></a>SLATE_ARGUMENT(ArgType, ArgName)</h2><ul><li>Use this macro to declare a slate argument.</li><li>Arguments differ from attributes in that they can only be values.<blockquote><p> 使用这个宏可以为你的正在构建的Widget声明一个参数，这个参数不是一个TAttribute&lt;&gt;类型（属性），只是一个一般数据类型的变量</p></blockquote></li></ul><blockquote><p>  Argumet和Attribute的区别在于Argument只能是一个值，而Attitude可以是一个值或者方法，并且可以为其绑定代理。</p></blockquote><h2 id="SLATE-EVENT-DelegateName-EventName"><a href="#SLATE-EVENT-DelegateName-EventName" class="headerlink" title="SLATE_EVENT(DelegateName,EventName)"></a>SLATE_EVENT(DelegateName,EventName)</h2><ul><li>用于自定义事件委托</li><li>注意与<strong>事件</strong>是不一样的</li><li>可以用于创建自定义单击事件<blockquote><p>SLATE_EVENT( FOnClicked, OnClicked )</p></blockquote></li></ul><h2 id="FORCEINLINE"><a href="#FORCEINLINE" class="headerlink" title="FORCEINLINE"></a>FORCEINLINE</h2><ul><li>虚幻4自定义的声明内敛函数的宏<blockquote><p>FORCEINLINE void Debug(FString Message, float duration)</p></blockquote></li></ul><h1 id="常用Slate控件函数"><a href="#常用Slate控件函数" class="headerlink" title="常用Slate控件函数"></a>常用Slate控件函数</h1><h2 id="OnClicked"><a href="#OnClicked" class="headerlink" title="OnClicked"></a>OnClicked</h2><ul><li><p>事件原型</p><pre><code class="cpp">/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked )</code></pre></li><li><p>FOnClicked原型</p><pre><code class="cpp">/*** A delegate that is invoked when widgets want to notify a user that they have been clicked.* Intended for use by buttons and other button-like widgets.*/DECLARE_DELEGATE_RetVal(   FReply,   FOnClicked )// FReply FOnClicked()</code></pre></li><li><p>因此OnClicked()调用的函数的函数原型必须是FReply FOnClicked()</p></li><li><p>FReply 告诉引擎如何处理事件</p><blockquote><p>A Reply is something that a Slate event returns to the system to notify it about certain aspect of how an event was handled. For example, a widget may handle an OnMouseDown event by asking the system to give mouse capture to a specific Widget. To do this, return FReply::CaptureMouse( NewMouseCapture ).</p></blockquote></li><li><p>FReply::Handled() 告诉引擎事件处理完</p><blockquote><p>An event should return a FReply::Handled() to let the system know that an event was handled.</p></blockquote></li></ul><ul><li>下面举一个例子</li></ul><pre><code class="cpp">/** SMyHUDWidget.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Widgets/SCompoundWidget.h&quot;#include &quot;DeclarativeSyntaxSupport.h&quot;#include &quot;MySlateWidgetStyle.h&quot;#include &quot;SImage.h&quot;class MYSLATE_API SMyHUDWidget : public SCompoundWidget{public:    SLATE_BEGIN_ARGS(SMyHUDWidget)    {}    SLATE_END_ARGS()    // Constructs this widget with InArgs     void Construct(const FArguments&amp; InArgs);    //注意SAssignNew需要使用共享指针    TSharedPtr&lt;SImage&gt; MyImage;private:    const FMySlateStyle *MySlateStyle;    FReply addImage();};</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            SAssignNew(MyImage, SImage)        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    return FReply::Handled();}</code></pre><p>效果如下图<br><img src="onClick.png" alt><br><img src="onClicked.png" alt></p><h2 id="SOverlay-Expose和SOverlay-FOverlaySlot"><a href="#SOverlay-Expose和SOverlay-FOverlaySlot" class="headerlink" title="SOverlay::Expose和SOverlay::FOverlaySlot"></a>SOverlay::Expose和SOverlay::FOverlaySlot</h2><ul><li><p>上述两个结合使用可以获取SOverlay的插槽作为变量使用</p></li><li><p>在OnClicked的例子中修改</p></li></ul><pre><code class="cpp">/** SMyHUDWidget.h **/public:    //注意SOverlay::FOverlaySlot 是内部类    SOverlay::FOverlaySlot* MySlot;</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/+ SOverlay::Slot().HAlign(HAlign_Center)//这些属性设计是应用于插槽.VAlign(VAlign_Center).Expose(MySlot)[    SNew(SButton)    .OnClicked(this,&amp;SMyHUDWidget::addImage)]</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::addImage(){    MyImage-&gt;SetImage(&amp;MySlateStyle-&gt;BackGroupBrush);    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><p>点击后按钮到最左侧<br><img src="FOverlaySlot.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>我们尝试编写图片的点击效果，来使用委托和宏。SImage默认不带这个效果。</li><li>首先我们创建一个继承于SlateWidget的C++类命名为MyImage</li><li>创建一个委托，用于与SLATE_EVENT绑定。相当于自定义一个需要单击会触发函数的函数原型</li></ul><pre><code class="cpp">/** SMyImage.h **/DECLARE_DELEGATE_RetVal(FReply,FImageOnClicked)</code></pre><ul><li>创建一个SLATE_EVENT,将之前创建的委托与该SLATE_EVENT绑定</li></ul><pre><code class="cpp">/** SMyImage.cpp **/SLATE_BEGIN_ARGS(SMyHUDWidget){}SLATE_EVENT(FImageOnClicked, ImageOnClicked)SLATE_END_ARGS()</code></pre><ul><li>然后在原来的SMyHUDWidget将SImage换成SMyImage并且可以调用ImageOnClicked()</li></ul><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;#include &quot;SOverlay.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SOverlay)        + SOverlay::Slot()        .HAlign(HAlign_Fill)        .VAlign(VAlign_Fill)        [            /**              * TSharedPtr&lt;SMyImage&gt; MyImage;            **/            SAssignNew(MyImage, SMyImage)            //.ImageOnClicked()        ]        + SOverlay::Slot()        .HAlign(HAlign_Center)//这些属性设计是应用于插槽        .VAlign(VAlign_Center)        .Expose(MySlot)        [            SNew(SButton)            .OnClicked(this,&amp;SMyHUDWidget::addImage)        ]    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATIONFReply SMyHUDWidget::addImage(){    //删除原来语句    MySlot-&gt;HAlign(HAlign_Left);    return FReply::Handled();}</code></pre><ul><li>在SMyImage中添加图片</li></ul><pre><code class="cpp">/** SMyImage.cpp **/#include &quot;SMyImage.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SImage.h&quot;#include &quot;Public/UI/MySlateWidgetStyle.h&quot;#include &quot;Public/UI/MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyImage::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>此时效果如下<br><img src="MyImage.png" alt></p><ul><li>接着我们需要创建一个回调函数用于ImageOnClicked()，传入后event对应FImageOnClicked就绑定该函数了</li></ul><pre><code class="cpp">/** SMyHUDWidget.cpp **/FReply SMyHUDWidget::ImageClicked(){    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Green, &quot;Suceess&quot;);    return FReply::Handled();}</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **//**    * TSharedPtr&lt;SMyImage&gt; MyImage;**/SAssignNew(MyImage, SMyImage).ImageOnClicked(this, &amp;SMyHUDWidget::ImageClicked)</code></pre><ul><li>但是这时候会发现，单击并没有什么效果。这是因为程序并不知道要根据单击触发。</li><li>我们需要在MyImage中重写鼠标相关函数</li></ul><pre><code class="cpp">/** SMyImage.h **/public:    FImageOnClicked ImageOnClick;    virtual FReply OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual FReply OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent) override;    virtual void OnMouseLeave(const FPointerEvent&amp; MouseEvent) override;    bool BIsMouseButtonDown = false;</code></pre><ul><li>我们这时候需要在鼠标按下时调用委托，使用我们必须事先获取到这个委托，<em>FImageOnClicked ImageOnClick</em>就是用来声明该委托。</li><li>在构造中,通过InArgs._*可以来获取SLATE_BEGIN_ARGS(SMyHUDWidget)和SLATE_END_ARGS()之间的属性。</li></ul><pre><code class="cpp">/** SMyImage.cpp **/void SMyImage::Construct(const FArguments&amp; InArgs){    ImageOnClick = InArgs._ImageOnClicked;    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}</code></pre><ul><li>这样我们就可以重写鼠标事件，让其在点击时调用相关委托</li></ul><pre><code class="cpp">FReply SMyImage::OnMouseButtonDown(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = true;    return FReply::Handled();}FReply SMyImage::OnMouseButtonUp(const FGeometry&amp; MyGeometry, const FPointerEvent&amp; MouseEvent){    if (BIsMouseButtonDown == true)    {        BIsMouseButtonDown = false;        ImageOnClick.Execute();    }    return FReply::Handled();}void SMyImage::OnMouseLeave(const FPointerEvent&amp; MouseEvent){    BIsMouseButtonDown = false;}</code></pre><ul><li>到此就完成了，点击图片时会显示<strong>SUCCEESS</strong><br><img src="Success.png" alt><blockquote><p>如果不成功可以尝试将播放模式设成模拟<br><img src="Simulation.png" alt></p></blockquote></li></ul><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/07/JSON/" target="_blank" rel="noopener">虚幻4之JSON学习</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习三 —— 创建Slate控件</title>
      <link href="/2019/08/04/SlateWidget/"/>
      <url>/2019/08/04/SlateWidget/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>如何利用C++编写Slate控件</li><li>介绍常用的Slate控件</li><li>自定义DPI</li></ul><h1 id="用C-编写Slate控件"><a href="#用C-编写Slate控件" class="headerlink" title="用C++编写Slate控件"></a>用C++编写Slate控件</h1><pre><code class="cpp">ChildSlot[    SNew(SImage)    .Image(&amp;MySlateStyle-&gt;BackGroupBrush)];</code></pre><p>只需要在ChildSlot中编写相关代码就可以创建控件。不同控件有不同的属性，下面将要介绍一些常用的控件,值得注意的是对于需要在游戏中动态控制的控件，需利用SAssignNew,再通过共享指针保存起来</p><h2 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h2><ul><li>用于实现重叠部件,可以创建任意个插件，即可以放任意个子控件</li></ul><h3 id="HAlign和VAlign"><a href="#HAlign和VAlign" class="headerlink" title="HAlign和VAlign"></a>HAlign和VAlign</h3><ul><li>设计布局方式</li></ul><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><ul><li>设计边缘空隙</li></ul><h3 id="FillWidth和FillHeight"><a href="#FillWidth和FillHeight" class="headerlink" title="FillWidth和FillHeight"></a>FillWidth和FillHeight</h3><ul><li>填充宽度和高度</li></ul><h3 id="SOverlay-Slot"><a href="#SOverlay-Slot" class="headerlink" title="+SOverlay::Slot()"></a>+SOverlay::Slot()</h3><ul><li>+SOverlay::Slot()与SNew().AddSlot等价。增加的插槽下用于放子控件</li></ul><pre><code class="cpp">SNew(SOverlay)+ SOverlay::Slot()//这些属性设计是应用于插槽.HAlign(HAlign_Fill).VAlign(VAlign_Fill)[     SNew(SImage)     //image()用于添加笔刷     .Image(&amp;MySlateStyle-&gt;BackGroupBrush)]</code></pre><p><img src="SOverlay.png" alt></p><h2 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h2><ul><li>Image()通过加笔刷来显示图片</li><li>ColorAndOpacity()改变颜色和透明度</li></ul><h2 id="SBox"><a href="#SBox" class="headerlink" title="SBox"></a>SBox</h2><ul><li>只能添加一个子组件</li><li>WidthOverride和HeightOverride设置长宽</li><li>对应UMG中的SizeBox</li></ul><h2 id="SBorder"><a href="#SBorder" class="headerlink" title="SBorder"></a>SBorder</h2><ul><li>可放子控件，可显示图片</li><li>用BorderImage添加图片</li></ul><h2 id="STextBlock"><a href="#STextBlock" class="headerlink" title="STextBlock"></a>STextBlock</h2><ul><li>用于添加文字</li><li>Font()设置字体（不是指针）</li><li>Text()设置显示文字</li></ul><h2 id="SVerticalBox"><a href="#SVerticalBox" class="headerlink" title="SVerticalBox"></a>SVerticalBox</h2><ul><li>垂直容器</li><li>可以加插槽</li><li>+SVerticalBox::Slot == AddSlot</li></ul><h2 id="SCheckBox"><a href="#SCheckBox" class="headerlink" title="SCheckBox"></a>SCheckBox</h2><ul><li>OnCheckStateChanged：传入函数指针（委托），状态改变时调用</li></ul><h2 id="SSlider"><a href="#SSlider" class="headerlink" title="SSlider"></a>SSlider</h2><ul><li>滑动条</li><li>滑动条样式用 FSliderStyle</li><li>OnValueChanged(Delegate) 此为SLATE_EVENT，里面应该传入一参数（滑动条value）委托，每次滑动条value改变时调用。</li><li>SetValue()设置滑动位置，范围[0f,1f]</li></ul><h1 id="自定义DPI"><a href="#自定义DPI" class="headerlink" title="自定义DPI"></a>自定义DPI</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/06/DelegateAndMacro/" target="_blank" rel="noopener">虚幻4之Slate学习四 —— 委托与宏</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习二 —— Slate控件样式</title>
      <link href="/2019/08/03/WidgetStyle/"/>
      <url>/2019/08/03/WidgetStyle/</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><ul><li>自定义控件样式</li><li>生成样式集合，用于加载和引用我们的样式</li></ul><h1 id="简单梳理"><a href="#简单梳理" class="headerlink" title="简单梳理"></a>简单梳理</h1><p>为了能够在控件上显示自定义的各类属性，使用我们要使用自定义的控件样式。使用我们需要创建一个基于SlateWidgetSytle的C++类。在这里可以定义许多的自定义样式。比如最常用的FSlateBrush用于显示图片，FSlateFontInfo用于表示字体信息。接着我们思考的是怎么指定这些相关属性，即怎么指定图片等信息。有两个方法，一是直接用硬编码，指定文件地址。二是转变成蓝图类，可视化选择我们指定的内容。使用现在的问题是如何让在不同地方的Slate控件能够获取获取到这些内容。这里的方法是写一个<strong>单例</strong>，并在GameModule中生成唯一实例以供调用。</p><h1 id="定义自定义Slate控件样式"><a href="#定义自定义Slate控件样式" class="headerlink" title="定义自定义Slate控件样式"></a>定义自定义Slate控件样式</h1><p>创建基于SlateWidgetStyle的C++类MySlateWidgetStyle，在UE4 Editor中的内容浏览器中创建自定义的控件样式蓝图，并选择样式为刚创建的C++类，命名为BP_MySlateWidgetStyle,具体操作如图:</p><p><img src="Menu.png" alt></p><p><img src="SlateStyle.png" alt></p><hr><p>可以测试一下是否成功,添加如下代码</p><pre><code class="cpp">/** MySlateWidgetStyle.h 部分代码 **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Styling/SlateWidgetStyle.h&quot;#include &quot;SlateWidgetStyleContainerBase.h&quot;#include &quot;SlateBrush.h&quot;#include &quot;MySlateWidgetStyle.generated.h&quot;/** *  */USTRUCT()struct MYSLATE_API FMySlateStyle : public FSlateWidgetStyle{    GENERATED_USTRUCT_BODY()    FMySlateStyle();    virtual ~FMySlateStyle();    // FSlateWidgetStyle    virtual void GetResources(TArray&lt;const FSlateBrush*&gt;&amp; OutBrushes) const override;    static const FName TypeName;    virtual const FName GetTypeName() const override { return TypeName; };    static const FMySlateStyle&amp; GetDefault();    //code needed to write     UPROPERTY(EditAnyWhere, Category = MenuHUD)    FSlateBrush BackGroupBrush;};</code></pre><p>这样在BP_MySlateWidgetStyle中产生如下效果<br><img src="Brush.png" alt></p><h1 id="自定义单例类"><a href="#自定义单例类" class="headerlink" title="自定义单例类"></a>自定义单例类</h1><p>接下来再来捋一下接下来的思路，我们需要在MyHUDWidget中获取到我们蓝图类中的样式。这里我们可以通过<a href="https://api.unrealengine.com/INT/API/Runtime/SlateCore/Styling/ISlateStyle/GetWidgetStyle/index.html" target="_blank" rel="noopener">ISlateStyle::GetWidgetStyle</a>。所以我们需要有一个ISlateStyle，这里我们可以通过得到FSlateStyleSet，它是继承于ISlateStyle的，可以直接隐式转换。接着我们<a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Slate/FSlateGameResources/New/index.html" target="_blank" rel="noopener">FSlateGameResources::New</a>函数来获取蓝图类中的所有样式生成FSlateStyleSet。而这一些列操作需要一个单列来实现，而单例也需要在某个地方实例化。</p><hr><p>创建一个不继承任何类的类，命名为MyStyle。单例模式大同小异，可以按照如下进行模仿</p><pre><code class="cpp">/** MyStyle.h **/#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;ISlateStyle.h&quot;/** *  */class MYSLATE_API MyStyle{public:    static void Initialze();    static FName GetStyleSetName();    static void ShutDown();    static const ISlateStyle&amp; Get();private:    static TSharedRef&lt;class FSlateStyleSet&gt; Create();    static TSharedPtr&lt;class FSlateStyleSet&gt; MytyleInstance;};</code></pre><pre><code class="cpp">/** MyStyle.cpp **/#include &quot;MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;#include &quot;SlateGameResources.h&quot;//由于此单例不用构造函数，所以成员初始化写在这里TSharedPtr&lt;FSlateStyleSet&gt; MyStyle::MyStyleInstance = NULL;void MyStyle::Initialze(){    if (!MyStyleInstance.IsValid())    {        MyStyleInstance = Create();        FSlateStyleRegistry::RegisterSlateStyle(*MyStyleInstance);    }}FName MyStyle::GetStyleSetName(){    const static FName MyStyleName(TEXT(&quot;BP_MySlateWidgetStyle&quot;));    return MyStyleName;}void MyStyle::ShutDown(){    FSlateStyleRegistry::UnRegisterSlateStyle(*MyStyleInstance);    ensure(MyStyleInstance.IsUnique());    MyStyleInstance.Reset();}const ISlateStyle&amp; MyStyle::Get(){    return *MyStyleInstance;}TSharedRef&lt;class FSlateStyleSet&gt; MyStyle::Create(){    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(GetStyleSetName(), &quot;/Game/&quot; , &quot;/Game/&quot;);    return StyleRef;}</code></pre><h2 id="注册和注销"><a href="#注册和注销" class="headerlink" title="注册和注销"></a>注册和注销</h2><ul><li>RegisterSlateStyle:Add a slate style to the repository.</li><li>UnRegisterSlateStyle:Removes a slate style from the repository.</li></ul><p>猜测:用于在 Static initialization时预加载我们需要的样式</p><h2 id="FSlateStyleSet"><a href="#FSlateStyleSet" class="headerlink" title="FSlateStyleSet"></a>FSlateStyleSet</h2><ul><li>一个Slate样式块，包含一组指定Slate外观的命名属性。</li></ul><h2 id="共享指针和共享引用"><a href="#共享指针和共享引用" class="headerlink" title="共享指针和共享引用"></a>共享指针和共享引用</h2><p>注意的是这两个都是指针，主要区别是TSharedRef&lt;&gt;不能指向空，且TSharedPtr&lt;&gt;可以隐式转换成TSharedRef&lt;&gt;，所有这里声明时用的是TSharedPtr&lt;&gt;</p><h1 id="创建单例实例"><a href="#创建单例实例" class="headerlink" title="创建单例实例"></a>创建单例实例</h1><ul><li>FDefaultGameModuleImpl中的StartupModule()和ShutdownModule()这两个函数会在加载(卸载)dll和模块后立刻调用,我们可以利用来生成实例。在MySlate中写如下代码:<pre><code class="cpp">/**  MySlate.h **/class FMySlateModule : public FDefaultGameModuleImpl{public:     virtual void StartupModule() override;     virtual void ShutdownModule() override;};</code></pre></li><li>FDefaultGameModuleImpl:Default minimal module class for gameplay modules. Does nothing at startup and shutdown.</li><li>所以上述其实就是自定义了一个模块</li></ul><pre><code class="cpp">/** MySlate.cpp **/#include &quot;MySlate.h&quot;#include &quot;Modules/ModuleManager.h&quot;#include &quot;Public/UI/MyStyle.h&quot;#include &quot;SlateStyleRegistry.h&quot;IMPLEMENT_PRIMARY_GAME_MODULE(FMySlateModule, MySlate, &quot;MySlate&quot; );void FMySlateModule::StartupModule(){    //先取消注册，保证不会重复注册    FSlateStyleRegistry::UnRegisterSlateStyle(MyStyle::GetStyleSetName());    MyStyle::Initialze();}void FMySlateModule::ShutdownModule(){    MyStyle::ShutDown();}</code></pre><ul><li>在您的游戏中，至少要使用IMPLEMENT_PRIMARY_GAME_MODULE注册一个模块。其他模块可以使用另一个可选的IMPLEMENT_GAME_MODULE方法进行注册。</li><li>所要使用的模组，注意默认是FDefaultGameModuleImpl,所以这里我们改为FMySlateModule</li><li><a href="https://docs.unrealengine.com/zh-CN/Programming/Modules/Gameplay/index.html" target="_blank" rel="noopener">更多关于Module可以看官方手册</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样我们就定义好了我们的控件样式，我们来测试一下是否成功，在样式蓝图中选择一张图片，并添加如下代码<br><img src="Sytle.png" alt></p><pre><code class="cpp">/** SMyHUDWidget.h 部分代码**/#include &quot;MySlateWidgetStyle.h&quot;private:    const FMySlateStyle *MySlateStyle;</code></pre><pre><code class="cpp">/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;#include &quot;SImage.h&quot;#include &quot;MyStyle.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    MySlateStyle = &amp;MyStyle::Get().GetWidgetStyle&lt;FMySlateStyle&gt;(&quot;BP_MySlateWidgetStyle&quot;);    ChildSlot    [        SNew(SImage)        .Image(&amp;MySlateStyle-&gt;BackGroupBrush)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><ul><li><strong>注意MyStyle::Get()返回的是一个集合</strong>,所以我们需要使用GetWidgetStyle<fmyslatestyle>(“BP_MySlateWidgetStyle”)来获取我们所定义的蓝图样式。</fmyslatestyle></li></ul><p>上述运行结果<br><img src="result.png" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/04/SlateWidget/" target="_blank" rel="noopener">虚幻4之Slate学习三 —— 创建Slate控件</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4之Slate学习一 —— HUD</title>
      <link href="/2019/08/02/HUD/"/>
      <url>/2019/08/02/HUD/</url>
      
        <content type="html"><![CDATA[<h1 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h1><ul><li>为项目添加Slate依赖库</li><li>创建容纳各种Widget的HUD类</li><li>创建自定义Widget类并将其添加到视口</li><li>设置光标的相关属性</li></ul><h1 id="Slate库"><a href="#Slate库" class="headerlink" title="Slate库"></a>Slate库</h1><p>想要使用Slate的库，必须在项目工程中包含相关的依赖库。在VS工程中找到  <strong>ProjectName.Build.cs</strong>，在其中添加</p><pre><code class="cs">PublicDependencyModuleNames.AddRange(    new string[]     {         &quot;Core&quot;,          &quot;CoreUObject&quot;,          &quot;Engine&quot;,          &quot;InputCore&quot;,         &quot;Slate&quot;,         &quot;SlateCore&quot;    });</code></pre><p>这样我们就能使用Slate库了。</p><h1 id="创建HUD"><a href="#创建HUD" class="headerlink" title="创建HUD"></a>创建HUD</h1><h2 id="什么是HUD"><a href="#什么是HUD" class="headerlink" title="什么是HUD"></a>什么是HUD</h2><p>HUD是平视显示器的缩写，其与UI的有区别，但较难阐述。此处只需知道，Slate库使用HUD来作为容器，即在HUD中编写相关控件</p><h2 id="设置自定义HUD"><a href="#设置自定义HUD" class="headerlink" title="设置自定义HUD"></a>设置自定义HUD</h2><ul><li>创建一个继承于HUD的C++类，此处命名为MyHUD</li><li>在MySlateGameModeBase.cpp中将HUD class改为MyHUD<blockquote><p>也可以直接创建GameModeBase类，并在世界设置中改为自定义GameModeBase类</p></blockquote></li></ul><pre><code class="cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;AMySlateGameModeBase::AMySlateGameModeBase(){    HUDClass = AMyHUD::StaticClass();}</code></pre><p>这样在在初始化游戏时，就会默认调用自定义的HUD</p><h1 id="将自定义Widget添加到视口"><a href="#将自定义Widget添加到视口" class="headerlink" title="将自定义Widget添加到视口"></a>将自定义Widget添加到视口</h1><ul><li>先创建自定义Widget的C++类，起名为MyHUDWidget</li><li>在MyHUD的构建函数中将MyHUDWidget添加到视口，这样在开始游戏时将自动调用</li></ul><pre><code class="cpp">/** MyHUD.h **/private:    TSharedPtr&lt;class SMyHUDWidget&gt; HUDWidget;</code></pre><pre><code class="cpp">/** MyHUD.cpp **/AMyHUD::AMyHUD(){    if (GEngine &amp;&amp; GEngine-&gt;GameViewport)    {        SAssignNew(HUDWidget, SMyHUDWidget);        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(SNew(SWeakWidget).PossiblyNullContent(HUDWidget.ToSharedRef()));    }}</code></pre><h2 id="如何创建控件实例"><a href="#如何创建控件实例" class="headerlink" title="如何创建控件实例"></a>如何创建控件实例</h2><ul><li>创建控件实例有下面两种方法</li><li>SAssignNew(TSharedPtr<slatewidgetclassname>,SlateWidgetClassName);<blockquote><p>将创建的控件保存到共享指针中</p></blockquote></slatewidgetclassname></li><li>SNew(SlateWidgetClassName)</li></ul><h2 id="如何将MyHUDWidget从视口中添加和删除"><a href="#如何将MyHUDWidget从视口中添加和删除" class="headerlink" title="如何将MyHUDWidget从视口中添加和删除"></a>如何将MyHUDWidget从视口中添加和删除</h2><ul><li>将控件添加到视口中<pre><code class="cpp">TSharedPtr&lt;MyWidget&gt; MyWidgetPtr;GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent(  SNew(SWeakWidget).  PossiblyNullContent(MyWidgetPtr.ToSharedRef()));</code></pre></li><li>将控件从视口删除<pre><code class="cpp">GEngine-&gt;GameViewport-&gt;RemoveViewportWidgetContent(  SNew(MyWidgetPtr.ToSharedRef())); </code></pre></li><li>将视口中的全部控件删除<pre><code class="cpp">GEngine-&gt;GameViewport-&gt;RemoveAllViewportWidgets();</code></pre></li></ul><h1 id="设置光标"><a href="#设置光标" class="headerlink" title="设置光标"></a>设置光标</h1><ul><li>这里光标是默认的，我们需要让光标一直显示，不然对后面会有影像。</li><li>我们创建继承于PlayerController的MyController类。</li></ul><pre><code class="cpp">/** MyController.cpp **/AMyController::AMyController(){    /** Whether the mouse cursor should be displayed. */    bShowMouseCursor = true;}</code></pre><ul><li>我们还可以设置光标的移动范围</li></ul><pre><code class="cpp">/** MyController.cpp **/void AMyController::BeginPlay(){    /** Data structure used to setup an input mode that allows only the UI to respond to user input. */    FInputModeUIOnly InputMode;    /** Sets the mouse locking behavior of the viewport */    InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::LockAlways);    SetInputMode(InputMode);}</code></pre><ul><li>在Gamemode中应用，这样光标一直显示，且不能移出视口<pre><code class="cpp">/** MySlateGameModeBase.cpp **/#include &quot;MySlateGameModeBase.h&quot;#include &quot;Public\UI\MyHUD.h&quot;#include &quot;Public\MyController.h&quot;</code></pre></li></ul><p>AMySlateGameModeBase::AMySlateGameModeBase()<br>{<br>    HUDClass = AMyHUD::StaticClass();<br>    PlayerControllerClass = AMyController::StaticClass();<br>}</p><pre><code># 总结到目前为止,准备工作算是做好了。我们可以测试以下是否成功。在MyHUDWidget中添加代码```cpp/** SMyHUDWidget.cpp **/#include &quot;SMyHUDWidget.h&quot;#include &quot;SlateOptMacros.h&quot;#include &quot;SButton.h&quot;BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATIONvoid SMyHUDWidget::Construct(const FArguments&amp; InArgs){    ChildSlot    [        SNew(SButton)    ];}END_SLATE_FUNCTION_BUILD_OPTIMIZATION</code></pre><p>这样你将看到屏幕中一个全屏填满的按钮<br><img src="Button.png" alt></p><blockquote><p>如果无法编译,尝试在SMyHUDWidget中添加#include “DeclarativeSyntaxSupport.h”头文件</p></blockquote><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li>下章链接<br><a href="https://sanctorum003.github.io/2019/08/03/WidgetStyle/" target="_blank" rel="noopener">虚幻4之Slate学习二 —— Slate控件样式</a></li><li>章节总览<br><a href="https://sanctorum003.github.io/2019/08/07/SlateMenu/" target="_blank" rel="noopener">虚幻4之Slate学习</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> slate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2019/08/01/KMP/"/>
      <url>/2019/08/01/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="王道方法"><a href="#王道方法" class="headerlink" title="王道方法"></a>王道方法</h2><p><img src="kmp1.bmp" alt title="KMP1"></p><blockquote><p>1) next 数组从1开始</p></blockquote><blockquote><p>2) next[1] = 0<br>next[2] = 1<br>next[0]不使用</p></blockquote><blockquote><p>3) 求当next数组当前位置<strong>j</strong></p></blockquote><pre><code class="cpp">// 主要方法就是 将前一个位置(j-1)的字符与next[j-1]所对应的字符比较相同则 next[j] = next[j-1]+1;// 不同则 将next[j-1]的字符 与next[ next[j-1] ]对应否字符相比较相同则 next[j] = next[ next[j-1] ]+1;// 不断重复// 如果next[...] = 0 ==&gt; next[j] = 1;    k = next[j-1];     while(1)    {        if(S[k] == S[j-1])//S为字符数组        {            next[j] = k+1;            break;        }        else            k = next[k];    }</code></pre><h2 id="殷人昆"><a href="#殷人昆" class="headerlink" title="殷人昆"></a>殷人昆</h2><p><img src="kmp2.bmp" alt title="KMP2"></p><blockquote><p>可以直接看 前n个串中的最大 前缀等于后缀 的个数 即为 next[j]的值</p></blockquote><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><blockquote><p>1) next[1]=0</p></blockquote><blockquote><p>2) 从第j(j&gt;1)个开启 比较前j个的 最大 前缀等于后缀 </p></blockquote><h2 id="转换技巧-快速做选择题"><a href="#转换技巧-快速做选择题" class="headerlink" title="转换技巧[快速做选择题]"></a>转换技巧[快速做选择题]</h2><p><a href="http://www.cskaoyan.com/thread-650235-1-1.html" target="_blank" rel="noopener">http://www.cskaoyan.com/thread-650235-1-1.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><blockquote><p>规则1：用常见方法做出结果 </p></blockquote><blockquote><p>规则2：右移一位，最左边添-1，最右边自然溢出</p></blockquote><blockquote><p>规则3：全部加1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
